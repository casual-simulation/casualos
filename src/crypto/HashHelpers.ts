import { hmac, sha256 } from 'hash.js';
import stringify from '@casual-simulation/fast-json-stable-stringify';
import { randomBytes } from 'tweetnacl';
import { deriveKey } from './Encryption';
import { fromByteArray, toByteArray } from 'base64-js';

/**
 * Calculates the SHA-256 hash of the given object.
 * @param obj The object to calculate the hash of.
 */
export function getHash(obj: any): string {
    const json = stringify(obj);
    let sha = sha256();
    sha.update(json);
    return sha.digest('hex');
}

/**
 * Calculates the SHA-256 hash of the given object and
 * returns a byte buffer containing the hash.
 * @param obj The object to hash.
 */
export function getHashBuffer(obj: any): Buffer {
    const json = stringify(obj);
    let sha = sha256();
    sha.update(json);
    return Buffer.from(sha.digest());
}

/**
 * Creates a random password and returns it along with its hash.
 */
export function createRandomPassword() {
    const passwordBytes = randomBytes(16); // 128-bit password

    const passwordBase64 = fromByteArray(passwordBytes); // convert to human-readable string

    const hash = hashPassword(passwordBase64);

    return {
        password: passwordBase64,
        hash,
    };
}

/**
 * Hashes the given password using scrypt and returns the result.
 * @param password The password that should be hashed.
 */
export function hashPassword(password: string): string {
    if (!password) {
        throw new Error('Invalid password. Must not be null or undefined.');
    }
    const salt = randomBytes(16);
    const textEncoder = new TextEncoder();
    const passwordBytes = textEncoder.encode(password);

    const hashBytes = deriveKey(passwordBytes, salt);

    return `vP1.${fromByteArray(hashBytes.salt)}.${fromByteArray(
        hashBytes.hash
    )}`;
}

/**
 * Verifies that the given password matches the given hash.
 * @param password The password to check.
 * @param hash The hash to check the password against.
 */
export function verifyPassword(password: string, hash: string): boolean {
    if (!password) {
        throw new Error('Invalid password. Must not be null or undefined.');
    }
    if (!hash) {
        throw new Error('Invalid hash. Must not be null or undefined.');
    }
    if (!hash.startsWith('vP1.')) {
        throw new Error('Invalid hash. Must start with "vP1."');
    }
    const withoutVersion = hash.slice('vP1.'.length);
    let nextPeriod = withoutVersion.indexOf('.');
    if (nextPeriod < 0) {
        return false;
    }
    const saltBase64 = withoutVersion.slice(0, nextPeriod);
    const hashBase64 = withoutVersion.slice(nextPeriod + 1);
    if (hashBase64.length <= 0) {
        return false;
    }

    const textEncoder = new TextEncoder();
    const passwordBytes = textEncoder.encode(password);
    const salt = toByteArray(saltBase64);
    const hashBytes = deriveKey(passwordBytes, salt);
    return fromByteArray(hashBytes.hash) === hashBase64;
}

/**
 * Hashes the given password using the given salt and returns the resulting base64 encoded hash.
 * Should only be used for low-entropy passwords like 5-digit codes or passwords that were generated by a user themselves.
 * For high-entropy passwords, use hashHighEntropyPasswordWithSalt().
 *
 * Returns a V1 hash that indicates that scrypt was used for the hashing process.
 * @param password The password to hash.
 * @param salt The salt to use for the password. Must be a base64 encoded string.
 */
export function hashLowEntropyPasswordWithSalt(
    password: string,
    salt: string
): string {
    if (!password) {
        throw new Error('Invalid password. Must not be null or undefined.');
    }
    if (!salt) {
        throw new Error('Invalid salt. Must not be null or undefined.');
    }

    const textEncoder = new TextEncoder();
    const passwordBytes = textEncoder.encode(password);
    const saltBytes = toByteArray(salt);

    const hashBytes = deriveKey(passwordBytes, saltBytes);

    return `vH1.${fromByteArray(hashBytes.hash)}`;
}

/**
 * Hashes the given password with the given salt using HMAC-SHA-256 and returns the resulting base64 encoded hash.
 * This function is designed for high-entropy passwords (at least 128 bits of unguessable information) and is not designed
 * for regular passwords. Use hashLowEntropyPasswordWithSalt() for regular low-entropy passwords.
 *
 * Returns a V2 hash that indicates that HMAC-SHA-256 was used for the hashing process.
 * @param password The password that should be hashed.
 * @param salt The salt to use for the password. Must be a base64 encoded string.
 */
export function hashHighEntropyPasswordWithSalt(
    password: string,
    salt: string
): string {
    if (!password) {
        throw new Error('Invalid password. Must not be null or undefined.');
    }
    if (!salt) {
        throw new Error('Invalid salt. Must not be null or undefined.');
    }

    const textEncoder = new TextEncoder();
    const passwordBytes = textEncoder.encode(password);
    const saltBytes = toByteArray(salt);

    const h = hmac(<any>sha256, saltBytes);
    h.update(passwordBytes);
    const hashBytes = new Uint8Array(h.digest());
    return `vH2.${fromByteArray(hashBytes)}`;
}

/**
 * Validates that the given password and salt match at least one of the given hashes.
 * @param password The password to check.
 * @param salt The base64 encoded salt to use for the password.
 * @param hashes The hashes that they should match. These hashes should have been produced by hashLowEntropyPasswordWithSalt().
 */
export function verifyPasswordAgainstHashes(
    password: string,
    salt: string,
    hashes: string[]
): boolean {
    if (!password) {
        throw new Error('Invalid password. Must not be null or undefined.');
    }
    if (!salt) {
        throw new Error('Invalid salt. Must not be null or undefined.');
    }
    if (!hashes) {
        throw new Error('Invalid hashes. Must not be null or undefined.');
    }

    let version1Hashes = [] as string[];
    let version2Hashes = [] as string[];

    for (let hash of hashes) {
        if (hash.startsWith('vH1.')) {
            version1Hashes.push(hash);
        } else if (hash.startsWith('vH2.')) {
            version2Hashes.push(hash);
        }
    }

    if (version1Hashes.length <= 0 && version2Hashes.length <= 0) {
        throw new Error(
            'Invalid hashes. Must contain at least one valid hash.'
        );
    }

    const textEncoder = new TextEncoder();
    const passwordBytes = textEncoder.encode(password);
    const saltBytes = toByteArray(salt);

    if (version2Hashes.length > 0) {
        // Check version 2 hashes first since they are faster to compute.
        const h = hmac(<any>sha256, saltBytes);
        h.update(passwordBytes);
        const hashBytes = new Uint8Array(h.digest());
        const hashBase64 = fromByteArray(hashBytes);

        for (const hash of version2Hashes) {
            const withoutVersion = hash.slice('vH2.'.length);

            if (withoutVersion === hashBase64) {
                return true;
            }
        }
    }

    if (version1Hashes.length > 0) {
        const passwordHash = deriveKey(passwordBytes, saltBytes);
        const passwordHashBase64 = fromByteArray(passwordHash.hash);

        for (const hash of version1Hashes) {
            const withoutVersion = hash.slice('vH1.'.length);

            if (withoutVersion === passwordHashBase64) {
                return true;
            }
        }
    }

    return false;
}
