/**
 * Contains information about the version of AUX that is running.
 */
export interface AuxVersion {
    /**
     * The commit of the hash that AUX was built from.
     */
    hash: string;

    /**
     * The full version number.
     */
    version: string;

    /**
     * The major portion of the version.
     */
    major: number;

    /**
     * The minor portion of the version.
     */
    minor: number;

    /**
     * The patch portion of the version.
     */
    patch: number;
}

/**
 * Contains information about the device that AUX is running on.
 */
export interface AuxDevice {
    /**
     * Whether the device supports augmented reality features.
     */
    supportsAR: boolean;

    /**
     * Whether the device supports virtual reality features.
     */
    supportsVR: boolean;
}

/**
 * An interface for an object that contains a set of roles that a user has.
 */
declare interface DeviceInfo {
    /**
     * The list of roles.
     */
    roles: string[];

    /**
     * The claims that the device contains.
     * That is, information about the device which has been verified.
     */
    claims: {
        username: string;
        device_id: string;
        session_id: string;
        [key: string]: string;
    };
}

/**
 * Defines an interface that represents an event.
 * That is, a time-ordered action in a server.
 * @deprecated
 */
declare interface Action {
    /**
     * The type of the event.
     * This helps determine how the event should be applied to the state.
     */
    type: string;
}

/**
 * An event that is used to indicate an event that was sent from a remote device.
 */
declare interface DeviceAction extends Action {
    type: 'device';

    /**
     * The device which sent the event.
     */
    device: DeviceInfo;

    /**
     * The event.
     */
    event: Action;
}

/**
 * An interface that is used to determine which device to send a remote event to.
 */
declare interface DeviceSelector {
    /**
     * The ID of the session that the event should be sent to.
     */
    sessionId?: string;

    /**
     * The ID of the device that the event should be sent to.
     */
    deviceId?: string;

    /**
     * The username of the user that the event should be sent to.
     */
    username?: string;
}

/**
 * An event that is used to send events from this device to a remote device.
 */
declare interface RemoteAction extends Action, DeviceSelector {
    type: 'remote';

    /**
     * The event that should be sent to the device.
     */
    event: Action;

    /**
     * Whether this action is allowed to be batched with other remote actions.
     * Batching will preserve ordering between remote actions but may
     * break ordering with respect to bot actions. Defaults to true.
     */
    allowBatching?: boolean;
}

declare type LocalActions = BotActions | ExtraActions | AsyncActions;

/**
 * Defines a union type for all the possible events that can be emitted from a bots server.
 */
declare type BotAction =
    | BotActions
    | TransactionAction
    | ExtraActions
    | AsyncActions
    | RemoteAction
    | DeviceAction;

/**
 * Defines a union type for all the possible actions that manipulate the bot state.
 */
declare type BotActions =
    | AddBotAction
    | RemoveBotAction
    | UpdateBotAction
    | CreateCertificateAction
    | SignTagAction
    | RevokeCertificateAction
    | ApplyStateAction;
``;

/**
 * Defines a set of possible local event types.
 */
declare type ExtraActions =
    | ShoutAction
    | RejectAction
    | ShowToastAction
    | ShowHtmlAction
    | HideHtmlAction
    | OpenQRCodeScannerAction
    | OpenBarcodeScannerAction
    | ShowQRCodeAction
    | ShowBarcodeAction
    | LoadServerAction
    | UnloadServerAction
    | SuperShoutAction
    | SendWebhookAction
    | LoadFileAction
    | SaveFileAction
    | GoToDimensionAction
    | GoToURLAction
    | OpenURLAction
    | ImportAUXAction
    | ShowInputForTagAction
    | SetForcedOfflineAction
    | ShellAction
    | OpenConsoleAction
    | DownloadAction
    | BackupToGithubAction
    | BackupAsDownloadAction
    | StartCheckoutAction
    | CheckoutSubmittedAction
    | FinishCheckoutAction
    | PasteStateAction
    | ReplaceDragBotAction
    | SetupChannelAction
    | SetClipboardAction
    | ShowChatBarAction
    | RunScriptAction
    | ShowUploadAuxFileAction
    | MarkHistoryAction
    | BrowseHistoryAction
    | RestoreHistoryMarkAction
    | LoadSpaceAction
    | EnableARAction
    | EnableVRAction
    | ShowJoinCodeAction
    | RequestFullscreenAction
    | ExitFullscreenAction
    | LoadBotsAction
    | ClearSpaceAction
    | LocalFormAnimationAction
    | AddDropSnapTargetsAction
    | EnableCustomDraggingAction
    | EnablePOVAction
    | SetAppOutputAction;

/**
 * Defines a set of possible async action types.
 */
declare type AsyncActions =
    | AsyncResultAction
    | AsyncErrorAction
    | ShowInputAction
    | ShareAction
    | CreateCertificateAction
    | SignTagAction
    | RevokeCertificateAction
    | UnlockSpaceAction
    | SetSpacePasswordAction
    | BufferSoundAction
    | PlaySoundAction
    | CancelSoundAction
    | OpenCustomPortalAction
    | RegisterPrefixAction
    | FocusOnBotAction
    | FocusOnPositionAction
    | BeginRecordingAction
    | EndRecordingAction
    | SpeakTextAction
    | GetVoicesAction
    | GetGeolocationAction;

/**
 * Defines an interface for actions that represent asynchronous tasks.
 */
declare interface AsyncAction extends Action {
    /**
     * The ID of the async task.
     */
    taskId: number;
}

/**
 * Defines an action that supplies a result for an AsyncRequestAction.
 */
declare interface AsyncResultAction extends AsyncAction {
    type: 'async_result';

    /**
     * The result value.
     */
    result: any;
}

/**
 * Defines an action that supplies an error for an AsyncRequestAction.
 */
declare interface AsyncErrorAction extends AsyncAction {
    type: 'async_error';

    /**
     * The error.
     */
    error: any;
}

/**
 * Defines a bot event that indicates a bot was added to the state.
 */
declare interface AddBotAction extends Action {
    type: 'add_bot';
    id: string;
    bot: Bot;
}

/**
 * Defines a bot event that indicates a bot was removed from the state.
 */
declare interface RemoveBotAction extends Action {
    type: 'remove_bot';
    id: string;
}

/**
 * Defines a bot event that indicates a bot was updated.
 */
declare interface UpdateBotAction extends Action {
    type: 'update_bot';
    id: string;
    update: Partial<Bot>;
}


/**
 * Defines the set of options required for creating a certificate.
 */
export interface CreateCertificateOptions {
    /**
     * The keypair that should be used for the certificate.
     */
    keypair: string;

    /**
     * The ID of the certified bot that is signing the new certificate.
     */
    signingBotId?: string;

    /**
     * The password that should be used to sign the new certificate.
     */
    signingPassword: string;
}

/**
 * Defines a bot event that creates a new certificate from the given keypair.
 */
export interface CreateCertificateAction
    extends AsyncAction,
        CreateCertificateOptions {
    type: 'create_certificate';
}

/**
 * Defines a bot event that creates a signature for the given tag on the given bot using the given certified bot and password.
 */
export interface SignTagAction extends AsyncAction {
    type: 'sign_tag';

    /**
     * The ID of the certified bot that is signing the tag value.
     */
    signingBotId: string;

    /**
     * The password that should be used to sign the value.
     */
    signingPassword: string;

    /**
     * The ID of the bot whose tag is being signed.
     */
    botId: string;

    /**
     * The tag that should be signed.
     */
    tag: string;
}

/**
 * Defines a bot event that revokes a certificate.
 */
export interface RevokeCertificateAction extends AsyncAction {
    type: 'revoke_certificate';

    /**
     * The ID of the bot that should be used to sign the revocation.
     */
    signingBotId: string;

    /**
     * The password that should be used to sign the revocation.
     */
    signingPassword: string;

    /**
     * The ID of the certificate that should be revoked.
     */
    certificateBotId: string;
}

/**
 * A set of bot events in one.
 */
declare interface TransactionAction extends Action {
    type: 'transaction';
    events: BotAction[];
}

/**
 * An eventBotsStatesome generic BotsState to the current state.
 * This is useful when you have some generic bot state and want to just apply it to the
 * current state. An example of doing this is from the automatic merge system.
 */
declare interface ApplyStateAction extends Action {
    type: 'apply_state';
    state: BotsState;
}

/**
 * The options for pasting bots state into a server.
 */
declare interface PasteStateOptions {
    /**
     * The dimension that the state should be pasted into.
     */
    dimension?: string;

    /**
     * The X position that the state should be pasted at.
     * If a dimension is provided then this is the X position inside the dimension.
     * If a dimension is not provided then this is the X position that the new dimension should be created at.
     */
    x: number;

    /**
     * The Y position that the state should be pasted at.
     * If a dimension is provided then this is the Y position inside the dimension.
     * If a dimension is not provided then this is the Y position that the new dimension should be created at.
     */
    y: number;

    /**
     * The Z position that the state should be pasted at.
     * If a dimension is provided then this is the Z position inside the dimension.
     * If a dimension is not provided then this is the Z position that the new dimension should be created at.
     */
    z: number;
}

/**
 * An event to paste the given bots state as a new worksurface at a position.
 */
declare interface PasteStateAction extends Action {
    type: 'paste_state';
    state: BotsState;

    /**
     * The options for the event.
     */
    options: PasteStateOptions;
}

/**
 * An event that is used to override dragging a bot.
 */
declare interface ReplaceDragBotAction extends Action {
    type: 'replace_drag_bot';

    /**
     * The bot that should be used to drag.
     */
    bot: Bot | BotTags;
}

/**
 * An event that is used to request that the server be backed up to github.
 */
declare interface BackupToGithubAction extends Action {
    type: 'backup_to_github';

    /**
     * The authentication key to use.
     */
    auth: string;

    /**
     * The options that should be used for backing up.
     */
    options?: BackupOptions;
}

/**
 * An event that is used to request that the server be backed up to a zip bot and downloaded.
 */
declare interface BackupAsDownloadAction extends Action {
    type: 'backup_as_download';

    /**
     * The options that should be used for backing up.
     */
    options?: BackupOptions;

    /**
     * The device(s) that the download should be sent to.
     */
    target: DeviceSelector;
}

/**
 * Defines the list of possible options for backing up a server.
 */
declare interface BackupOptions {
    /**
     * Whether to include archived atoms.
     */
    includeArchived?: boolean;
}

declare interface StartCheckoutOptions {
    /**
     * The publishable API key that should be used for interfacing with the Stripe API.
     */
    publishableKey: string;

    /**
     * The ID of the product that is being checked out.
     */
    productId: string;

    /**
     * The title of the product.
     */
    title: string;

    /**
     * The description of the product.
     */
    description: string;

    /**
     * The server that the payment processing should occur in.
     */
    processingServer: string;

    /**
     * Whether to request the payer's billing address.
     */
    requestBillingAddress?: boolean;

    /**
     * Specifies the options that should be used for requesting payment from Apple Pay or the Payment Request API.
     */
    paymentRequest?: PaymentRequestOptions;
}

/**
 * Defines an interface of payment request options.
 */
declare interface PaymentRequestOptions {
    /**
     * The two letter country code of your payment processor account.
     */
    country: string;

    /**
     * The three character currency code.
     */
    currency: string;

    /**
     * The total that should be charged to the user.
     */
    total: {
        /**
         * The label that should be displayed for the total.
         */
        label: string;

        /**
         * The amount in the currency's smallest unit. (cents, etc.)
         */
        amount: number;
    };
}

/**
 * An event that is used to initiate the checkout flow.
 */
declare interface StartCheckoutAction extends Action, StartCheckoutOptions {
    type: 'start_checkout';
}

/**
 * An event that is used to indicate that the checkout was submitted.
 */
declare interface CheckoutSubmittedAction extends Action {
    type: 'checkout_submitted';

    /**
     * The ID of the product that was checked out.
     */
    productId: string;

    /**
     * The token that allows payment.
     */
    token: string;

    /**
     * The server that processing should happen in.
     */
    processingServer: string;
}

/**
 * An event that is used to finish the checkout process by charging the user's card/account.
 */
declare interface FinishCheckoutAction extends Action {
    type: 'finish_checkout';

    /**
     * The Secret API Key that should be used to finish the checkout process.
     */
    secretKey: string;

    /**
     * The token that was created from the checkout process.
     * You should have recieved this from the onCheckout() event.
     */
    token: string;

    /**
     * The amount to charge in the smallest currency unit.
     * For USD, this is cents. So an amount of 100 equals $1.00.
     */
    amount: number;

    /**
     * The currency that the amount is in.
     */
    currency: string;

    /**
     * The description for the charge.
     */
    description: string;

    /**
     * The extra info that this event contains.
     */
    extra: any;
}

/**
 * An event that is used to run a shell script.
 */
declare interface ShellAction extends Action {
    type: 'shell';

    /**
     * The script that should be run.
     */
    script: string;
}

/**
 * An event that is used to show a toast message to the user.
 */
declare interface ShowToastAction extends Action {
    type: 'show_toast';
    message: string;
    duration: number;
}

/**
 * An event that is used to show some HTML to the user.
 */
declare interface ShowHtmlAction extends Action {
    type: 'show_html';

    /**
     * Whether the HTML should be visible.
     */
    visible: true;

    /**
     * The HTML that should be shown.
     */
    html: string;
}

/**
 * An event that is used to hide the HTML from the user.
 */
declare interface HideHtmlAction extends Action {
    type: 'show_html';
    visible: false;
}
/**
 * Options for the os.tweenTo(), os.moveTo(), and os.focusOn() actions.
 */
 export interface FocusOnOptions {
    /*
     * The zoom value to use.
     */
    zoom?: number;

    /*
     * The rotation value to use in radians. These are the polar coordinates that determine where the camera should orbit around the target point.
     */
    rotation?: {
        x: number;
        y: number;

        /**
         * Whether to normalize the rotation values to between 0 and 2*PI.
         * Defaults to true. Setting this to false can be useful for rotating around a bot multiple times.
         */
         normalize?: boolean;
    };

    /**
     * The duration in seconds that the animation should take.
     * Defaults to 1.
     */
    duration?: number;

    /**
     * The type of easing to use.
     * If not specified then "quadratic" "inout" will be used.
     */
     easing?: EaseType | Easing;

     /**
      * The portal that the bot should be focused in.
      * If not specified, then the bot will be focused in all supported portals. (page, mini and menu)
      */
     portal?: PortalType;
}

/**
 * An event that is used to focus on a given bot.
 */
export interface FocusOnBotAction extends AsyncAction, FocusOnOptions {
    type: 'focus_on';

    /**
     * The ID of the bot to tween to.
     */
    botId: string;
}

/**
 * An event that is used to focus the camera on a specific position.
 */
 export interface FocusOnPositionAction extends AsyncAction, FocusOnOptions {
    type: 'focus_on_position';

    /**
     * The position to animate to.
     */
    position: {
        x: number;
        y: number;
    };
}

/**
 * The possible camera types.
 */
declare type CameraType = 'front' | 'rear';

/**
 * An event that is used to show or hide the QR Code Scanner.
 */
declare interface OpenQRCodeScannerAction extends Action {
    type: 'show_qr_code_scanner';

    /**
     * Whether the QR Code scanner should be visible.
     */
    open: boolean;

    /**
     * The camera that should be used.
     */
    cameraType: CameraType;
}

/**
 * An event that is used to show or hide the barcode scanner.
 */
declare interface OpenBarcodeScannerAction extends Action {
    type: 'show_barcode_scanner';

    /**
     * Whether the barcode scanner should be visible.
     */
    open: boolean;

    /**
     * The camera that should be used.
     */
    cameraType: CameraType;
}

/**
 * An event that is used to toggle whether the console is open.
 */
declare interface OpenConsoleAction extends Action {
    type: 'open_console';

    /**
     * Whether the console should be open.
     */
    open: boolean;
}

/**
 * An event that is used to show or hide a QR Code on screen.
 */
declare interface ShowQRCodeAction extends Action {
    type: 'show_qr_code';

    /**
     * Whether the QR Code should be visible.
     */
    open: boolean;

    /**
     * The code to display.
     */
    code: string;
}

/**
 * The list of possible barcode formats.
 */
declare type BarcodeFormat =
    | 'code128'
    | 'code39'
    | 'ean13'
    | 'ean8'
    | 'upc'
    | 'itf14'
    | 'msi'
    | 'pharmacode'
    | 'codabar';

/**
 * An event that is used to show or hide a barcode on screen.
 */
declare interface ShowBarcodeAction extends Action {
    type: 'show_barcode';

    /**
     * Whether the barcode should be visible.
     */
    open: boolean;

    /**
     * The code to display.
     */
    code: string;

    /**
     * The format that the code should be displayed in.
     */
    format: BarcodeFormat;
}

/**
 * An event that is used to load a simulation.
 */
declare interface LoadServerAction extends Action {
    type: 'load_server';

    /**
     * The ID of the simulation to load.
     */
    id: string;
}

/**
 * An event that is used to unload a simulation.
 */
declare interface UnloadServerAction extends Action {
    type: 'unload_server';

    /**
     * The ID of the simulation to unload.
     */
    id: string;
}

/**
 * An event that is used to load an AUX from a remote location.
 */
declare interface ImportAUXAction extends Action {
    type: 'import_aux';

    /**
     * The URL to load.
     */
    url: string;
}

/**
 * Defines an event for actions that are shouted to every current loaded simulation.
 */
declare interface SuperShoutAction extends Action {
    type: 'super_shout';

    /**
     * The name of the event.
     */
    eventName: string;

    /**
     * The argument to pass as the "that" variable to scripts.
     */
    argument?: any;
}

/**
 * Defines an event that sends a web request to a server.
 */
declare interface SendWebhookAction extends Action {
    type: 'send_webhook';

    /**
     * The options for the webhook.
     */
    options: WebhookOptions;
}

/**
 * Defines a set of options for a webhook.
 */
declare interface WebhookOptions {
    /**
     * The HTTP Method that the request should use.
     */
    method?: string;

    /**
     * The URL that the request should be made to.
     */
    url?: string;

    /**
     * The headers to include in the request.
     */
    headers?: {
        [key: string]: string;
    };

    /**
     * The data to send with the request.
     */
    data?: any;

    /**
     * The shout that should be made when the request finishes.
     */
    responseShout?: string;
}

/**
 * Defines a set of options for animateTag().
 */
declare interface AnimateTagFunctionOptions {
    /**
     * The value that should be animated from.
     * If not specified then the current tag value will be used.
     */
    fromValue?: any;

    /**
     * The value that should be animated to.
     */
    toValue: any;

    /**
     * The duration of the animation in seconds.
     */
    duration: number;

    /**
     * The type of easing to use.
     * If not specified then "linear" "inout" will be used.
     */
    easing?: EaseType | Easing;

    /**
     * The space that the tag should be animated in.
     * If not specified then "tempLocal" will be used.
     * If false, then the bot will be edited instead of using tag masks.
     */
    tagMaskSpace?: BotSpace | false;
}

/**
 * Defines an event that is used to load a file.
 */
declare interface LoadFileAction extends Action {
    type: 'load_file';

    /**
     * The options for the action.
     */
    options: LoadFileOptions;
}

/**
 * Options for loading a file.
 */
declare interface LoadFileOptions {
    /**
     * The file path that should be loaded.
     */
    path?: string;

    /**
     * The shout that should be made when the request finishes.
     */
    callbackShout?: string;
}

/**
 * The data returned from loading a file.
 */
declare interface LoadFileResult {
    path: string;
    url: string;
    data: string | Buffer;
}

/**
 * Defines an event that is used to save a file to a drive.
 */
declare interface SaveFileAction extends Action {
    type: 'save_file';

    /**
     * The options for the action.
     */
    options: SaveFileOptions;
}

/**
 * Options for saving a file.
 */
declare interface SaveFileOptions {
    /**
     * The path that the mod should be saved.
     */
    path?: string;

    /**
     * The data to save to the file.
     */
    data?: string;

    /**
     * The shout that should be made when the request finishes.
     */
    callbackShout?: string;

    /**
     * Whether to overwrite existing files.
     */
    overwriteExistingFile?: boolean;
}

/**
 * The data returned from saving a file.
 */
declare interface SaveFileResult {
    path: string;
    url: string;
}

/**
 * Defines an event that is used to send the player to a dimension.
 */
declare interface GoToDimensionAction extends Action {
    type: 'go_to_dimension';

    /**
     * The dimension that should be loaded.
     */
    dimension: string;
}

/**
 * Defines an event that is used to show an input box to edit a tag on a bot.
 */
declare interface ShowInputForTagAction extends Action {
    type: 'show_input_for_tag';

    /**
     * The ID of the bot to edit.
     */
    botId: string;

    /**
     * The tag that should be edited on the bot.
     */
    tag: string;

    /**
     * The options for the input box.
     */
    options: Partial<ShowInputOptions>;
}

/**
 * Defines an event that is used to show an input box.
 */
declare interface ShowInputAction extends AsyncAction {
    type: 'show_input';

    /**
     * The value that should be in the input box.
     */
    currentValue?: any;

    /**
     * The options for the input box.
     */
    options: Partial<ShowInputOptions>;
}

/**
 * Defines an event that is used to set whether the connection is forced to be offline.
 */
declare interface SetForcedOfflineAction extends Action {
    type: 'set_offline_state';

    /**
     * Whether the connection should be offline.
     */
    offline: boolean;
}

/**
 * Defines an event that is used to redirect the user to the given URL.
 * This should be equivalent to clicking a link with rel="noreferrer".
 */
declare interface GoToURLAction extends Action {
    type: 'go_to_url';

    /**
     * The URL to open.
     */
    url: string;
}

/**
 * Defines an event that is used to open the given URL.
 * This should be equivalent to clicking a link with rel="noreferrer" and target="_blank".
 */
declare interface OpenURLAction extends Action {
    type: 'open_url';

    /**
     * The URL to open.
     */
    url: string;
}

/**
 * Defines an event that is used to play a sound from the given url.
 */
declare interface PlaySoundAction extends AsyncAction {
    type: 'play_sound';

    /**
     * The URL to open.
     */
    url: string;

    /**
     * The ID of the sound.
     */
    soundID: number | string;
}

/**
 * Defines an event that is used to pre-load a sound from the given URL.
 */
export interface BufferSoundAction extends AsyncAction {
    type: 'buffer_sound';

    /**
     * The URL to buffer.
     */
    url: string;
}

/**
 * Defines an event that is used to cancel a sound that is playing.
 */
export interface CancelSoundAction extends AsyncAction {
    type: 'cancel_sound';

    /**
     * The ID of the sound.
     */
    soundID: number;
}

/**
 * Defines an event that is used to download a file onto the device.
 */
declare interface DownloadAction extends Action {
    type: 'download';

    /**
     * The data that should be included in the downloaded file.
     */
    data: any;

    /**
     * The name of the downloaded file. (includes the extension)
     */
    filename: string;

    /**
     * The MIME type of the downloaded file.
     */
    mimeType: string;
}

/**
 * Defines an interface for options that a show input event can use.
 */
declare interface ShowInputOptions {
    /**
     * The type of input box to show.
     */
    type: ShowInputType;

    /**
     * The subtype of input box to show.
     */
    subtype: ShowInputSubtype;

    /**
     * The title that should be used for the input.
     */
    title: string;

    /**
     * The placeholder for the value.
     */
    placeholder: string;

    /**
     * The background color to use.
     */
    backgroundColor: string;

    /**
     * The foreground color to use.
     */
    foregroundColor: string;

    /**
     * Whether the text in the input box should be automatically selected.
     */
    autoSelect: boolean;
}

/**
 * Defines the possible input types.
 */
declare type ShowInputType = 'text' | 'color' | 'secret' | 'date';

/**
 * Defines the possible input types.
 */
declare type ShowInputSubtype = 'basic' | 'swatch' | 'advanced';

/**
 * Defines an event for actions.
 * Actions are basically user-defined events.
 */
declare interface ShoutAction {
    type: 'action';

    /**
     * The IDs of the bots that the event is being sent to.
     * If null, then the action is sent to every bot.
     */
    botIds: string[] | null;

    /**
     * The Bot ID of the user.
     */
    userId: string | null;

    /**
     * The name of the event.
     */
    eventName: string;

    /**
     * The argument to pass as the "that" variable to scripts.
     */
    argument?: any;

    /**
     * Whether the Bot IDs should be sorted before processing.
     */
    sortBotIds?: boolean;
}

/**
 * Defines an event that prevents the execution of an action.
 */
declare interface RejectAction {
    type: 'reject';

    /**
     * The action to prevent.
     */
    action: Action;
}

/**
 * Defines an event that creates a server if it doesn't exist.
 */
declare interface SetupChannelAction {
    type: 'setup_server';

    /**
     * The server that should be created.
     */
    channel: string;

    /**
     * The bot or mod that should be cloned into the new server.
     */
    botOrMod?: Bot | BotTags;
}

/**
 * Defines an event that sets some text on the user's clipboard.
 */
declare interface SetClipboardAction {
    type: 'set_clipboard';

    /**
     * The text that the clipboard should be set to.
     */
    text: string;
}

/**
 * Defines an event that shows the chat bar.
 */
declare interface ShowChatBarAction {
    type: 'show_chat_bar';

    /**
     * Whether the chat bar should be visible.
     */
    visible: boolean;

    /**
     * The text that the bar should be filled with by default.
     */
    prefill?: string;

    /**
     * The text that the bar should have as the placeholder.
     */
    placeholder?: string;

    /**
     * The color to use for the placeholder.
     */
    placeholderColor?: string;

    /**
     * The color to use for the background.
     */
    backgroundColor?: string;

    /**
     * The color to use for the foreground (text).
     */
     foregroundColor?: string;
}

/**
 * Defines the possible options for showing the chat bar.
 */
declare interface ShowChatOptions {
    /**
     * The text that the bar should be filled with by default.
     */
    prefill?: string;

    /**
     * The text that the bar should have as the placeholder.
     */
    placeholder?: string;

    /**
     * The color to use for the placeholder.
     */
    placeholderColor?: string;

    /**
     * The color to use for the background.
     */
     backgroundColor?: string;

     /**
     * The color to use for the foreground (text).
     */
      foregroundColor?: string;
}

/**
 * Defines an event that executes a script.
 */
declare interface RunScriptAction extends AsyncAction {
    type: 'run_script';

    /**
     * The script that should be executed.
     */
    script: string;
}

/**
 * Defines an event that shows the "upload AUX file" dialog.
 */
declare interface ShowUploadAuxFileAction {
    type: 'show_upload_aux_file';
}

/**
 * Defines an interface that represents a file that was uploaded.
 */
declare interface UploadedFile {
    /**
     * The name of the file that was uploaded.
     */
    name: string;

    /**
     * The size of the file in bytes.
     */
    size: number;

    /**
     * The data that the file contains.
     */
    data: string | ArrayBuffer;
}

/**
 * Defines an event that marks a specific point in history.
 */
declare interface MarkHistoryAction {
    type: 'mark_history';

    /**
     * The message that the mark should contain.
     */
    message: string;
}

/**
 * Defines an event that loads the history into the server.
 */
declare interface BrowseHistoryAction {
    type: 'browse_history';
}

/**
 * Defines an event that restores the current state to a specific bookmark.
 */
declare interface RestoreHistoryMarkAction {
    type: 'restore_history_mark';

    /**
     * The ID of the mark that should be restored.
     */
    mark: string;

    /**
     * The server that the mark should be restored to.
     * If not specified, then the current server will be used.
     */
    server?: string;
}

/**
 * Defines an event that loads a space into the server.
 */
declare interface LoadSpaceAction {
    type: 'load_space';

    /**
     * The space that should be loaded.
     */
    space: BotSpace;

    /**
     * The config that should be used to load the space.
     */
    config: any;
}

/**
 * Defines an event that loads bots from the given space that match the given tags and values.
 */
declare interface LoadBotsAction {
    type: 'load_bots';

    /**
     * The space that should be searched.
     */
    space: BotSpace;

    /**
     * The tags that the loaded bots should have.
     */
    tags: LoadBotsTagFilter[];
}

/**
 * Defines an interface for objects that specify a tag and value
 * that a bot should have to be loaded.
 */
declare interface LoadBotsTagFilter {
    /**
     * The tag that the bot should have.
     */
    tag: string;

    /**
     * The value that the bot should have.
     */
    value?: any;
}

/**
 * Defines an event that clears all bots from a space.
 *
 * Only supported for the following spaces:
 * - error
 */
declare interface ClearSpaceAction {
    type: 'clear_space';

    /**
     * The space to clear.
     */
    space: BotSpace;
}

/**
 * Defines an event that unlocks the given space for editing.
 * Once a space is unlocked, it cannot be locked for the remainder of the session.
 * 
 * Only supported for the following spaces:
 * - admin
 */
export interface UnlockSpaceAction {
    type: 'unlock_space';

    /**
     * The space to unlock.
     */
    space: BotSpace;

    /**
     * The password to use to unlock the space.
     */
    password: string;
}

/**
 * Defines an event that sets the password used to unlock the given space for editing.
 */
export interface SetSpacePasswordAction extends AsyncAction {
    type: 'set_space_password';

    /**
     * The space to set the password for.
     */
    space: BotSpace;

    /**
     * The old password for the space.
     */
    oldPassword: string;

    /**
     * The new password for the space.
     */
    newPassword: string;
}

/**
 * Defines an event that runs an animation locally over
 * whatever existing animations are playing.
 */
declare interface LocalFormAnimationAction {
    type: 'local_form_animation';

    /**
     * The bot to run the animation on.
     */
    botId: string;

    /**
     * The animation to run.
     */
    animation: number | string;
}

declare type TweenType = 'position' | 'rotation';

declare type EaseType = 'linear' | 'quadratic' | 'cubic' | 'quartic' | 'quintic' | 'sinusoidal' | 'exponential' | 'circular' | 'elastic';

declare type EaseMode = 'in' | 'out' | 'inout';

declare interface Easing {
    type: EaseType;
    mode: EaseMode;
}

/**
 * Defines the set of possible options for tweens.
 */
declare interface TweenOptions {
    /**
     * The easing type and mode that the tween should use.
     */
    easing?: Easing;

    /**
     * The amount of time that the tween should take in seconds.
     */
    duration?: number;
}

/**
 * Defines an event that runs a tween locally.
 */
declare interface LocalTweenAction extends Action {
    type: 'local_tween';

    /**
     * The bot to run the tween on.
     */
    botId: string;

    /**
     * The dimension that the bot should be tweened in.
     */
    dimension: string;

    /**
     * The type of the tween.
     */
    tweenType: TweenType;

    /**
     * The easing that should be used.
     */
    easing: Easing;
}

/**
 * Defines an event that runs a position tween locally.
 */
declare interface LocalPositionTweenAction extends LocalTweenAction {
    tweenType: 'position';

    /**
     * The target position of the tween.
     */
    position: { x?: number, y?: number, z?: number };
}

/**
 * Defines an event that runs a rotation tween locally.
 */
declare interface LocalRotationTweenAction extends LocalTweenAction {
    tweenType: 'rotation';

    /**
     * The target rotation of the tween.
     */
    rotation: { x?: number, y?: number, z?: number };
}

/**
 * Defines an event that enables AR on the device.
 */
declare interface EnableARAction {
    type: 'enable_ar';

    /**
     * Whether AR features should be enabled.
     */
    enabled: boolean;
}

/**
 * Defines an event that enables VR on the device.
 */
declare interface EnableVRAction {
    type: 'enable_vr';

    /**
     * Whether VR features should be enabled.
     */
    enabled: boolean;
}

/**
 * Defines an event that enables POV on the device.
 */
 export interface EnablePOVAction {
    type: 'enable_pov';

    /**
     * Whether POV features should be enabled.
     */
    enabled: boolean;

    /**
     * The point that the camera should be placed at for POV.
     */
    center?: { x: number, y: number, z: number };
}

/**
 * Defines an event that shows a QR code that is a link to a server & dimension.
 */
declare interface ShowJoinCodeAction {
    type: 'show_join_code';

    /**
     * The server that should be joined.
     */
    server?: string;

    /**
     * The dimension that should be joined.
     */
    dimension?: string;
}

/**
 * Defines an event that requests that AUX enter fullscreen mode.
 * This can be denied by the user.
 */
declare interface RequestFullscreenAction {
    type: 'request_fullscreen_mode';
}

/**
 * Defines an event that exits fullscreen mode.
 */
declare interface ExitFullscreenAction {
    type: 'exit_fullscreen_mode';
}

/**
 * Defines the options that a share action can have.
 */
declare interface ShareOptions {
    /**
     * The title of the document being shared.
     */
    title?: string;

    /**
     * The text that should be shared.
     */
    text?: string;

    /**
     * The URL of the document being shared.
     */
    url?: string;
}

/**
 * Defines an event that shares the given information using the
 * device's native social sharing capabilities.
 */
declare interface ShareAction extends AsyncAction, ShareOptions {
    type: 'share';
}

/**
 * An event that is used to show or hide the circle wipe.
 */
 declare interface OpenCircleWipeAction extends AsyncAction {
    type: 'show_circle_wipe';

    /**
     * Whether the circle wipe should be visible.
     */
    open: boolean;

    /**
     * The options for the circle wipe.
     */
    options: OpenCircleWipeOptions;
}

/**
 * The options for the circle wipe.
 */
 declare interface OpenCircleWipeOptions {
    /**
     * The duration of this half of the circle wipe animation in seconds.
     */
    duration: number;

    /**
     * The color that the circle wipe should be.
     */
    color: string;
}

/**
 * An event that is used to add some snap points for a drag operation.
 */
 declare interface AddDropSnapTargetsAction extends Action {
    type: 'add_drop_snap_targets';

    /**
     * The ID of the bot that, when it is a drop target, the snap points should be enabled.
     * If null, then the targets apply globally during the drag operation.
     */
    botId?: string;

    /**
     * The list of snap targets that should be used.
     */
    targets: SnapTarget[];
}

/**
 * Defines an interface that represents a snap point.
 * That is, a point in 3D space with an associated snap distance.
 */
 declare interface SnapPoint {
    /**
     * The 3D position for the point.
     */
    position: { x: number; y: number; z: number };

    /**
     * The distance that the snap point should take effect at.
     */
    distance: number;
}

/**
 * Defines an interface that represents a snap axis.
 * That is, a ray in 3D space with an associated snap distance.
 */
 export interface SnapAxis {
    /**
     * The 3D direction that the axis ray travels along.
     */
    direction: { x: number; y: number; z: number };

    /**
     * The 3D position that the ray starts at.
     */
    origin: { x: number; y: number; z: number };

    /**
     * The distance from the ray line that the snap point should take effect at.
     */
    distance: number;
}

/**
 * The list of possible snap targets.
 * - "ground" means that the dragged bot should snap to the ground plane. This option is overriden by "grid".
 * - "grid" means that the dragged bot should snap to grid tiles.
 * - "face" means that the dragged bot should snap to other bot faces.
 * - "bots" means that the dragged bot will snap to other bots.
 */
declare type SnapTarget = 'ground' | 'grid' | 'face' | 'bots' | SnapPoint | SnapAxis;

/**
 * An event that is used to disable the default dragging logic (moving the bot) and enable
 * "onDragging" shouts and whispers.
 */
 export interface EnableCustomDraggingAction extends Action {
    type: 'enable_custom_dragging';
}

/**
 * The possible options for a custom portal.
 */
 declare interface OpenCustomPortalOptions {
    /**
     * The mode that the portal should be opened in.
     * "Tag" indicates that the portal should watch the given tag and automatically produce bundles for the portal.
     * "source" indicates that the portal should load the given source directly.
     * 
     * Defaults to "tag".
     */
    mode?: 'tag' | 'source';

    /**
     * The CSS styles that should be used for the portal.
     */
    style?: any;
}

/**
 * Defines an event that creates a custom portal using the given source code.
 */
 declare interface OpenCustomPortalAction extends AsyncAction {
    type: 'open_custom_portal';
    /**
     * The ID of the portal.
     */
    portalId: string;

    /**
     * The tag that the portal should use.
     */
    tag: string;

    /**
     * The options for the portal.
     */
    options: OpenCustomPortalOptions;
}


/**
 * The list of types of output that custom portals support.
 */
 export type CustomAppOutputType = 'html';

 /**
  * the list of modes that custom portals support.
  */
 export type CustomPortalOutputMode = 'push' | 'pull';
 
 /**
  * Defines an event that registers a custom portal.
  * This functions similarly to OpenCustomPortalAction except that it is more
  * tightly integrated into CasualOS.
  */
 export interface RegisterCustomAppAction extends AsyncAction {
     type: 'register_custom_app';
 
     /**
      * The ID of the portal.
      */
     portalId: string;
 
     /**
      * The ID of the bot that should be used to configure the portal.
      */
     botId: string;
 
     /**
      * Options that should be used to configure the custom portal.
      */
     options: RegisterCustomAppOptions;
 }
 
 /**
  * The options for a register custom portal action.
  */
 export interface RegisterCustomAppOptions {
     /**
      * The type of the custom portal.
      * Used by CasualOS to determine how CasualOS should consume the rendered output and display it.
      */
     type: CustomAppOutputType;
 
     /**
      * The kind of the custom portal.
      * Used to make it easy to register multiple custom portals that rely on the same kind of renderers.
      */
     kind?: string;
 
     /**
      * The output mode of the custom portal.
      * Used to make it easy to control how a custom portal recieves updates.
      */
     outputMode?: CustomPortalOutputMode;
 }


/**
 * Defines an event that notifies that the output of a portal should be updated with the given data.
 */
 export interface SetAppOutputAction extends Action {
    type: 'set_app_output';

    /**
     * The ID of the portal.
     */
    portalId: string;

    /**
     * The output that the portal should show.
     */
    output: any;

    uncopiable: true;
}

/**
 * Defines an event that adds an entry point to a custom portal.
 */
declare interface RegisterPrefixAction extends AsyncAction {
    type: 'register_prefix';

    /**
     * The prefix that should be registered.
     */
    prefix: string;
    
    /**
     * The options that should be used for the prefix.
     */
    options: RegisterPrefixOptions;
}

/**
 * Defines an interface that contains options for register prefix actions.
 */
declare interface RegisterPrefixOptions {
    /**
     * The possible languages that prefixes can use.
     */
    language?: 'javascript' | 'typescript' | 'json' | 'jsx' | 'tsx' | 'text';
}


/**
 * An interface that represents the options that can be used for making recordings.
 */
declare interface RecordingOptions {
    /**
     * Whether to record audio.
     */
    audio: boolean;

    /**
     * Whether to record video.
     */
    video: boolean;

    /**
     * Whether to record the screen.
     */
    screen: boolean;
}

/**
 * An event that is used to start audio recording.
 */
declare interface BeginRecordingAction extends AsyncAction, RecordingOptions {
    type: 'begin_recording';
}

/**
 * An event that is used to finish audio recording.
 */
declare interface EndRecordingAction extends AsyncAction {
    type: 'end_recording';
}

/**
 * Defines an interface that contains recorded data.
 */
declare interface Recording {

    /**
     * The list of files that were produced when recording.
     */
    files: RecordedFile[];
}

declare interface RecordedFile {
    /**
     * Whether the file contains the recorded audio.
     */
    containsAudio: boolean;
    
    /**
     * Whether the file contains the recorded video.
     */
    containsVideo: boolean;

    /**
     * Whether the file contains the recorded screen data.
     */
    containsScreen: boolean;

    /**
     * The data that the file contains.
     */
    data: Blob;
}


declare interface SpeakTextOptions {
    /**
     * The pitch that the text should be spoken at.
     */
     pitch?: number;

     /**
      * The rate that the text should be spoken at.
      */
     rate?: number;
 
     /**
      * The name of the voice that the text should be spoken with.
      */
     voice?: string;
}

/**
 * An event that is used to speak some text using the builtin text to speech engine.
 */
 declare interface SpeakTextAction extends AsyncAction, SpeakTextOptions {
    type: 'speak_text';

    /**
     * The text that should be spoken.
     */
    text: string;
}

/**
 * An event that is used to retrieve the synthetic voices that are supported by the current system.
 */
 declare interface GetVoicesAction extends AsyncAction {
    type: 'get_voices';
}

/**
 * Defines an interface that represents a synthetic voice.
 */
 declare interface SyntheticVoice {
    /**
     * Whether this voice is the default synthetic voice.
     */
    default: boolean;

    /**
     * The language that this voice can speak.
     */
    language: string;

    /**
     * The name of the voice.
     */
    name: string;
}


/**
 * An event that is used to retrieve the current geolocation of the device.
 */
 declare interface GetGeolocationAction extends AsyncAction {
    type: 'get_geolocation';
}

declare interface SuccessfulGeolocation {
    success: true;

    /**
     * The altitude that the device is near.
     * Null if the device does not support determining the altitude.
     */
     altitude?: number;

     /**
      * The accuracy of the altitude in meters.
      * Null if the device does not support altitude.
      */
     altitudeAccuracy?: number;
 
     /**
      * The latitude that the device is near.
      */
     latitude: number;
 
     /**
      * The longitude that the device is near.
      */
     longitude: number;
 
     /**
      * The accuracy of the positional location (latitude and longitude) in meters.
      */
     positionalAccuracy: number;
 
     /**
      * The heading of the device from north in radians.
      * 0 is true north, Math.PI/2 is east, Math.PI is south and 3/2*Math.PI is west.
      * This value is null if the device is unable to determine the heading.
      */
     heading: number;
 
     /**
      * The speed that the device is moving in meters per second.
      * Null if the device does not support calculating the speed.
      */
     speed: number;
 
     /**
      * The timestamp of the geolocation result.
      */
     timestamp: number;
}

declare interface UnsuccessfulGeolocation {
    success: false;

    /**
     * The code of the error that occurred.
     */
     errorCode?: 'permission_denied' | 'position_unavailable' | 'timeout' | 'unknown';

     /**
      * The message of the error that occurred.
      */
     errorMessage?: string;
}

/**
 * Defines an interface that represents a geolocation result.
 */
declare type GeoLocation = SuccessfulGeolocation | UnsuccessfulGeolocation;


/**
 * Defines an event that publishes a record.
 */
 export interface PublishRecordAction extends AsyncAction {
    type: 'publish_record';

    /**
     * The auth token that should be used to authenticate the publish record request.
     */
    token: string;

    /**
     * The address that the record should be published to.
     */
    address: string;

    /**
     * The record data that should be published.
     */
    record: any;

    /**
     * The space that the record should be published in.
     */
    space: RecordSpace;

    uncopiable: true;
}

export interface RecordDefinition {
    /**
     * The auth token that should be used to authenticate the publish record request.
     * Different auth tokens can be used to publish records to different CasualOS.me accounts.
     * Defaults to using the auth token in the auth bot.
     */
    authToken?: string;

    /**
     * The space that the record should be published in.
     * Defaults to tempRestricted.
     */
    space?: RecordSpace;

    /**
     * The record that should be published.
     */
    record: any;
}

export interface AddressedRecord extends RecordDefinition {
    /**
     * The address that the record should be published to.
     */
    address: string;
}

export interface PrefixedRecord extends RecordDefinition {
    /**
     * The prefix that the record should be published with.
     */
    prefix?: string;

    /**
     * The ID that the record should be published with.
     * Defaults to a UUID.
     */
    id?: string;
}

export type PublishableRecord = AddressedRecord | PrefixedRecord;


export interface DeletableRecord {
    /**
     * The auth token that should be used to authenticate the delete record request.
     */
     authToken?: string;
     
    /**
     * The space that the record lives in.
     */
     space: RecordSpace;

     /**
      * The address that the record was published to.
      */
     address: string;
};

/**
 * Defines an interface for options that show a payment box.
 */
declare interface CheckoutOptions {
    /**
     * The publishable API Key that should be used to checkout with stripe.
     */
    publishableKey: string;

    /**
     * The ID of the product that is being purchased.
     */
    productId: string;

    /**
     * The title that should be shown for the product.
     */
    title: string;

    /**
     * The description that should be shown for the product.
     */
    description: string;

    /**
     * The server that the payment should be processed on.
     */
    processingServer: string;

    /**
     * Whether to request the payer's billing address.
     */
    requestBillingAddress?: boolean;

    /**
     * Specifies the options that should be used for requesting payment from Apple Pay or the Payment Request API.
     */
    paymentRequest?: PaymentRequestOptions;
}

/**
 * Defines an interface of payment request options.
 */
declare interface PaymentRequestOptions {
    /**
     * The two letter country code of your payment processor account.
     */
    country: string;

    /**
     * The three character currency code.
     */
    currency: string;

    /**
     * The total that should be charged to the user.
     */
    total: {
        /**
         * The label that should be displayed for the total.
         */
        label: string;

        /**
         * The amount in the currency's smallest unit. (cents, etc.)
         */
        amount: number;
    };
}

/**
 * Defines an interface for options that complete payment for a product.
 */
declare interface FinishCheckoutOptions {
    /**
     * The secret API key that should be used to checkout with stripe.
     */
    secretKey: string;

    /**
     * The token that authorized payment from the user.
     */
    token: string;

    /**
     * The amount that should be charged in the currency's smallest unit. (cents, etc.)
     */
    amount: number;

    /**
     * The three character currency code.
     */
    currency: string;

    /**
     * The description for the charge.
     */
    description: string;

    /**
     * Any extra info that should be included in the onPaymentSuccessful() or onPaymentFailed() events for this checkout.
     */
    extra: any;
}

/**
 * Defines an interface for options that mark a specific time in history.
 */
declare interface MarkHistoryOptions {
    /**
     * The message that the mark should contain.
     */
    message: string;
}

/**
 * An interface that is used to say which user/device/session an event should be sent to.
 */
declare interface SessionSelector {
    username?: string;
    device?: string;
    session?: string;
    broadcast?: boolean;
}

declare interface BotTags {
    [key: string]: any;
}

/**
 * Defines the basic structure of a bot.
 */
export interface Bot {
    /**
     * The ID of the bot.
     */
    id: string;

    /**
     * The space the bot lives in.
     */
    space?: BotSpace;

    /**
     * The calculated tag values that the bot contains.
     */
    tags: BotTags;

    /**
     * The tag masks that are applied to the bot.
     */
    masks: BotTags;

    /**
     * The raw tag values that the bot contains.
     * If you want to access the script code for a formula, use this.
     * Otherwise, use the tags property.
     */
    raw: BotTags;

    /**
     * The tags that have been changed on this bot.
     */
    changes: BotTags;

    /**
     * The tag masks that have been changed on this bot.
     */
    maskChanges: {
        [space: string]: BotTags;
    };
}

/**
 * Defines an interface for a record.
 */
export interface Record {
    /**
     * The address that the record was published at.
     */
    address: string;

    /**
     * The space that the record was published to.
     */
    space: RecordSpace;

    /**
     * The auth ID that published the record.
     */
    authID: string;

    /**
     * The data that was stored in the record.
     */
    data: any;
}

/**
 * Defines an interface for an object that represents a reference to a specific record.
 */
export interface RecordReference {
    /**
     * The ID of the user that published the record.
     */
    authID: string;

    /**
     * The space that the record lives in.
     */
    space: RecordSpace;

    /**
     * The address that the record was published to.
     */
    address: string;
}


/**
 * Defines an interface that represents a set of records that were retrieved.
 */
export interface GetRecordsResult {

    /**
     * The set of records that were retrieved.
     */
    records: Record[];

    /**
     * The total number of records that the query would have returned.
     */
    totalCount: number;

    /**
     * Whether there are more records available to retrieve for the query.
     */
     hasMoreRecords: boolean;

    /**
     * Gets the set page of records.
     */
    getMoreRecords(): Promise<GetRecordsResult>;
}

/**
 * Defines the possible bot anchor points.
 */
declare type BotAnchorPoint =
    | 'top'
    | 'front'
    | 'back'
    | 'left'
    | 'right'
    | 'bottom'
    | 'center'
    | [number, number, number];

/**
 * Defines an interface for the state that an AUX bot can contain.
 */
declare interface BotsState {
    [id: string]: Bot;
}


/**
 * The possible bot spaces.
 *
 * - "shared" means that the bot is a normal bot.
 * - "local" means that the bot is stored in the local storage partition.
 * - "tempLocal" means that the bot is stored in the temporary partition.
 * - "history" means that the bot represents a version of another space.
 * - "admin" means that the bot is shared across all servers.
 * - "tempShared" means that the bot is temporary and shared with other devices.
 * - "remoteTempShared" means that the bot is temporary and shared with this device from a remote device.
 * - "certified" means that the bot is a certificate.
 */
 export type BotSpace =
    | 'shared'
    | 'local'
    | 'tempLocal'
    | 'history'
    | 'admin'
    | 'tempShared'
    | 'remoteTempShared'
    | 'certified';

/**
 * The possible spaces that records can be stored in.
 * 
 * - "tempGlobal" means that the record is temporary and available to anyone.
 * - "tempRestricted" means that the record is temporary and available to a specific user.
 * - "permanentGlobal" means that the record is permanent and available to anyone.
 * - "permanentRestricted" means that the record is permanent and available to a specific user.
 */
export type RecordSpace = 
    | 'tempGlobal'
    | 'tempRestricted'
    | 'permanentGlobal'
    | 'permanentRestricted';

/**
 * The possible portal types.
 */
declare type PortalType =
    | 'page'
    | 'mini'
    | 'menu'
    | 'sheet'
    | string;

/**
 * Defines a tag filter. It can be either a function that accepts a tag value and returns true/false or it can be the value that the tag value has to match.
 */
declare type TagFilter =
    | ((value: any) => boolean)
    | string
    | number
    | boolean
    | null
    | undefined;

/**
 * Defines a bot filter. It is a function that accepts a bot and returns true/false.
 *
 * Common bot filters are:
 * - `byTag(tag, value)`
 * - `inDimension(dimension)`
 * - `atPosition(dimension, x, y)`
 * - `inStack(bot, dimension)`
 * - `neighboring(bot, dimension, direction)`
 * - `either(filter1, filter2)`
 * - `not(filter)`
 */
declare interface BotFilterFunction {
    (bot: Bot): boolean;
    sort?: (bot: Bot) => any;
}

export interface RecordFilter {
    recordFilter: true;
}

export interface AuthIdRecordFilter extends RecordFilter {
    authID: string;
}

export interface SpaceFilter extends BotFilterFunction, RecordFilter {
    space: string;
}

export interface AddressRecordFilter extends RecordFilter {
    address: string;
}

export interface AuthTokenRecordFilter extends RecordFilter {
    authToken: string;
}

export interface PrefixRecordFilter extends RecordFilter {
    prefix: string;
}

export interface IDRecordFilter extends BotFilterFunction, RecordFilter {
    id: string;
}

export type RecordFilters = AuthIdRecordFilter | SpaceFilter | AddressRecordFilter | AuthTokenRecordFilter | PrefixRecordFilter | IDRecordFilter;

/**
 * Defines a result from a webhook.
 */
declare interface WebhookResult {
    /**
     * The data returned from the webhook.
     * If the returned data was JSON, then this will be an object.
     * Otherwise, it will be a string.
     */
    data: any;

    /**
     * The HTTP status code number that was returned.
     */
    status: number;

    /**
     * The name of the status code that was returned.
     */
    statusText: string;

    /**
     * The HTTP headers that were returned with the response.
     */
    headers: {
        [key: string]: string
    }
}

/**
 * Defines a type that represents a mod.
 * That is, a set of tags that can be applied to another bot.
 */
declare type Mod = BotTags | Bot;

/**
 * Defines a point in 3D space.
 */
declare interface Point3D {
    /**
     * The X position of the point.
     */
    x: number;

    /**
     * The Y position of the point.
     */
    y: number;

    /**
     * The Z position of the point.
     */
    z: number;
}

/**
 * Defines an interface that contains performance statistics about a server.
 */
declare interface PerformanceStats {
    /**
     * The number of bots in the server.
     */
    numberOfBots: number;

    /**
     * A list of listen tags and the amount of time spent executing them (in miliseconds).
     * Useful to guage if a listen tag is causing the server to slow down.
     */
    shoutTimes: {
        tag: string;
        timeMs: number;
    }[];

    /**
     * The total number of active setTimeout() and setInterval() timers that are active.
     */
    numberOfActiveTimers: number;
}

/**
 * Defines an interface that represents the list of bots and tags that are included in a bundle.
 */
export interface BundleModules {
    [id: string]: Set<string>;
}

/**
 * Defines an interface that represents a bundle of code.
 */
export interface CodeBundle {
    /**
     * The tag the bundle was built from.
     */
    tag: string;

    /**
     * The source code that the bundle contains.
     * If an error occurred, then this will be null/undefined.
     */
    source?: string;

    /**
     * The error that occurred while building the bundle.
     * Null/Undefined if an error did not happen.
     */
    error?: string;

    /**
     * The list of warnings that occurred while building the bundle.
     */
    warnings: string[];

    /**
     * The list of modules that the bundle contains.
     */
    modules: BundleModules;
}

/**
 * Defines an interface for a function that provides HTML VDOM capabilities to bots.
 */
 export interface HtmlFunction {
    (...args: any[]): any;
    h: (name: string | Function, props: any, ...children: any[]) => any;
    f: any;
}

declare global {

    /**
     * The Bot that this script is running in.
     */
    const thisBot: Bot;

    /**
     * The Bot that this script is running in.
     */
    const bot: Bot;

    /**
     * The tags of the Bot that this script is running in.
     */
    const tags: BotTags;

    /**
     * The raw tags of the Bot that this script is running in.
     */
    const raw: BotTags;

    /**
     * The Bot that created this Bot.
     */
    const creatorBot: Bot;

    /**
     * The config Bot for this Bot.
     */
    const configBot: Bot;

    /**
     * The name of the tag that this script is running in.
     */
    const tagName: string;

    /**
     * Creates a new bot and returns it.
     * @param parent The bot that should be the parent of the new bot.
     * @param mods The mods which specify the new bot's tag values. If given a mod with no tags, then an error will be thrown.
     * @returns The bot(s) that were created.
     *
     * @example
     * // Create a red bot without a parent.
     * let redBot = create(null, { "color": "red" });
     *
     * @example
     * // Create a red bot and a blue bot with `this` as the parent.
     * let [redBot, blueBot] = create(this, [
     *    { "color": "red" },
     *    { "color": "blue" }
     * ]);
     *
     */
    function create(...mods: Mod[]): Bot | Bot[];

    /**
     * Destroys the given bot, bot ID, or list of bots.
     * @param bot The bot, bot ID, or list of bots to destroy.
     */
    function destroy(bot: Bot | string | Bot[]): void;

    /**
     * Removes tags from the given list of bots.
     * @param bot The bot, bot ID, or list of bots that should have their matching tags removed.
     * @param tagSection The tag section which should be removed from the bot(s). If given a string, then all the tags
     *                   starting with the given name will be removed. If given a RegExp, then all the tags matching the regex will be removed.
     *
     * @example
     * // Remove tags named starting with "abc" from the `this` bot.
     * removeTags(this, "abc");
     *
     * @example
     * // Remove tags named "hello" using a case-insensitive regex from the `this` bot.
     * removeTags(this, /^hello$/gi);
     *
     */
    function removeTags(bot: Bot | Bot[], tagSection: string | RegExp): void;

    /**
     * Renames the given original tag to the given new tag using the given bot or list of bots.
     * @param bot The bot or list of bots that the tag should be renamed on.
     * @param originalTag The original tag to rename.
     * @param newTag The new tag name.
     * 
     * @example
     * // Rename the "abc" tag to "def"
     * renameTag(this, "abc", "def")
     */
    function renameTag(bot: Bot | Bot[], originalTag: string, newTag: string): void;

    /**
     * Gets the ID from the given bot.
     * @param bot The bot or string.
     */
    function getID(bot: Bot | string): string;

    /**
     * Gets JSON for the given data.
     * @param data The data.
     */
    function getJSON(data: any): string;

    /**
     * Shouts the given events in order until a bot returns a result.
     * Returns the result that was produced or undefined if no result was produced.
     * @param eventNames The names of the events to shout.
     * @param arg The argument to shout.
     */
     function priorityShout(eventNames: string[], arg?: any): any;

    /**
     * Asks every bot in the server to run the given action.
     * In effect, this is like shouting to a bunch of people in a room.
     *
     * @param name The event name.
     * @param arg The optional argument to include in the shout.
     * @returns Returns a list which contains the values returned from each script that was run for the shout.
     *
     * @example
     * // Tell every bot to reset themselves.
     * shout("reset()");
     *
     * @example
     * // Ask every bot for its name.
     * const names = shout("getName()");
     *
     * @example
     * // Tell every bot say "Hi" to you.
     * shout("sayHi()", "My Name");
     */
    function shout(name: string, arg?: any): any[];

    /**
     * Asks the given bots to run the given action.
     * In effect, this is like whispering to a specific set of people in a room.
     *
     * @param bot The bot(s) to send the event to.
     * @param eventName The name of the event to send.
     * @param arg The optional argument to include.
     * @returns Returns a list which contains the values returned from each script that was run for the shout.
     *
     * @example
     * // Tell all the red bots to reset themselves.
     * whisper(getBots("#color", "red"), "reset()");
     *
     * @example
     * // Ask all the tall bots for their names.
     * const names = whisper(getBots("scaleZ", height => height >= 2), "getName()");
     *
     * @example
     * // Tell every friendly bot to say "Hi" to you.
     * whisper(getBots("friendly", true), "sayHi()", "My Name");
     */
    function whisper(
        bot: (Bot | string)[] | Bot | string,
        eventName: string,
        arg?: any
    ): any;

    /**
     * Shouts the given event to every bot in every loaded simulation.
     * @param eventName The name of the event to shout.
     * @param arg The argument to shout. This gets passed as the `that` variable to the other scripts.
     */
    function superShout(eventName: string, arg?: any): SuperShoutAction;

    /**
     * Watches the given bot or list of bots for changes and calls the given callback when the bot is changed or destroyed.
     * Returns a number that can be passed to clearWatchBot() to stop watching the bot.
     * @param bot The bot or list of bots that should be watched for changes.
     * @param callback The function that should be called when the bot is changed or destroyed.
     */
    function watchBot(bot: (Bot | string)[] | Bot | string, callback: () => void): number;

    /**
     * Cancels watching a bot using the given ID number that was returned from watchBot().
     * @param watchId The ID number that should be used to cancel the watch callbacks.
     */
    function clearWatchBot(watchId: number): void;

    /**
     * Watches the given portal for when bots are added and removed from it and calls the given function.
     * Returns a number that can be passed to clearWatchPortal() to stop watching the portal.
     * @param portalId The ID of the portal to watch.
     * @param callback The function that should be called when the portal changes.
     */
    function watchPortal(portalId: string, callback: () => void): number;

    /**
     * Cancels watching a portal using the given ID number that was returned from watchPortal().
     * @param watchId The ID number that should be used to cancel the watch callbacks.
     */
    function clearWatchPortal(watchId: number): void;

    /**
     * Sends a web request based on the given options.
     * @param options The options that specify where and what to send in the web request.
     *
     * @example
     * // Send a HTTP POST request to https://www.example.com/api/createThing
     * webhook({
     *   method: 'POST',
     *   url: 'https://www.example.com/api/createThing',
     *   data: {
     *     hello: 'world'
     *   },
     *   responseShout: 'requestFinished'
     * });
     */
    const web: {

        /**
         * Sends an HTTP GET request for the given URL using the given options.
         * @param url The URL to request.
         * @param options The options to use.
         * 
         * @example
         * 
         * // Send a HTTP GET request for https://www.example.com
         * const result = await web.get('https://www.example.com');
         */
        get(url: string, options?: WebhookOptions): Promise<WebhookResult>;

        /**
         * Sends a HTTP POST request to the given URL with the given data.
         *
         * @param url The URL that the request should be sent to.
         * @param data That that should be sent.
         * @param options The options that should be included in the request.
         *
         * @example
         * 
         * // Send a HTTP POST request to https://www.example.com/api/createThing
         * const result = await web.post('https://www.example.com/api/createThing', {
         *   hello: 'world'
         * });
         * 
         */
        post(url: string, data?: any, options?: WebhookOptions): Promise<WebhookResult>;

        /**
         * Sends a web request based on the given options.
         * @param options The options that specify where and what to send in the web request.
         *
         * @example
         * 
         * // Send a HTTP GET request to https://example.com
         * const result = await web.hook({
         *   method: 'GET',
         *   url: 'https://example.com'
         * });
         * 
         * os.toast(result);
         */
        hook(options: WebhookOptions): Promise<WebhookResult>;
    };
    
    /**
    * Creates a Universally Unique IDentifier (UUID).
    */
    function uuid(): string;

    /**
     * Animates the given tag. Returns a promise when the animation is finished.
     * @param bot The bot or list of bots that should be animated.
     * @param tag The tag that should be animated.
     * @param options The options for the animation. If given null, then any running animations for the given tag will be canceled.
     */
     function animateTag(bot: Bot | (Bot | string)[] | string, tag: string, options: AnimateTagFunctionOptions): Promise<void>;

     /**
      * Animates the given tags. Returns a promise when the animation is finished.
      * @param bot The bot or list of bots that should be animated.
      * @param options The options for the animation. fromValue should be an object which contains the starting tag values and toValue should be an object that contains the ending tag values.
      */
      function animateTag(bot: Bot | (Bot | string)[] | string, options: AnimateTagFunctionOptions): Promise<void>;
     /**
      * Animates the given tag. Returns a promise when the animation is finished.
      * @param bot The bot or list of bots that should be animated.
      * @param tag The tag that should be animated.
      * @param options The options for the animation.
      */
     function animateTag(
         bot: Bot | (Bot | string)[] | string,
         tagOrOptions: string | AnimateTagFunctionOptions,
         options?: AnimateTagFunctionOptions
     ): Promise<void>;

    /**
     * Cancels the animations that are running on the given bot(s).
     * @param bot The bot or list of bots that should cancel their animations.
     * @param tag The tag that the animations should be canceld for. If omitted then all tags will be canceled.
     */
    function clearAnimations(bot: Bot | (Bot | string)[] | string, tag?: string): void;

    /**
     * Sends the given operation to all the devices that matches the given selector.
     * In effect, this allows users to send each other events directly without having to edit tags.
     *
     * Note that currently, devices will only accept events sent from the server.
     *
     * @param event The event that should be executed in the remote session(s).
     * @param selector The selector that indicates where the event should be sent. The event will be sent to all sessions that match the selector.
     *                 For example, specifying a username means that the event will be sent to every active session that the user has open.
     *                 If a selector is not specified, then the event is sent to the server.
     * @param allowBatching Whether to allow batching this remote event with other remote events. This will preserve ordering between remote events but may not preserve ordering
     *                      with respect to other events. Defaults to true.
     *
     * @example
     * // Send a toast to all sessions for the username "bob"
     * remote(os.toast("Hello, Bob!"), { username: "bob" });
     */
    function remote(
        event: BotAction,
        selector?: SessionSelector | string | (SessionSelector | string)[],
        allowBatching?: boolean
    ): RemoteAction | RemoteAction[];

    /**
     * Sends an event to the given remote or list of remotes.
     * The other remotes will recieve an onRemoteData shout for this whisper.
     * 
     * In effect, this allows remotes to communicate with each other by sending arbitrary events.
     * 
     * @param remoteId The ID of the other remote or remotes to whisper to.
     * @param name The name of the event.
     * @param arg The optional argument to include in the event.
     */
    function sendRemoteData(remoteId: string | string[], name: string, arg?: any): RemoteAction | RemoteAction[];

    /**
     * Gets the first bot which matches all of the given filters.
     * @param filters The filter functions that the bot needs to match.
     * @returns The first bot that matches all the given filters.
     *
     * @example
     * // Get a bot by the "name" tag.
     * let bot = getBot(byTag("name", "The bot's name"));
     */
    function getBot(...filters: BotFilterFunction[]): Bot;

    /**
     * Gets the first bot ordered by ID which matches the given tag and filter.
     * @param tag The tag the bot should match.
     * @param filter The optional value or filter the bot should match.
     *
     * @example
     * // Get a bot with the "name" tag.
     * // Shorthand for getBot(byTag("name"))
     * let bot = getBot("name");
     *
     * @example
     * // Get a bot by the "name" tag.
     * // Shorthand for getBot(byTag("name", "The bot's name"))
     * let bot = getBot("name", "The bot's name");
     *
     * @example
     * // Get a bot where the "name" tag starts with the letter "N".
     * // Shorthand for getBot(byTag("name", name => name.startsWith("N")))
     * let bot = getBot("name", name => name.startsWith("N"));
     */
    function getBot(tag: string, filter?: any | TagFilter): Bot;

    /**
     * Gets the first bot ordered by ID.
     * @returns The bot with the first ID when sorted alphebetically.
     *
     * @example
     * let firstBot = getBot();
     */
    function getBot(): Bot;

    /**
     * Gets the list of bots which match all of the given filters.
     * @param filters The filter functions that the bots need to match.
     * @returns A list of bots that match all the given filters. If no bots match then an empty list is returned.
     *
     * @example
     * // Get all the bots that are red.
     * let bots = getBots(byTag("color", "red"));
     */
    function getBots(...filters: ((bot: Bot) => boolean)[]): Bot[];

    /**
     * Gets the list of bots that have the given tag matching the given filter value.
     * @param tag The tag the bot should match.
     * @param filter The value or filter the bot should match.
     *
     * @example
     * // Get all the bots that are red.
     * // Shorthand for getBots(byTag("color", "red"))
     * let bots = getBots("color", "red");
     */
    function getBots(tag: string, filter?: any | TagFilter): Bot[];

    /**
     * Gets a list of all the bots.
     *
     * @example
     * // Gets all the bots in the server.
     * let bots = getBots();
     */
    function getBots(): Bot[];

    /**
     * Gets the list of tag values from bots that have the given tag.
     * @param tag The tag.
     * @param filter THe optional filter to use for the values.
     */
    function getBotTagValues(tag: string, filter?: TagFilter): any[];

    /**
     * Creates a filter function that checks whether bots have the given tag and value.
     * @param tag The tag to check.
     * @param filter The value or filter that the tag should match.
     *
     * @example
     * // Find all the bots with a "name" of "bob".
     * let bobs = getBots(byTag("name", "bob"));
     *
     * @example
     * // Find all bots with a height larger than 2.
     * let bots = getBots(byTag("height", height => height > 2));
     *
     * @example
     * // Find all the bots with the "test" tag.
     * let bots = getBots(byTag("test"));
     */
    function byTag(tag: string, filter?: TagFilter): BotFilterFunction;

    /**
     * Creates a filter function that checks whether bots have the given ID.
     * @param id The ID to check for.
     * 
     * @example
     * // Find all the bots with the ID "bob".
     * let bobs = getBots(byId("bob"));
     */
    function byID(id: string): IDRecordFilter;

    /**
     * Creates a filter function that checks whether bots match the given mod.
     * @param mod The mod that bots should be checked against.
     *
     * @example
     * // Find all the bots with a height set to 1 and color set to "red".
     * let bots = getBots(byMod({
     *      "color": "red",
     *      height: 1
     * }));
     */
    function byMod(mod: Mod): BotFilterFunction;

    /**
     * Creates a filter function that checks whether bots are in the given dimension.
     * @param dimension The dimension to check.
     * @returns A function that returns true if the given bot is in the dimension and false if it is not.
     *
     * @example
     * // Find all the bots in the "test" dimension.
     * let bots = getBots(inDimension("test"));
     */
    function inDimension(dimension: string): BotFilterFunction;

    /**
     * Creates a filter function that checks whether bots are at the given position in the given dimension.
     * @param dimension The dimension that the bots should be in.
     * @param x The X position in the dimension that the bots should be at.
     * @param y The Y position in the dimension that the bots should be at.
     * @returns A function that returns true if the given bot is at the given position and false if it is not.
     *
     * @example
     * // Find all the bots at (1, 2) in the "test" dimension.
     * let bots = getBots(atPosition("test", 1, 2));
     */
    function atPosition(
        dimension: string,
        x: number,
        y: number
    ): BotFilterFunction;

    /**
     * Creates a filter function that checks whether bots were created by the given bot.
     * @param bot The bot to determine weather the bots have been created by it or not.
     * @returns A function that returns true if the bot was created by the given bot.
     *
     * @example
     * // Find all the bots created by the yellow bot.
     * let bots = getBots(byCreator(getBot('color','yellow')));
     */
    function byCreator(bot: Bot | string);

    /**
     * Creates a filter function that checks whether bots are in the same stack as the given bot.
     * @param bot The bot that other bots should be checked against.
     * @param dimension The dimension that other bots should be checked in.
     * @returns A function that returns true if the given bot is in the same stack as the original bot.
     *
     * @example
     * // Find all bots in the same stack as `this` in the "test" dimension.
     * let bots = getBots(inStack(this, "test"));
     *
     */
    function inStack(bot: Bot, dimension: string): BotFilterFunction;

    /**
     * Creates a function that filters bots by whether they are in the given space.
     * @param space The space that the bots should be in.
     */
    function bySpace(space: string): BotFilterFunction;

    /**
     * Creates a function that filters bots by whether they are neighboring the given bot.
     * @param bot The bot that other bots should be checked against.
     * @param dimension The dimension that other bots should be checked in.
     * @param direction The neighboring direction to check.
     * @returns A function that returns true if the given bot is next to the original bot.
     *
     * @example
     * // Find all bots in front of `this` bot in the "test" dimension.
     * let bots = getBots(neighboring(this, "test", "front"));
     */
    function neighboring(
        bot: Bot,
        dimension: string,
        direction: 'front' | 'left' | 'right' | 'back'
    ): BotFilterFunction;

    /**
     * Creates a function that filters bots by whether they match any of the given filters.
     * @param filters The filter functions that a bot should be tested against.
     *
     * @example
     * // Find all bots with the name "bob" or height 2.
     * let bots = getBots(
     *   either(
     *     byTag("name", "bob"),
     *     byTag("height", height => height === 2)
     *   )
     * );
     */
    function either(...filters: BotFilterFunction[]): BotFilterFunction;

    /**
     * Creates a function that negates the result of the given function.
     * @param filter The function whose results should be negated.
     *
     * @example
     * // Find all bots that are not in the "test" dimension.
     * let bots = getBots(not(inDimension("test")));
     */
    function not(filter: BotFilterFunction): BotFilterFunction;

    /**
     * Creates a record filter that retrieves records created by the given Auth ID.
     * @param authID The ID of the creator of the records.
     */
     function byAuthID(authID: string): AuthIdRecordFilter;

    /**
     * Creates a record filter that retrieves records with the given address.
     * @param address The address that the record was stored at.
     */
     function byAddress(address: string): AddressRecordFilter;

    /**
     * Creates a record filter that retrieves records with the given address.
     * @param token The auth token that should be used to authenticate the getRecords() request.
     */
    function withAuthToken(token: string): AuthTokenRecordFilter;

    /**
     * Creates a record filter that retrieves records with the given prefix in their address.
     * @param prefix The prefix that should be matched to record addresses.
     */
    function byPrefix(prefix: string): PrefixRecordFilter;

    /**
     * Gets the value of the given tag stored in the given bot.
     * @param bot The bot.
     * @param tag The tag.
     *
     * @example
     * // Get the "color" tag from the `this` bot.
     * let color = getTag(this, "color");
     */
    function getTag(bot: Bot, ...tags: string[]): any;

    /**
     * Sets the value of the given tag stored in the given bot.
     * @param bot The bot.
     * @param tag The tag to set.
     * @param value The value to set.
     *
     * @example
     * // Set a bot's color to "green".
     * setTag(this, "color", "green");
     */
    function setTag(bot: Bot | Bot[] | BotTags, tag: string, value: any): any;

    /**
     * Sets the value of the given tag mask in the given bot.
     * @param bot The bot.
     * @param tag The tag to set.
     * @param value The value to set.
     * @param space The space that the tag mask should be placed in. If not specified, then the tempLocal space will be used.
     * 
     * @example
     * // Set a bot's color to "green".
     * setTagMask(this, "color", "green")
     */
    function setTagMask(bot: Bot | Bot[], tag: string, value: any, space?: BotSpace): any;

    /**
     * Clears the tag masks from the given bot.
     * @param bot The bot or bots that the tag masks should be cleared from.
     * @param space The space that the tag masks should be cleared from. If not specified, then all spaces will be cleared.
     */
    function clearTagMasks(bot: Bot | Bot[], space?: BotSpace): void;

    /**
     * Inserts the given text into the given tag at the given index.
     * Returns the resulting raw tag value.
     * @param bot The bot that should be edited.
     * @param tag The tag that should be edited.
     * @param index The index that the text should be inserted at.
     * @param text The text that should be inserted.
     */
    function insertTagText(
        bot: Bot,
        tag: string,
        index: number,
        text: string
    ): string;

    /**
     * Inserts the given text into the given tag and space at the given index.
     * Returns the resulting raw tag mask value.
     * @param bot The bot that should be edited.
     * @param tag The tag that should be edited.
     * @param index The index that the text should be inserted at.
     * @param text The text that should be inserted.
     * @param space The space that the tag exists in. If not specified then the tempLocal space will be used.
     */
    function insertTagMaskText(
        bot: Bot,
        tag: string,
        index: number,
        text: string,
        space?: BotSpace
    ): string;

    /**
     * Deletes the specified number of characters from the given tag.
     * Returns the resulting raw tag value.
     * @param bot The bot that should be edited.
     * @param tag The tag that should be edited.
     * @param index The index that the text should be deleted at.
     * @param count The number of characters to delete.
     */
    function deleteTagText(
        bot: Bot,
        tag: string,
        index: number,
        count: number
    ): string;

    /**
     * Deletes the specified number of characters from the given tag mask.
     * Returns the resulting raw tag mask value.
     * @param bot The bot that should be edited.
     * @param tag The tag that should be edited.
     * @param index The index that the text should be deleted at.
     * @param count The number of characters to delete.
     * @param space The space that the tag mask exists in. If not specified then the tempLocal space will be used.
     */
    function deleteTagMaskText(
        bot: Bot,
        tag: string,
        index: number,
        count: number,
        space?: string
    ): string;

    /**
     * Creates a mod from declareed mod data.
     * @param bot The mod data that should be loaded.
     * @param tags The tags that should be included in the output mod.
     * @returns The mod that was loaded from the data.
     */
    function getMod(bot: any, ...tags: (string | RegExp)[]): Mod;

    /**
     * Gets the position that the given bot is at in the given dimension.
     * @param bot The bot or bot ID.
     * @param dimension The dimension that the bot's position should be retrieved for.
     */
     function getBotPosition(
        bot: Bot | string,
        dimension: string
    ): Point3D;

    /**
     * Applies the given diff to the given bot.
     * @param bot The bot.
     * @param diff The diff to apply.
     */
    function applyMod(bot: any, ...diffs: Mod[]): void;

    /**
     * subrtacts the given diff from the given bot.
     * @param bot The bot.
     * @param diff The diff to apply.
     */
    function subtractMods(bot: any, ...diffs: Mod[]): void;

    /**
     * Produces HTML from the given HTML strings and expressions.
     * Best used with a tagged template string.
     */
    const html: HtmlFunction;

    /**
     * Defines a set of functions that relate to common OS operations.
     */
    const os: {

        /**
         * Sleeps for time in ms.
         * @param time Time in ms. 1 second is 1000ms.
         */
        sleep(time: number): Promise<void>;

        /**
         * Derermines whether the player is in the given dimension.
         * @param dimension The dimension.
         */
        isInDimension(dimension: string): string;

        /**
         * Redirects the user to the given dimension.
         * @param dimension The dimension to go to.
         *
         * @example
         * // Send the player to the "welcome" dimension.
         * os.goToDimension("welcome");
         */
        goToDimension(dimension: string): GoToDimensionAction;

        /**
         * Instructs CasualOS to open the built-in developer console.
         * The dev console provides easy access to error messages and debug logs for formulas and actions.
         */
        openDevConsole(): OpenConsoleAction;

        /**
         * Changes the state that the given bot is in.
         * @param bot The bot to change.
         * @param stateName The state that the bot should move to.
         * @param groupName The group of states that the bot's state should change in. (Defaults to "state")
         */
        changeState(bot: Bot, stateName: string, groupName?: string): void;

        /**
         * Enables Augmented Reality features.
         */
        enableAR(): EnableARAction;

        /**
         * Enables Virtual Reality features.
         */
        enableVR(): EnableVRAction;

        /**
         * Disables Augmented Reality features.
         */
        disableAR(): EnableARAction;

        /**
         * Disables Virtual Reality features.
         */
        disableVR(): EnableVRAction;

        /**
         * Enables Point-of-View mode.
         */
        enablePointOfView(center?: Point3D): EnablePOVAction;

        /**
         * Disables Point-of-View mode.
         */
        disablePointOfView(): EnablePOVAction;

        /**
         * Gets the dimension that is loaded into the given portal for the player.
         * If no dimension is loaded, then null is returned.
         * @param portal The portal type.
         */
        getPortalDimension(portal: PortalType): string;

        /**
         * Gets information about the version of AUX that is running.
         */
        version(): AuxVersion;

        /**
         * Gets information about the device that the player is using.
         */
        device(): AuxDevice;

        /**
         * Gets whether this device has enabled collaborative features.
         */
        isCollaborative(): boolean;

        /**
         * Gets the URL that AB1 should be bootstrapped from.
         */
        getAB1BootstrapURL(): string;

        /**
         * Gets whether the player is in the sheet dimension.
         */
        inSheet(): boolean;

        /**
         * Gets the 3D position of the player's camera.
         * @param portal The portal that the camera position should be retrieved for.
         */
        getCameraPosition(portal?: 'page' | 'mini'): Point3D;

        /**
         * Gets the 3D rotation of the player's camera.
         * @param portal The portal that the camera rotation should be retrieved for.
         */
        getCameraRotation(portal?: 'page' | 'mini'): Point3D;

        /**
         * Gets the 3D point that the player's camera is focusing on.
         * @param portal The portal that the camera focus point should be retrieved for.
         */
        getFocusPoint(portal?: 'page' | 'mini'): Point3D;

        /**
         * Gets the 3D position of the player's pointer.
         * @param pointer The position of the pointer to retrieve.
         */
        getPointerPosition(pointer?: 'mouse' | 'left' | 'right'): Point3D;

        /**
         * Gets the 3D rotation of the player's pointer.
         * @param pointer The rotation of the pointer to retrieve.
         */
        getPointerRotation(pointer?: 'mouse' | 'left' | 'right'): Point3D;

        /**
         * Gets the 3D direction that the given pointer is pointing in.
         * @param pointer The pointer to get the direction of.
         */
        getPointerDirection(pointer?: 'mouse' | 'left' | 'right'): Point3D;

        /**
         * Gets the input state of the given button on the mouse.
         * @param controller The name of the controller that should be checked.
         * @param button The name of the button on the controller.
         */
        getInputState(controller: 'mousePointer', button: 'left' | 'right' | 'middle'): null | 'down' | 'held';

        /**
         * Gets the input state of the given button on the left or right controller.
         * @param controller The name of the controller that should be checked.
         * @param button The name of the button on the controller.
         */
        getInputState(controller: 'leftPointer' | 'rightPointer', button: 'primary' | 'squeeze'): null | 'down' | 'held';

        /**
         * Gets the input state of the given button on the keyboard.
         * @param controller The name of the controller that should be checked.
         * @param button The name of the button on the controller.
         */
        getInputState(controller: 'keyboard', button: string): null | 'down' | 'held';

        /**
         * Gets the input state of the given touch.
         * @param controller The name of the controller that should be checked.
         * @param button The index of the finger.
         */
        getInputState(controller: 'touch', button: '0' | '1' | '2' | '3' | '4'): null | 'down' | 'held';

        /**
         * Gets the input state of the given button on the given controller.
         * @param controller The name of the controller that should be checked.
         * @param button The name of the button on the controller.
         */
        getInputState(controller: string, button: string): null | 'down' | 'held';

        /**
         * Gets the list of inputs that are currently available.
         */
        getInputList(): string[];

        /**
         * Shows a toast message to the user.
         * @param message The message to show.
         * @param duration The number of seconds the message should be on the screen. (Defaults to 2)
         */
        toast(message: string | number | boolean | object | Array<any> | null, duration?: number): ShowToastAction;

        /**
         * Play the given url's audio.
         * Returns a promise that resolves with the sound ID when the sound starts playing.
         * @param url The URL to play.
         * 
         * @example
         * // Play a cow "moo"
         * os.playSound("https://freesound.org/data/previews/58/58277_634166-lq.mp3");
         */
        playSound(url: string): Promise<string>;

        /**
         * Preloads the audio for the given URL.
         * Returns a promise that resolves when the audio has finished loading.
         * @param url The URl to preload.
         * 
         * @example
         * // Preload a cow "moo"
         * os.bufferSound("https://freesound.org/data/previews/58/58277_634166-lq.mp3");
         */
        bufferSound(url: string): Promise<void>;

        /**
         * Cancels the sound with the given ID.
         * Returns a promise that resolves when the audio has been canceled.
         * @param soundID The ID of the sound that is being canceled.
         *
         * @example
         * // Play and cancel a sound
         * const id = await os.playSound("https://freesound.org/data/previews/58/58277_634166-lq.mp3");
         * os.cancelSound(id);
         */
        cancelSound(soundID: number): Promise<void>;

        /**
         * Shows a QR Code that contains a link to a server and dimension.
         * @param server The server that should be joined. Defaults to the current server.
         * @param dimension The dimension that should be joined. Defaults to the current dimension.
         */
        showJoinCode(
            server?: string,
            dimension?: string
        ): ShowJoinCodeAction;

        /**
         * Requests that AUX enters fullscreen mode.
         * Depending on the web browser, this may ask the player for permission.
         */
        requestFullscreenMode(): RequestFullscreenAction;

        /**
         * Exits fullscreen mode.
         */
        exitFullscreenMode(): ExitFullscreenAction;

        /**
         * Shares some information via the device's social sharing functionality.
         * @param options The options.
         */
        share(options: ShareOptions): ShareAction;

        /**
         * Closes the circle wipe transition effect.
         * @param options The options that should be used for the effect.
         */
        closeCircleWipe(options?: Partial<OpenCircleWipeOptions>): Promise<void>;

        /**
         * Opens the circle wipe transition effect.
         * @param options The options that should be used for the effect.
         */
        openCircleWipe(options?: Partial<OpenCircleWipeOptions>): Promise<void>;

        /**
         * Adds the given list of snap targets to the current drag operation.
         * @param targets The list of targets to add.
         */
        addDropSnap(...targets: SnapTarget[]): AddDropSnapTargetsAction;

        /**
         * Adds the given list of snap targets for when the specified bot is being dropped on.
         * @param bot The bot.
         * @param targets The targets that should be enabled when the bot is being dropped on.
         */
        addBotDropSnap(bot: Bot | string, ...targets: SnapTarget[]): AddDropSnapTargetsAction;

        /**
         * Enables custom dragging for the current drag operation.
         * This will disable the built-in logic that moves the bot(s) and
         * enables the "onDragging" and "onAnyBotDragging" listen tags.
         */
        enableCustomDragging(): EnableCustomDraggingAction;

        /**
         * Logs the given data to the developer console.
         * @param args The data to log.
         */
        log(...args: any[]): void;

        /**
         * Gets the geolocation of the device.
         * Returns a promise that resolves with the location.
         */
        getGeolocation(): Promise<GeoLocation>;

        /**
         * Shows some HTML to the user.
         * @param html The HTML to show.
         */
        showHtml(html: string): ShowHtmlAction;

        /**
         * Hides the HTML from the user.
         */
        hideHtml(): HideHtmlAction;

        /**
         * Moves the camera to view the given bot.
         * Returns a promise that resolves when the bot is focused.
         * @param botOrPosition The bot, bot ID, or position to view.
         * @param options The options to use for moving the camera.
         */
        focusOn(
            botOrPosition: Bot | string | { x: number, y: number },
            options: FocusOnOptions
        ): Promise<void>;

        /**
         * Opens the QR Code Scanner.
         * @param camera The camera that should be used.
         */
        openQRCodeScanner(camera?: CameraType): OpenQRCodeScannerAction;

        /**
         * Closes the QR Code Scanner.
         */
        closeQRCodeScanner(): OpenQRCodeScannerAction;

        /**
         * Shows the given QR Code.
         * @param code The code to show.
         */
        showQRCode(code: string): ShowQRCodeAction;

        /**
         * Hides the QR Code.
         */
        hideQRCode(): ShowQRCodeAction;

        /**
         * Opens the barcode scanner.
         * @param camera The camera that should be used.
         */
        openBarcodeScanner(camera?: CameraType): OpenBarcodeScannerAction;

        /**
         * Closes the barcode scanner.
         */
        closeBarcodeScanner(): OpenBarcodeScannerAction;

        /**
         * Shows the given barcode.
         * @param code The code that should be shown.
         * @param format The format that the barcode should be shown in.
         */
        showBarcode(code: string, format?: BarcodeFormat): ShowBarcodeAction;

        /**
         * Hides the barcode.
         */
        hideBarcode(): ShowBarcodeAction;

        /**
         * Shows the chat bar.
         */
        showChat(): ShowChatBarAction;

        /**
         * Shows the chat bar with the given placeholder.
         * @param placeholder The placeholder text that should be in the chat bar.
         */
        showChat(placeholder: string): ShowChatBarAction;

        /**
         * Shows the chat bar with the given options.
         * @param options The options that should be used to show the chat bar.
         */
        showChat(options: ShowChatOptions): ShowChatBarAction;

        /**
         * Shows the run bar.
         * @param placeholderOrOptions The placeholder text or options. (optional)
         */
        showChat(
            placeholderOrOptions?: string | ShowChatOptions
        ): ShowChatBarAction;

        /**
         * Hides the run bar.
         */
        hideChat(): ShowChatBarAction;

        /**
         * Enqueues the given script to execute after this script is done running.
         * @param script The script that should be executed.
         */
        run(script: string): Promise<any>;

        /**
         * Downloads the given data.
         * @param data The data to download. Objects will be formatted as JSON before downloading.
         * @param filename The name of the file that the data should be downloaded as.
         * @param mimeType The MIME type that should be used. If not specified then it will be inferred from the filename.
         */
        download(
            data: string | object | ArrayBuffer | Blob,
            filename: string,
            mimeType?: string
        ): DownloadAction;

        /**
         * Downloads the given list of bots.
         * @param bots The bots that should be downloaded.
         * @param filename The name of the file that the bots should be downloaded as.
         */
        downloadBots(bots: Bot[], filename: string): DownloadAction;

        /**
         * Downloads all the shared bots in the server.
         */
        downloadServer(): DownloadAction;

        /**
         * Shows the "Upload AUX File" dialog.
         */
        showUploadAuxFile(): ShowUploadAuxFileAction;

        /**
         * Shows the "Upload Files" dialog.
         */
        showUploadFiles(): Promise<UploadedFile[]>;

        /**
         * Loads the server with the given ID.
         * @param id The ID of the server to load.
         */
        loadServer(id: string): LoadServerAction;

        /**
         * Unloads the server with the given ID.
         * @param id The ID of the server to unload.
         */
        unloadServer(id: string): UnloadServerAction;

        /**
         * Imports the AUX from the given URL or JSON
         * @param urlOrJSON The URL or JSON to load.
         *                  If given JSON, then it will be imported as if it was a .aux file.
         *                  If given a URL, then it will be downloaded and then imported.
         */
        importAUX(urlOrJSON: string): ImportAUXAction | ApplyStateAction;

        /**
         * Parses the given JSON or PDF data and returns the list of bots that were contained in it.
         * @param jsonOrPdf The JSON or PDF data to parse.
         */
        parseBotsFromData(jsonOrPdf: string): Bot[];

        /**
         * Replaces the bot that the user is beginning to drag.
         * Only works from inside a onDrag() or onAnyBotDrag() listen tag.
         * @param bot The bot or mod that should be dragged instead of the original.
         */
        replaceDragBot(bot: Mod): ReplaceDragBotAction;

        /**
         * Sets the text stored in the player's clipboard.
         * @param text The text to set to the clipboard.
         */
        setClipboard(text: string): SetClipboardAction;

        /**
         * Redirects the user to the given URL.
         * @param url The URL to go to.
         *
         * @example
         * // Send the player to wikipedia.
         * os.goToURL("https://wikipedia.org");
         */
        goToURL(url: string): GoToURLAction;

        /**
         * Redirects the user to the given URL.
         * @param url The URL to go to.
         *
         * @example
         * // Open wikipedia in a new tab.
         * os.openURL("https://wikipedia.org");
         */
        openURL(url: string): OpenURLAction;

        /**
         * Shows an input box to edit the given bot and tag.
         *
         * @param bot The bot or bot ID that should be edited.
         * @param tag The tag which should be edited on the bot.
         * @param options The options that indicate how the input box should be customized.
         *
         * @example
         * // Show an input box for `this` bot's label.
         * os.showInputForTag(this, "label", {
         *            title: "Change the label",
         *            type: "text"
         * });
         *
         * @example
         * // Show a color picker for the bot's color.
         * os.showInputForTag(this, "color", {
         *            title: "Change the color",
         *            type: "color",
         *            subtype: "advanced"
         * });
         */
        showInputForTag(
            bot: Bot | string,
            tag: string,
            options?: Partial<ShowInputOptions>
        ): ShowInputForTagAction;

        /**
         * Shows an input box. Returns a promise that resolves with the new value.
         *
         * @param currentValue The value that the input box should be prefilled with.
         * @param options The options that indicate how the input box should be customized.
         *
         * @example
         * // Show an input box.
         * const result = await os.showInput({
         *    title: "Change the label",
         *    type: "text"
         * });
         */
        showInput(
            currentValue?: any,
            options?: Partial<ShowInputOptions>
        ): Promise<string>;

        /**
         * Shows a checkout screen that lets the user purchase something.
         *
         * @param options The options for the payment box.
         *
         * @example
         * // Show a checkout box for 10 cookies
         * os.checkout({
         *   productId: '10_cookies',
         *   title: '10 Cookies',
         *   description: '$5.00',
         *   processingServer: 'cookies_checkout'
         * });
         *
         */
        checkout(options: CheckoutOptions): StartCheckoutAction;

        /**
         * Gets the dimension that the player is currently viewing.
         */
        getCurrentDimension(): string;

        /**
         * Gets the server that the player is currently in.
         */
        getCurrentServer(): string;

        /**
         * Gets the distance that the player bot is from the given dimension.
         *
         * Returns 0 if the player bot is in the dimension, 1 if the dimension is in a portal, and -1 if neither are true.
         *
         * @param dimension The dimension to check for.
         */
        getDimensionalDepth(dimension: string): number;

        /**
         * Determines whether the player has the given bot in their mini portal.
         * @param bots The bot or bots to check.
         */
        hasBotInMiniPortal(bots: Bot | Bot[]): boolean;

        /**
         * Gets the current user's bot.
         */
        getBot(): Bot;

        /**
         * Gets the name of the dimension that is used for the current user's menu.
         */
        getMenuDimension(): string;

        /**
         * Gets the name of the dimension that is used for the current user's mini portal.
         */
        getMiniPortalDimension(): string;

        /**
         * Registers a custom app for the given bot with the given options.
         * Apps allow you add custom functionality to the CasualOS frontend and are deeply integrated into the CasualOS platform.
         * 
         * @param id The ID of the app.
         * @param bot The bot that should be used to control the app.
         */
         registerApp(
            id: string,
            bot: Bot | string
        ): Promise<void>;

        /**
         * Removes a custom app from the session.
         * 
         * @param id The ID of the app.
         */
        unregisterApp(
            id: string
        ): Promise<void>;

        /**
         * Sets the output of the given app.
         * @param id The ID of the app.
         * @param output The output that the app should display.
         */
        compileApp(id: string, output: any): SetAppOutputAction;

        /**
         * Requests that the current session be authorized and for a global bot to be created
         * to contain information about the authorized user.
         */
        requestAuthBot(): Promise<Bot>;

        /**
         * Requests an auth token that does not expire and can be used to authorize other app bundles to publish records for this app bundle.
         */
        requestPermanentAuthToken(): Promise<string>;

        /**
         * Publishes a record that can be used across servers.
         * @param recordDefinition The data that should be used to publish the record.
         */
        publishRecord(recordDefinition: PublishableRecord): Promise<void>;

        /**
         * Retrives a list of records using the given filters.
         * @param filters The list of filters that should be used to retrieve some records.
         */
        getRecords(...filters: RecordFilters[]): Promise<GetRecordsResult>;

        /**
         * Requests that the given record be destroyed.
         * @param record The record that should be deleted.
         */
        destroyRecord(record: DeletableRecord): Promise<void>;

        /**
         * Specifies that the given prefix should be interpreted as code.
         * @param prefix The prefix that code tags should start with.
         * @param options The options that should be used for the prefix.
         */
         registerTagPrefix(prefix: string, options?: RegisterPrefixOptions): Promise<void>;

        /**
         * Registers a custom executable with the given source code.
         * Executables can contain arbitrary code that can run anywhere.
         * As such, executables allow you to add custom functionality that is not deeply integrated into the CasualOS platform.
         * 
         * @param id The ID of the executable.
         * @param bot The bot that should be used to configure the executable.
         * @param tagOrSource The tag or source code that the executable should be created from.
         * @param options The options for the executable.
         */
        registerExecutable(
            id: string,
            bot: Bot | string,
            tagOrSource?: string,
            options?: OpenCustomPortalOptions
        ): Promise<void>;

        /**
         * Builds an executable bundle from the given tag.
         * @param tag The tag that the bundle should be created from.
         */
        buildExecutable(tag: string): Promise<CodeBundle>;
    };

    /**
     * Defines a set of functions that relate to common server operations.
     */
    const server: {
        /**
         * Sends an event to the server to setup a new server if it does not exist.
         * @param server The server.
         * @param botOrMod The bot or mod that should be cloned into the new server.
         */
        setupServer(server: string, botOrMod?: Mod): Promise<void>;
    
        /**
         * Sends an event to the server to export a pin (BCM) as input or output.
         * @param pin The physical pin (BCM) number.
         * @param mode The mode of the pin (BCM).
         */
        exportGpio(pin: number, mode: 'in' | 'out'): Promise<void>;

        /**
         * Sends an event to the server to unexport a pin (BCM).
         * @param pin The physical pin (BCM) number.
         */
        unexportGpio(pin: number): Promise<void>;

        /**
         * Sends an event to the server to set a pin (BCM) as HIGH or LOW.
         * @param pin The physical pin (BCM) number.
         * @param value The mode of the pin (BCM).
         */
        setGpio(pin: number, value: 0 | 1): Promise<void>;

        /**
         * Sends an event to the server to get the value of a pin (BCM).
         * @param pin The physical pin (BCM) number.
         */
        getGpio(pin: number): Promise<void>;

        /**
         * Sends an event to the server to initialize rpio with provided settings
         * @param options An object containing values to initilize with.
         * 
         * @example
         * // Initialize with default settings
         * server.rpioInit({
         *   gpiomem: true,
         *   mapping: 'physical',
         *   mock: undefined,
         *   close_on_exit: false
         * }); 
         */
        rpioInit(options?: object): Promise<void>;

        /**
         * Shuts down rpio, unmaps, and clears everything.
         */
        rpioExit(): Promise<void>;

        /**
         * Sends an event to the server to open a pin as input or output and set its initial state.
         * @param pin The physical pin number.
         * @param mode The mode of the pin.
         * @param options The initial state of the pin.
         */
        rpioOpen(pin: number, mode: 'INPUT' | 'OUTPUT' | 'PWM', options?: 'HIGH' | 'LOW' | 'PULL_OFF' | 'PULL_DOWN' | 'PULL_UP'): Promise<void>;

        /**
         * Sends an event to the server to change the mode and optionally the state, of a previously opened pin.
         * @param pin The physical pin number.
         * @param mode The mode of the pin.
         * @param options The initial state of the pin.
         */
        rpioMode(pin: number, mode: 'INPUT' | 'OUTPUT' | 'PWM', options?: 'HIGH' | 'LOW' | 'PULL_OFF' | 'PULL_DOWN' | 'PULL_UP'): Promise<void>;

        /**
         * Sends an event to the server to read the value of a pin.
         * @param pin The physical pin number.
         */
        rpioRead(pin: number): Promise<void>;

        /**
         * Sends an event to the server to read the pin's buffer.
         * @param pin The physical pin number.
         * @param buffer The buffer to read.
         * @param length The length of the buffer.
         */
        rpioReadSequence(pin: number, buffer: number, length?: number): Promise<void>;

        /**
         * Sends an event to the server to write to a pin and set it as HIGH or LOW.
         * @param pin The physical pin number.
         * @param value The mode of the pin.
         */
        rpioWrite(pin: number, value: 'HIGH' | 'LOW'): Promise<void>;

        /**
         * Sends an event to the server to write to the pin's buffer.
         * @param pin The physical pin number.
         * @param buffer The buffer to write to.
         * @param length The length of the buffer.
         */
        rpioWriteSequence(pin: number, buffer: number[], length?: number): Promise<void>;

        /**
         * Read the current state of the GPIO pad control for the specified GPIO group.
         * On current models of Raspberry Pi there are three groups.
         * 
         * 'PAD_GROUP_0_27' is GPIO0 - GPIO27. Use this for the main GPIO header.
         * 'PAD_GROUP_28_45' is GPIO28 - GPIO45. Use this to configure the P5 header.
         * 'PAD_GROUP_46_53' is GPIO46 - GPIO53. Internal, you probably won't need this.
         * 
         * @param group The GPIO group to be read.
         * @param bitmask The bitmask you want to check.
         */
        rpioReadpad(group: 'PAD_GROUP_0_27' | 'PAD_GROUP_28_45' | 'PAD_GROUP_46_53', bitmask: 'slew' | 'hysteresis' | 'current'): Promise<void>;

        /**
         * Write `control` settings to the pad control for `group`.
         * 
         * 'PAD_GROUP_0_27' is GPIO0 - GPIO27. Use this for the main GPIO header.
         * 'PAD_GROUP_28_45' is GPIO28 - GPIO45. Use this to configure the P5 header.
         * 'PAD_GROUP_46_53' is GPIO46 - GPIO53. Internal, you probably won't need this.
         * 
         * @param group The GPIO group to be read.
         * @param slew Slew rate unlimited if set to true.
         * @param hysteresis Hysteresis is enabled if set to true.
         * @param current Drive current set in mA. Must be an even number 2-16.
         */
        rpioWritepad(group: 'PAD_GROUP_0_27' | 'PAD_GROUP_28_45' | 'PAD_GROUP_46_53', slew?: boolean, hysteresis?: boolean, current?: 2 | 4 | 6 | 8 | 10 | 12 | 14 | 16): Promise<void>;

        /**
         * Configure the pin's internal pullup or pulldown resistors.
         * @param pin The pin that you want to use.
         * @param state Configure the pin's resistors as: 'PULL_OFF', 'PULL_DOWN' or 'PULL_UP'
         */
        rpioPud(pin: number, state: 'PULL_OFF' | 'PULL_DOWN' | 'PULL_UP'): Promise<void>;

        /**
         * Watch `pin` for changes and execute the callback `cb()` on events.
         * @param pin The pin that you want to use.
         * @param cb The callback executed on events.
         * @param options Optional. Used to watch for specific events.
         */
        rpioPoll(pin: number, cb: any, options?: 'POLL_LOW' | 'POLL_HIGH' | 'POLL_BOTH'): Promise<void>;

        /**
         * Sends an event to the server to close a pin and what state to leave it in.
         * @param pin The physical pin number.
         * @param options The state to leave the pin in upon closing.
         */
        rpioClose(pin: number, options: 'PIN_RESET' | 'PIN_PRESERVE'): Promise<void>;

        /**
         * Initializes i2c for use.
         */
        rpioI2CBegin(): Promise<void>;
        
        /**
         * Configure the slave address.
         * @param address The slave address to set.
         */
        rpioI2CSetSlaveAddress(address: number): Promise<void>;
        
        /**
         * Set the baud rate. Directly set the speed in hertz.
         * @param rate The i2c refresh rate in hertz.
         */
        rpioI2CSetBaudRate(rate: number): Promise<void>;
        
        /**
         * Set the baud rate. Set it based on a divisor of the base 250MHz rate.
         * @param rate The i2c refresh rate based on a divisor of the base 250MHz rate.
         */
        rpioI2CSetClockDivider(rate: number): Promise<void>;
        
        /**
         * Read from the i2c slave.
         * @param rx Buffer to read.
         * @param length Optional. Length of the buffer to read.
         */
        rpioI2CRead(rx: number[], length?: number): Promise<void>;
        
        /**
         * Write to the i2c slave.
         * @param tx Buffer to write.
         * @param length Optional. Length of the buffer to write.
         */
        rpioI2CWrite(tx: number[], length?: number): Promise<void>;
        
        /**
         * 
         */
        // rpioI2CReadRegisterRestart(): Promise<void>;
        
        /**
         * 
         */
        // rpioI2CWriteReadRestart(): Promise<void>;
        
        /**
         * Turn off the ic interface and return the pins to GPIO.
         */
        rpioI2CEnd(): Promise<void>;
        
        
        /**
         * This is a power-of-two divisor of the base 19.2MHz rate, with a maximum value of 4096 (4.6875kHz).
         * @param rate The PWM refresh rate.
         */
        rpioPWMSetClockDivider(rate: number): Promise<void>;
        
        /**
         * This determines the maximum pulse width.
         * @param pin The physical pin number.
         * @param range The PWM range for a pin.
         */
        rpioPWMSetRange(pin: number, range: number): Promise<void>;
        
        
        /**
         * Set the width for a given pin.
         * @param pin The physical pin number.
         * @param width The PWM width for a pin.
         */
        rpioPWMSetData(pin: number, width: number): Promise<void>;
        
        /**
         * Initiate SPI mode.
         */
        rpioSPIBegin(): Promise<void>;
        
        /**
         * Choose which of the chip select / chip enable pins to control.
         *  Value | Pin
         *  ------|---------------------
         *    0   | SPI_CE0 (24 / GPIO8)
         *    1   | SPI_CE1 (26 / GPIO7)
         *    2   | Both
         * @param value The value correlating to pin(s) to control.
         */
        rpioSPIChipSelect(value: 0 | 1 | 2): Promise<void>;
        
        /**
         * If your device's CE pin is active high, use this to change the polarity.
         * *  Value | Pin
         *  ------|---------------------
         *    0   | SPI_CE0 (24 / GPIO8)
         *    1   | SPI_CE1 (26 / GPIO7)
         *    2   | Both
         * @param value The value correlating to pin(s) to control.
         * @param polarity Set the polarity it activates on. HIGH or LOW
         */
        rpioSPISetCSPolarity(value: 0 | 1 | 2, polarity: 'HIGH' | 'LOW'): Promise<void>;
        
        /**
         * Set the SPI clock speed.
         * @param rate It is an even divisor of the base 250MHz rate ranging between 0 and 65536.
         */
        rpioSPISetClockDivider(rate: number): Promise<void>;
        
        /**
         * Set the SPI Data Mode.
         *  Mode | CPOL | CPHA
         *  -----|------|-----
         *    0  |  0   |  0
         *    1  |  0   |  1
         *    2  |  1   |  0
         *    3  |  1   |  1
         * @param mode The SPI Data Mode.
         */
        rpioSPISetDataMode(mode: 0 | 1 | 2 | 3): Promise<void>;
        
        /**
         * 
         */
        rpioSPITransfer(tx: number[]): Promise<void>;
        
        /**
         * 
         */
        rpioSPIWrite(tx: number[]): Promise<void>;
        
        /**
         * Release the pins back to general purpose use.
         */
        rpioSPIEnd(): Promise<void>;
        
        /**
         * Establish the connection to the bluetooth serial device
         * @param name A friendly device name. Example: Brush01
         * @param device The device path. Example: /dev/rfcomm0
         * @param mac The device MAC address. Example: AA:BB:CC:DD:EE
         * @param channel The device channel. Example: 1
         * @param options 
         * {boolean} [autoOpen=true] Automatically opens the port on `nextTick`.
         * 
         * {number=} [baudRate=9600] The baud rate of the port to be opened. This should match one of the commonly available baud rates, such as 110, 300, 1200, 2400, 4800, 9600, 14400, 19200, 38400, 57600, or 115200. Custom rates are supported best effort per platform. The device connected to the serial port is not guaranteed to support the requested baud rate, even if the port itself supports that baud rate.
         * 
         * {number} [dataBits=8] Must be one of these: 8, 7, 6, or 5.
         * 
         * {number} [highWaterMark=65536] The size of the read and write buffers defaults to 64k.
         * 
         * {boolean} [lock=true] Prevent other processes from opening the port. Windows does not currently support `false`.
         * 
         * {number} [stopBits=1] Must be one of these: 1 or 2.
         * 
         * {string} [parity=none] Must be one of these: 'none', 'even', 'mark', 'odd', 'space'.
         * 
         * {boolean} [rtscts=false] flow control setting
         * 
         * {boolean} [xon=false] flow control setting
         * 
         * {boolean} [xoff=false] flow control setting
         * 
         * {boolean} [xany=false] flow control setting
         * 
         * {object=} bindingOptions sets binding-specific options
         * 
         * {Binding=} Binding The hardware access binding. `Bindings` are how Node-Serialport talks to the underlying system. Will default to the static property `Serialport.Binding`.
         * 
         * {number} [bindingOptions.vmin=1] see [`man termios`](http://linux.die.net/man/3/termios) LinuxBinding and DarwinBinding
         * 
         * {number} [bindingOptions.vtime=0] see [`man termios`](http://linux.die.net/man/3/termios) LinuxBinding and DarwinBinding
         */
        serialConnect(name: string, device: string, mac: string, channel: number, options?: object, cb?: any): Promise<void>;
        
        /**
         * Parses and returns the serial stream to the event tag 'onSerialData'.
         * @param bot The id of the bot you want data streamed to. The bot needs the 'onSerialData' tag.
         * @param name A friendly device name. Example: Brush01
         */
        serialStream(bot: string, name: string): Promise<void>;

        /**
         * Opens the serial connection if you set the option in serialConnect to {autoOpen: false}
         * @param name A friendly device name. Example: Brush01
         */
        serialOpen(name: string): Promise<void>;

        /**
         * Updates the SerialPort object with a new baudRate.
         * @param name A friendly device name. Example: Brush01
         * @param options {number=} [baudRate=9600] The baud rate of the port to be opened. This should match one of the commonly available baud rates, such as 110, 300, 1200, 2400, 4800, 9600, 14400, 19200, 38400, 57600, or 115200. Custom rates are supported best effort per platform. The device connected to the serial port is not guaranteed to support the requested baud rate, even if the port itself supports that baud rate.
         * @param cb
         */
        serialUpdate(name: string, options: object, cb?: any): Promise<void>;
        
        /**
         * Writes the provided data/command to the device
         * @param name A friendly device name. Example: Brush01
         * @param data The data/command to send
         * @param encoding The encoding, if chunk is a string. Defaults to 'utf8'. Also accepts 'utf16le', 'latin1', 'ascii', 'base64', 'binary', 'ucs2', and 'hex'
         * @param cb
         * @param taskId The ID of the async task.
         */
        serialWrite(name: string, data: string|number[], encoding?: string, cb?: any): Promise<void>;
        
        /**
         * Request a number of bytes from the SerialPort.
         * @param name A friendly device name. Example: Brush01
         * @param size Specify how many bytes of data to return, if available.
         * @param taskId The ID of the async task.
         */
        serialRead(name: string, size?: number): Promise<void>;
        
        /**
         * Closes an open connection. 
         * @param name A friendly device name. Example: Brush01
         * @param cb
         * @param device The device path. Example: /dev/rfcomm0
         * @param taskId The ID of the async task.
         */
        serialClose(name: string, device: string, cb?: any): Promise<void>;
        
        /**
         * Flush discards data that has been received but not read, or written but not transmitted by the operating system. 
         * @param name A friendly device name. Example: Brush01
         * @param taskId The ID of the async task.
         */
        serialFlush(name: string): Promise<void>;
        
        /**
         * Waits until all output data is transmitted to the serial port. After any pending write has completed, it calls `tcdrain()` or `FlushFileBuffers()` to ensure it has been written to the device. 
         * @param name A friendly device name. Example: Brush01
         * @param taskId The ID of the async task.
         */
        serialDrain(name: string): Promise<void>;
        
        /**
         * Causes a stream in flowing mode to stop emitting 'data' events, switching out of flowing mode. Any data that becomes available remains in the internal buffer.
         * @param name A friendly device name. Example: Brush01
         */
        serialPause(name: string): Promise<void>;
        
        /**
         * Causes an explicitly paused, Readable stream to resume emitting 'data' events, switching the stream into flowing mode.
         * @param name A friendly device name. Example: Brush01
         */
        serialResume(name: string): Promise<void>;
        
        /**
         * Executes the given shell script on the server.
         * @param script The shell script that should be executed.
         */
        shell(script: string): ShellAction;
    
        /**
         * Backs up all the AUX servers to a Github Gist.
         * @param auth The Github Personal Access Token that should be used to grant access to your Github account. See https://help.github.com/en/articles/creating-a-personal-access-token-for-the-command-line
         */
        backupToGithub(auth: string): BackupToGithubAction;
    
        /**
         * Backs up all the AUX servers to a zip bot.
         */
        backupAsDownload(target: SessionSelector): BackupAsDownloadAction;

        /**
         * Gets the number of devices that are viewing the current server.
         * @param server The server to get the statistics for. If omitted, then the current server is used.
         */
        serverRemoteCount(server?: string): Promise<number>;

        /**
         * Gets the total number of devices that are connected to the server.
         */
        totalRemoteCount(): Promise<number>;

        /**
         * Gets the list of servers that are on the server.
         */
        servers(): Promise<string[]>;

        /**
         * Gets the list of servers that are on the server.
         */
        serverStatuses(): Promise<{
            server: string,
            lastUpdateTime: Date
        }[]>;

        /**
         * Gets the list of remote IDs that are connected to the server.
         */
        remotes(): Promise<string[]>;
    
        /**
         * Loads a file from the server at the given path.
         * @param path The path of the file.
         * @param options The options.
         */
        loadFile(path: string, options?: LoadFileOptions): Promise<LoadFileResult>;
    
        /**
         * Saves a file on the server at the given path.
         * @param path The path of the file.
         * @param options The options.
         */
        saveFile(path: string, data: string, options?: SaveFileOptions): Promise<SaveFileResult>;
    
        /**
         * Finishes the checkout process by charging the payment fee to the user.
         *
         * @param options The options for finishing the checkout.
         *
         * @example
         * // Finish the checkout process
         * server.finishCheckout({
         *   secretKey: 'YOUR_SECRET_API_KEY',
         *   token: 'token from onCheckout',
         *
         *   // 1000 cents == $10.00
         *   amount: 1000,
         *   currency: 'usd',
         *   description: 'Description for purchase'
         * });
         */
        finishCheckout(options: FinishCheckoutOptions): FinishCheckoutOptions;
    
        /**
         * Saves the current state as a history mark.
         * @param options The options that describe what information the mark should contain.
         *
         * @example
         * // Bookmark the current state with a message
         * server.markHistory({
         *   message: "Save recent changes"
         * });
         */
        markHistory(options: MarkHistoryOptions): MarkHistoryAction;
    
        /**
         * Loads the "history" space into the server.
         */
        browseHistory(): Promise<void>;
    
        /**
         * Restores the current state to the given mark.
         * @param mark The bot or bot ID that represents the mark that should be restored.
         */
        restoreHistoryMark(mark: Bot | string): Promise<void>;
    
        /**
         * Restores the current state to the given mark.
         * @param mark The bot or bot ID that represents the mark that should be restored.
         * @param server The server that the mark should be restored to.
         */
        restoreHistoryMarkToServer(
            mark: Bot | string,
            server: string
        ): Promise<void>;
    };

    /**
     * Defines a set of functions that handle actions.
     */
    const action: {
        /**
         * Performs the given action.
         * @param action The action to perform.
         */
        perform(action: any): BotAction;
    
        /**
         * Rejects the given action.
         * @param action The action to reject.
         */
        reject(action: any): BotAction;
    };

    /**
     * Defines a set of functions that manage admin space.
     */
    const adminSpace: {
        /**
         * Unlocks admin space using the given password.
         * Returns a promise that resolves when the space is unlocked.
         * @param password The password to use to unlock admin space.
         */
        unlock(): Promise<void>;

        /**
         * Sets the password that should be used for admin space.
         * @param oldPassword The old password for the admin space.
         * @param newPassword The new password that should be used.
         */
        setPassword(oldPassword: string, newPassword: string): Promise<void>;
    };

    /**
     * Defines a set of functions that relate to common math operations.
     */
    const math: {
        /**
         * Sums the given array of numbers and returns the result.
         * If any value in the list is not a number, it will be converted to one.
         * If the given value is not an array, then it will be converted to a number and returned.
         *
         * @param list The value that should be summed. If it is a list, then the result will be the sum of the items in the list.
         *             If it is not a list, then the result will be the value converted to a number.
         */
        sum(list: any): number;

        /**
         * Calculates the average of the numbers in the given list and returns the result.
         * @param list The value that should be averaged.
         *             If it is a list, then the result will be sum(list)/list.length.
         *             If it is not a list, then the result will be the value converted to a number.
         */
        avg(list: any): number;

        /**
         * Calculates the square root of the given number.
         * @param value The number.
         */
        sqrt(value: any): number;

        /**
         * Calculates the absolute value of a number.
         * @param number The number to get the absolute value of.
         */
        abs(number: any): number;

        /**
         * Calculates the standard deviation of the numbers in the given list and returns the result.
         *
         * @param list The value that the standard deviation should be calculated for.
         */
        stdDev(list: any): number;

        /**
         * Generates a random integer number between min and max.
         * @param min The smallest allowed value.
         * @param max The largest allowed value.
         */
        randomInt(min?: number, max?: number): number;

        /**
         * Generates a random number between min and max.
         * @param min The smallest allowed value.
         * @param max The largest allowed value.
         */
        random(min?: number, max?: number): number;

        /**
         * Gets the forward direction for the given rotation.
         * @param pointerRotation The rotation that the pointer has represented in radians.
         */
        getForwardDirection(pointerRotation: Point3D): Point3D;

        /**
         * Finds the point at which the the given ray and ground plane intersect.
         * Returns null if the ray does not intersect the ground plane.
         * @param origin The origin of the ray.
         * @param direction The direction that the ray is pointing.
         */
        intersectPlane(origin: Point3D, direction: Point3D): Point3D;

        /**
         * Gets the position offset for the given bot anchor point.
         * This is useful for doing custom math using anchor points.
         * @param anchorPoint The anchor point to get the offset for.
         */
        getAnchorPointOffset(anchorPoint: BotAnchorPoint): Point3D;

        /**
         * Adds the given vectors together and returns the result.
         * @param vectors The vectors that should be added together.
         */
        addVectors<T>(...vectors: T[]): T;

        /**
         * Subtracts the given vectors from each other and returns the result.
         * @param vectors The vectors that should be subtracted from each other.
         */
        subtractVectors<T>(...vectors: T[]): T;

        /**
         * Negates the given vector and returns the result.
         * @param vector The vector that should be negated.
         */
        negateVector<T>(vector: T): T;

        /**
         * Normalizes the given vector and returns the result.
         * @param vector The vector that should be normalized.
         */
        normalizeVector<T>(vector: T): T;

        /**
         * Calculates the length of the given vector.
         * @param vector The vector to calculate the length of.
         */
        vectorLength<T>(vector: T): number;

        /**
         * Multiplies each component of the given vector by the given scale and returns the result.
         * @param vector The vector that should be scaled.
         * @param scale The number that the vector should be multiplied by.
         */
        scaleVector<T>(vector: T, scale: number): T;
    };

    /**
     * Defines a set of functions that are used to create and transform mods.
     */
    const mod: {
        /**
         * Converts the given 3D point into a mod that sets the cameraPositionOffset tags.
         * @param point The mod that represents the 3D point.
         */
        cameraPositionOffset(point: Partial<Point3D>): {
            cameraPositionOffsetX: number,
            cameraPositionOffsetY: number,
            cameraPositionOffsetZ: number,
        };

        /**
         * Converts the given 3D rotation into a mod that sets the cameraRotationOffset tags.
         * @param rotation The mod that represents the 3D rotation.
         */
        cameraRotationOffset(rotation: Partial<Point3D>): {
            cameraRotationOffsetX: number,
            cameraRotationOffsetY: number,
            cameraRotationOffsetZ: number,
        };
    };

    // @ts-ignore: Ignore redeclaration
    const crypto: {
        /**
         * Calculates the SHA-256 hash of the given data.
         * Returns the hexadecimal string of the hash.
         * @param data The data that should be hashed.
         */
        sha256(...data: unknown[]): string;

        /**
         * Calculates the SHA-512 hash of the given data.
         * Returns the hexadecimal string of the hash.
         * @param data The data that should be hashed.
         */
        sha512(...data: unknown[]): string;

        /**
         * Calculates the HMAC SHA-256 hash of the given data.
         * HMAC is commonly used to verify that a message was created with a specific key.
         * Returns the hexadecimal string of the hash.
         * @param key The key that should be used to sign the message.
         * @param data The data that should be hashed.
         */
        hmacSha256(key: string, ...data: unknown[]): string;

        /**
         * Calculates the HMAC SHA-512 hash of the given data.
         * HMAC is commonly used to verify that a message was created with a specific key.
         * Returns the hexadecimal string of the hash.
         * @param key The key that should be used to sign the message.
         * @param data The data that should be hashed.
         */
        hmacSha512(key: string, ...data: unknown[]): string;

        /**
         * Encrypts the given data with the given secret and returns the result.
         * 
         * @description Always choose a strong unique secret. Use a password manager such as LastPass or 1Password to
         * help you create and keep track of them.
         * 
         * Assuming the above, this method will return a string of encrypted data that is confidential (unreadable without the secret),
         * reliable (the encrypted data cannot be changed without making it unreadable), and authentic (decryptability proves that the secret was used to encrypt the data).
         * 
         * As a consequence, encrypting the same data with the same secret will produce different results.
         * This is to ensure that an attacker cannot correlate different pieces of data to potentially deduce the original plaintext.
         * 
         * Encrypts the given data using an authenticated encryption mechanism 
         * based on XSalsa20 (An encryption cipher) and Poly1305 (A message authentication code).
         * 
         * @param secret The secret to use to secure the data.
         * @param data The data to encrypt.
         */
        encrypt(secret: string, data: string): string;

        /**
         * Decrypts the given data using the given secret and returns the result.
         * If the data was unable to be decrypted, null will be returned.
         *
         * @param secret The secret to use to decrypt the data.
         * @param data The data to decrypt.
         */
        decrypt(secret: string, data: string): string;

        /**
         * Determines if the given value has been encrypted with symmetric encryption.
         * @param cyphertext The value to test to see if it is encrypted.
         */
         isEncrypted(cyphertext: string): boolean;

        /**
         * Contains functions useful for asymmetric encryption.
         */
        asymmetric: {
            /**
             * Creates a new keypair that can be used for encrypting and decrypting data.
             *
             * @description Always choose a strong unique secret. Use a password manager such as LastPass or 1Password to
             * help you create and keep track of them.
             * 
             * Keypairs are made up of a private key and a public key.
             * The public key is a special value that can be used to encrypt data and 
             * the private key is a related value that can be used to decrypt data that was encrypted by the public key.
             *
             * The private key is called "private" because it is encrypted using the given secret
             * while the public key is called "public" because it is not encrypted so anyone can use it if they have access to it.
             *
             * Note that both the private and public keys are randomly generated, so while the public key is unencrypted, it won't be able to be used by someone else unless
             * they have access to it.
             *
             * @param secret The secret that should be used to encrypt the private key.
             */
            keypair(secret: string): string;

            /**
             * Determines if the given value is a keypair that can be used to encrypt and decrypt data using
             * asymmetric encryption.
             * @param keypair The value to test to see if it is a keypair that can be used for asymmetric encryption.
             */
             isKeypair(keypair: string): boolean;

            /**
             * Encrypts the given data with the given keypair and returns the result.
             *
             * @description This method will return a string of encrypted data that is confidential (unreadable without the keypair and secret used to encrypt it),
             * reliable (the encrypted data cannot be changed without making it unreadable), and authentic (decryptability proves that the keypair was used to encrypt the data).
             *
             * As a consequence, encrypting the same data with the same keypair will produce different results.
             * This is to ensure that an attacker cannot correlate different pieces of data to potentially deduce the original plaintext.
             *
             * Encrypts the given data using an asymmetric authenticated encryption mechanism
             * based on x25519 (A key-exchange mechanism), XSalsa20 (An encryption cipher) and Poly1305 (A message authentication code).
             * 
             * You may notice that this function does not need a secret to decrypt the keypair.
             * This is because the public key of the keypair is used to encrypt the data.
             * Due to how asymmetric encryption works, only the encrypted private key will be able to decrypt the data.
             *
             * @param keypair The keypair to use to secure the data.
             * @param data The data to encrypt.
             */
            encrypt(keypair: string, data: string): string;

            /**
             * Decrypts the given data with the given keypair and secret and returns the result.
             * If the data was unable to be decrypted, null will be returned.
             *
             * @param keypair The keypair to use to decrypt the data.
             * @param secret The secret to use to decrypt the keypair's private key.
             * @param data The data to decrypt.
             */
            decrypt(keypair: string, secret: string, data: string): string;

            /**
             * Determines if the given value is encrypted using asymmetric encryption.
             * @param cyphertext The value to test to see if it is encrypted.
             */
             isEncrypted(cyphertext: string): boolean;
        };

        /**
         * Creates a new keypair that can be used for signing and verifying data.
         *
         * @description
         * Keypairs are made up of a private key and a public key.
         * The private key is a special value that can be used to create digital signatures and
         * the public key is a related value that can be used to verify that a digitital signature was created by the private key.
         *
         * The private key is called "private" because it is encrypted using the given secret
         * while the public key is called "public" because it is not encrypted so anyone can use it if they have access to it.
         *
         * Note that both the private and public keys are randomly generated, so while the public is unencrypted, it won't be able to be used by someone else unless
         * they have access to it.
         *
         * @param secret The secret that should be used to encrypt the private key.
         */
        keypair(secret: string): string;

        /**
         * Creates a digital signature for the given data using the private key from the given keypair.
         *
         * @description
         * Digital signatures are used to verifying the authenticity and integrity of data.
         *
         * This works by leveraging asymetric encryption but in reverse.
         * 
         * If we can encrypt some data such that only the public key of a keypair can decrypt it, then we can prove that
         * the data was encrypted (i.e. signed) by the corresponding private key.
         * 
         * And since the public key is available to everyone but the private
         * key is only usable when you have the secret, we can use this to prove that a particular piece of data was signed by whoever knows the secret.
         *
         * @param keypair The keypair that should be used to create the signature.
         * @param secret The secret that was used when creating the keypair. Used to decrypt the private key.
         * @param data The data to sign.
         */
        sign(keypair: string, secret: string, data: string): string;

        /**
         * Validates that the given signature for the given data was created by the given keypair.
         * @param keypair The keypair that should be used to validate the signature.
         * @param signature The signature that was returned by the sign() operation.
         * @param data The data that was used in the sign() operation.
         */
        verify(keypair: string, signature: string, data: string): boolean;

        /**
         * Creates a new certified bot that is signed using the given certified bot.
         * @param certificate The certified bot that the new certificate should be signed with. 
         *                    This is commonly known as the signing certificate.
         *                    If given null, then the new certificate will be self-signed.
         * @param secret The signing certificate's secret. This is the secret that was used to create
         *                 the keypair for the signing certificate. If the new certificate will be self-signed, then this
         *                 is the secret that was used to create the given keypair.
         * @param keypair The keypair that the new certificate should use.
         */
        createCertificate(certificate: Bot | string, secret: string, keypair: string): Promise<Bot>;

        /**
         * Signs the tag on the given bot using the given certificate and secret.
         * @param certificate The certificate to use to create the signature.
         * @param secret The secret to use to decrypt the certificate's private key.
         * @param bot The bot that should be signed.
         * @param tag The tag that should be signed.
         */
        signTag(certificate: Bot | string, secret: string, bot: Bot | string, tag: string): Promise<void>;

        /**
         * Verifies that the given tag on the given bot has been signed by a certificate.
         * @param bot The bot.
         * @param tag The tag to check.
         */
        verifyTag(bot: Bot | string, tag: string): boolean;

        /**
         * Revokes the given certificate using the given secret.
         * In effect, this deletes the certificate bot from the server.
         * Additionally, any tags signed with the given certificate will no longer be verified.
         * 
         * If given a signer, then the specified certificate will be used to sign the revocation.
         * This lets you use a parent or grandparent certificate to remove the child.
         * 
         * If no signer is given, then the certificate will be used to revoke itself.
         * 
         * @param certificate The certificate that should be revoked.
         * @param secret The secret that should be used to decrypt the corresponding certificate's private key.
         *                 If given a signer, then this is the secret for the signer certificate. If no signer is given,
         *                 then this is the secret for the revoked certificate.
         * @param signer The certificate that should be used to revoke the aforementioned certificate. If not specified then the revocation will be self-signed.
         */
        revokeCertificate(certificate: Bot | string, secret: string, signer?: Bot | string): Promise<void>;
    };

    /**
     * Defines a set of experimental functions.
     */
    const experiment: {
        /**
         * Plays the given animation on the given bot locally.
         * Reverts back to the original animation when done playing.
         * @param bot The bot.
         * @param animation The animation to play.
         */
        localFormAnimation(
            bot: Bot | string,
            animation: string | number
        ): LocalFormAnimationAction;

        /**
         * Tweens the position of the given bot.
         * @param bot The bot or bot ID to tween.
         * @param dimension The dimension that the bot should be tweened in.
         * @param position The position that the bot should be tweened to.
         * @param options The options that should be used for the tween.
         */
        localPositionTween(
            bot: Bot | string,
            dimension: string,
            position: { x?: number, y?: number, z?: number },
            options?: TweenOptions
        ): LocalPositionTweenAction;

        /**
         * Tweens the rotation of the given bot.
         * @param bot The bot or bot ID to tween.
         * @param dimension The dimension that the bot should be tweened in.
         * @param rotation The rotation that the bot should be tweened to.
         * @param options The options that should be used for the tween.
         */
        localRotationTween(
            bot: Bot | string,
            dimension: string,
            rotation: { x?: number, y?: number, z?: number },
            options?: TweenOptions
        ): LocalRotationTweenAction;

        /**
         * Gets the position that the center of the given bot would placed at if the bot was using the given anchor point.
         * @param bot The bot.
         * @param dimension The dimension to get the position of.
         * @param anchorPoint The anchor point.
         */
        getAnchorPointPosition(
            bot: Bot,
            dimension: string,
            anchorPoint: BotAnchorPoint
        ): {x: number, y: number, z: number};

        /**
         * Starts a new audio recording.
         */
        beginAudioRecording(): Promise<void>;

        /**
         * Finishes an audio recording.
         * Returns a promise that resolves with the recorded blob.
         */
        endAudioRecording(): Promise<Blob>;

        /**
         * Starts a new recording.
         * @param options The options for the recording.
         * @returns A promise that resolves when the recording has started.
         */
        beginRecording(options?: RecordingOptions): Promise<void>;

        /**
         * Finishes a recording.
         * Returns a promise that resolves with the recorded data.
         */
        endRecording(): Promise<Recording>;

        /**
         * Speaks the given text.
         * Returns a promise that resolves when the text has been spoken.
         * @param text The text that should be spoken.
         * @param options The options that should be used.
         */
        speakText(text: string, options?: { rate?: number, pitch?: number, voice?: string | SyntheticVoice }): Promise<void>;

        /**
         * Gets the list of synthetic voices that are supported by the system.
         * Returns a promise that resolves with the voices.
         */
        getVoices(): Promise<SyntheticVoice[]>;
    };

    /**
     * Defines a set of performance related functions.
     */
    const perf: {
        /**
         * Gets the performance stats for the server.
         */
        getStats(): PerformanceStats;
    };
}