/* CasualOS is a set of web-based tools designed to facilitate the creation of real-time, multi-user, context-aware interactive experiences.
 *
 * Copyright (c) 2019-2025 Casual Simulation, Inc.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */
import {
    hashLowEntropyPasswordWithSalt as cryptoHashPasswordWithSalt,
    hashHighEntropyPasswordWithSalt as cryptoHashHighEntropyPasswordWithSalt,
    verifyPasswordAgainstHashes as cryptoVerifyPasswordAgainstHashes,
} from '@casual-simulation/crypto/HashHelpers';
import { trace } from '@opentelemetry/api';

declare const GIT_TAG: string;

/**
 * Hashes the given password using the given salt and returns the resulting base64 encoded hash.
 * Should only be used for low-entropy passwords like 5-digit codes or passwords that were generated by a user themselves.
 * For high-entropy passwords, use hashHighEntropyPasswordWithSalt().
 *
 * Returns a V1 hash that indicates that scrypt was used for the hashing process.
 * @param password The password to hash.
 * @param salt The salt to use for the password. Must be a base64 encoded string.
 */
export function hashLowEntropyPasswordWithSalt(
    password: string,
    salt: string
): string {
    const tracer = trace.getTracer(
        'InstrumentedHashHelpers',
        typeof GIT_TAG === 'undefined' ? undefined : GIT_TAG
    );

    return tracer.startActiveSpan(
        'hashLowEntropyPasswordWithSalt',
        {
            attributes: {
                'password.length': password.length,
                'salt.length': salt.length,
            },
        },
        () => {
            return cryptoHashPasswordWithSalt(password, salt);
        }
    );
}

/**
 * Hashes the given password with the given salt using HMAC-SHA-256 and returns the resulting base64 encoded hash.
 * This function is designed for high-entropy passwords (at least 128 bits of unguessable information) and is not designed
 * for regular passwords. Use hashLowEntropyPasswordWithSalt() for regular low-entropy passwords.
 *
 * Returns a V2 hash that indicates that HMAC-SHA-256 was used for the hashing process.
 * @param password The password that should be hashed.
 * @param salt The salt to use for the password. Must be a base64 encoded string.
 */
export function hashHighEntropyPasswordWithSalt(
    password: string,
    salt: string
): string {
    const tracer = trace.getTracer(
        'InstrumentedHashHelpers',
        typeof GIT_TAG === 'undefined' ? undefined : GIT_TAG
    );

    return tracer.startActiveSpan(
        'hashHighEntropyPasswordWithSalt',
        {
            attributes: {
                'password.length': password.length,
                'salt.length': salt.length,
            },
        },
        () => {
            return cryptoHashHighEntropyPasswordWithSalt(password, salt);
        }
    );
}

/**
 * Validates that the given password and salt match at least one of the given hashes.
 * @param password The password to check.
 * @param salt The base64 encoded salt to use for the password.
 * @param hashes The hashes that they should match. These hashes should have been produced by hashLowEntropyPasswordWithSalt().
 */
export function verifyPasswordAgainstHashes(
    password: string,
    salt: string,
    hashes: string[]
): boolean {
    const tracer = trace.getTracer(
        'InstrumentedHashHelpers',
        typeof GIT_TAG === 'undefined' ? undefined : GIT_TAG
    );

    return tracer.startActiveSpan(
        'verifyPasswordAgainstHashes',
        {
            attributes: {
                'password.length': password.length,
                'salt.length': salt.length,
                'hashes.length': hashes.length,
            },
        },
        () => {
            return cryptoVerifyPasswordAgainstHashes(password, salt, hashes);
        }
    );
}
