{"version":1,"state":{"4db69ebb-66ca-4bcb-9a3a-815e35ce3c78":{"id":"4db69ebb-66ca-4bcb-9a3a-815e35ce3c78","space":"shared","tags":{"creator":"eeedaa12-9220-479b-a479-8cb57e1d8ae5","system":"ab1.tests.manager","runTestCase":"@const testCase = getBot('id', that);\r\nif (!testCase) {\r\n    console.log('Test case not found!');\r\n    return;\r\n}\r\n\r\nif (testCase.tags.system) {\r\n    destroy(getBots(\r\n        byTag('__testResult', true)\r\n    ));\r\n}\r\n\r\nconst d = await os.createDebugger({\r\n    pausable: true,\r\n    allowAsynchronousScripts: true\r\n});\r\n\r\nif (typeof testCase.tags.randomSeed === 'number' || typeof testCase.tags.randomSeed === 'string') {\r\n    d.math.setRandomSeed(testCase.tags.randomSeed);\r\n}\r\nconst timeline = [];\r\nawait bot.hookupDebugger({ debug: d, timeline });\r\nawait bot.addBotsToDebugger(d);\r\n\r\nlet actionsToPerform = [];\r\nlet asyncResults = {}; \r\n\r\nfor (let event of testCase.tags.timeline) {\r\n    preprocessEvent(event);\r\n}\r\n\r\nfunction preprocessEvent(event) {\r\n    if (event.type === 'user_action') {\r\n        if ('timeline' in event) {\r\n            for (let e of event.timeline) {\r\n                preprocessEvent(e);\r\n            }\r\n        } else {\r\n            let action = event.action;\r\n            if (action.type === 'action' && 'keys' in action) {\r\n                let botIds = action.keys.map(k => {\r\n                    return d.getID(d.getBot(\r\n                        either(\r\n                            byTag('system', k),\r\n                            byTag('__key', k))\r\n                    ));\r\n                });\r\n\r\n                action = {\r\n                    ...action,\r\n                    botIds,\r\n                };\r\n                delete action.keys;\r\n                actionsToPerform.push(action);\r\n            } else if (action.type === 'async_result') {\r\n                asyncResults[action.taskId] = action;\r\n            }\r\n        }\r\n    } else if (event.type === 'script') {\r\n        for (let e of event.timeline) {\r\n            preprocessEvent(e);\r\n        }\r\n    }\r\n}\r\n\r\nlet resolve;\r\nlet reject;\r\nlet promise = new Promise((res, rej) => {\r\n    resolve = res;\r\n    reject = rej;\r\n})\r\n\r\nconst expectedTimeline = testCase.tags.timeline.slice();\r\n\r\nd.onScriptActionEnqueued(a => {\r\n    if (a.type !== 'async_result' && 'taskId' in a) {\r\n        // async task was enqueued\r\n        // send async result\r\n        let result = asyncResults[a.taskId];\r\n        if (result) {\r\n            d.performUserAction(result);\r\n        }\r\n    }\r\n});\r\n\r\nfor (let a of actionsToPerform) {\r\n    console.log('perform', a);\r\n    await d.performUserAction(a);\r\n}\r\n\r\nfor (let i = 0; i < 50; i++) {\r\n    await Promise.resolve();\r\n}\r\n\r\nconst resultTimeline = bot.compileTimeline({ timeline: timeline });\r\n\r\nconsole.log('Result', resultTimeline);\r\n\r\nlet renderedResult = thisBot.renderTimeline({ timeline: resultTimeline, name: testCase.tags.testName });\r\nlet expectedResult = thisBot.renderTimeline({ timeline: expectedTimeline, name: testCase.tags.testName });\r\n\r\nif (renderedResult.string === expectedResult.string) {\r\n    return {\r\n        success: true\r\n    };\r\n    // os.toast('Sucess!');\r\n} else {\r\n    const system = 'test-failures.' + testCase.tags.testName;\r\n    let { resultBot } = thisBot.createBotsForRenderedTimeline({\r\n        system,\r\n        result: renderedResult,\r\n        creator: testCase,\r\n        systemTag: 'testSystem'\r\n    });\r\n\r\n    let { resultBot: expectedBot } = thisBot.createBotsForRenderedTimeline({\r\n        system,\r\n        result: expectedResult,\r\n        testCase,\r\n        systemTag: 'system'\r\n    });\r\n\r\n    return {\r\n        success: false,\r\n        system: system,\r\n        diffBotId: expectedBot.id,\r\n    };\r\n}","hookupDebugger":"@const { debug: d, addKeys, timeline, noWarnMissingKeys } = that;\r\nconst botTimeline = timeline ?? [];\r\n\r\nconst actionTimelines = {};\r\nconst scriptTimelines = {};\r\n\r\nlet emittedActions = [];\r\nconst asyncRequests = new Map();\r\nlet asyncTimeline = null;\r\nlet syncCounter = 0;\r\n\r\nlet botKeys = {};\r\n\r\nfunction shouldSkipAction(a) {\r\n    const c = d.configBot;\r\n    if (!c) {\r\n        return true;\r\n    }\r\n    if (a.type !== 'action') {\r\n        if (a.type === 'update_bot') {\r\n            return true;\r\n        } else if (a.type === 'add_bot') {\r\n            return true;\r\n        } else if (a.type === 'remove_bot') {\r\n            return true;\r\n        } else if (a.type === 'async_result') {\r\n            return false;\r\n        } else if (a.type === 'async_error') {\r\n            return false;\r\n        } else if (a.type === 'apply_state') {\r\n            return true;\r\n        } else if (a.type === 'register_builtin_portal') {\r\n            return true;\r\n        } else if(a.type === 'custom_app_container_available') {\r\n            return true;\r\n        } else if (a.type === 'register_html_app' && a.appId === '_root') {\r\n            return true;\r\n        } else if (a.type === 'define_global_bot') {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nfunction shouldSkipUpdateForBot(update) {\r\n    const b = getBot(byID(update.botId));\r\n    return (\r\n        b && (\r\n            byTag('ab1')(b) || byTag('ab1ID')(b)\r\n        )\r\n    );\r\n}\r\n\r\nd.onBeforeUserAction(a => {\r\n    if (shouldSkipAction(a)) {\r\n        return;\r\n    }\r\n    console.log('user action', a);\r\n\r\n    if (a.type === 'action') {\r\n        asyncTimeline = null;\r\n        syncCounter += 1;\r\n        addBotAction(a);\r\n    } else {\r\n        if (a.type === 'async_result') {\r\n            // the timeline that started the async request.\r\n            asyncTimeline = asyncRequests.get(a.taskId);\r\n            if (!asyncTimeline) {\r\n                console.log('async', asyncRequests, a);\r\n                throw new Error(`Async timeline not found for task! (taskId: ${a.taskId})`);\r\n            }\r\n            asyncTimeline.push({\r\n                type: 'user_action',\r\n                action: a,\r\n            });\r\n        } else {\r\n            botTimeline.push({\r\n                type: 'user_action',\r\n                action: a,\r\n            });\r\n        }\r\n    }\r\n});\r\n\r\nd.onScriptActionEnqueued(a => {\r\n    console.log('emit action', a);\r\n    console.log('call stack', d.getCallStack());\r\n    let timeline = getCurrentScriptTimeline();\r\n\r\n    if (timeline) {\r\n        timeline.push({\r\n            type: 'emitted_action',\r\n            action: a,\r\n            location: getCurrentScriptLocation() \r\n        });\r\n    }\r\n\r\n    if ('taskId' in a) {\r\n        if (!timeline) {\r\n            debugger;\r\n            throw new Error('The timeline for the script action could not be found!');\r\n        }\r\n        asyncRequests.set(a.taskId, timeline);\r\n    }\r\n});\r\n\r\nd.onAfterScriptUpdatedTag(update => {\r\n    if (shouldSkipUpdateForBot(update)) {\r\n        return;\r\n    }\r\n\r\n    console.log('update tag', update);\r\n    console.log('call stack', d.getCallStack());\r\n    let timeline = getCurrentScriptTimeline();\r\n\r\n    if (timeline) {\r\n        let { botId, ...rest } = update;\r\n\r\n        timeline.push({\r\n            type: 'update_tag',\r\n            update: {\r\n                ...rest,\r\n                botId: getBotKey(botId) ?? botId\r\n            },\r\n            location: getCurrentScriptLocation()\r\n        });\r\n    }\r\n});\r\n\r\nd.onAfterScriptUpdatedTagMask(update => {\r\n    if (shouldSkipUpdateForBot(update)) {\r\n        return;\r\n    }\r\n\r\n    console.log('update tag mask', update);\r\n    console.log('call stack', d.getCallStack());\r\n    let timeline = getCurrentScriptTimeline();\r\n\r\n    if (timeline) {\r\n        let { botId, ...rest } = update;\r\n\r\n        timeline.push({\r\n            type: 'update_tag_mask',\r\n            update: {\r\n                ...rest,\r\n                botId: getBotKey(botId) ?? botId\r\n            },\r\n            location: getCurrentScriptLocation()\r\n        });\r\n    }\r\n});\r\n\r\nfunction getCurrentScriptTimeline() {\r\n    if (!asyncTimeline) {\r\n        let currentScript = getCurrentScript();\r\n        if (currentScript) {\r\n            return getScriptTimeline(currentScript.botId, currentScript.tag, syncCounter);\r\n        }\r\n        return null;\r\n    } else {\r\n        return asyncTimeline;\r\n    }\r\n}\r\n\r\nfunction getScriptTimeline(botId, tag, syncCounter) {\r\n    const key = `${botId}.${tag}:${syncCounter}`;\r\n    let timeline = scriptTimelines[key];\r\n    if (!timeline) {\r\n        scriptTimelines[key] = timeline = [];\r\n        let actionTimeline = actionTimelines[syncCounter];\r\n\r\n        if (actionTimeline) {\r\n            const originalBotId = getOriginalBotId(botId);\r\n            actionTimeline.push({\r\n                type: 'script',\r\n                botId: getBotKey(botId),\r\n                tag: tag,\r\n                count: syncCounter,\r\n                timeline,\r\n                location: {\r\n                    botId: originalBotId,\r\n                    tag,\r\n                    line: 0,\r\n                    column: 0\r\n                }\r\n            });\r\n        }\r\n    }\r\n    return timeline;\r\n}\r\n\r\nfunction getCurrentScript() {\r\n    const callStack = d.getCallStack();\r\n    for (let i = 0; i < callStack.length; i++) {\r\n        let frame = callStack[i];\r\n        if (frame.location?.botId && frame.location?.tag) {\r\n            return {\r\n                botId: frame.location.botId,\r\n                tag: frame.location.tag\r\n            }\r\n        }\r\n    };\r\n\r\n    return null;\r\n}\r\n\r\nfunction getCurrentScriptLocation() {\r\n    const callStack = d.getCallStack();\r\n    for (let i = callStack.length - 1; i >= 0; i--) {\r\n        let frame = callStack[i];\r\n        if (frame.location?.botId && frame.location?.tag) {\r\n            const botId = getOriginalBotId(frame.location.botId);\r\n            return {\r\n                botId: botId,\r\n                tag: frame.location.tag,\r\n                line: frame.location.lineNumber,\r\n                column: frame.location.columnNumber\r\n            };\r\n        }\r\n    };\r\n\r\n    return null;\r\n}\r\n\r\nasync function addBotAction(a) {\r\n    let action;\r\n    if (a.botIds) {\r\n        let keys = [];\r\n        for (let botId of a.botIds) {\r\n            const key = getBotKey(botId);\r\n            if (!key) {\r\n                continue;\r\n            }\r\n\r\n            keys.push(key);\r\n        }\r\n\r\n        action = {\r\n            ...a,\r\n            keys\r\n        };\r\n        delete action.botIds;\r\n    } else {\r\n        action = a;\r\n    }\r\n\r\n    const timeline = actionTimelines[syncCounter] = [\r\n        {\r\n            type: 'user_action',\r\n            action: action,\r\n        }\r\n    ];\r\n    botTimeline.push({\r\n        type: 'user_action',\r\n        timeline: timeline\r\n    });\r\n}\r\n\r\nfunction getOriginalBotId(botId) {\r\n    let bot = d.getBot('id', botId);\r\n    if (!bot || !bot.tags.__originalBotId) {\r\n        return null;\r\n    }\r\n    let originalBot = getBot('id', bot.tags.__originalBotId);\r\n    if (!originalBot) {\r\n        return null;\r\n    }\r\n\r\n    return originalBot.id;\r\n}\r\n\r\nfunction getBotKey(botId) {\r\n    let bot = d.getBot('id', botId);\r\n    if (!bot || !bot.tags.__originalBotId) {\r\n        return null;\r\n    }\r\n    let originalBot = getBot('id', bot.tags.__originalBotId);\r\n    if (!originalBot) {\r\n        return null;\r\n    }\r\n    let key = bot.tags.__key ?? bot.tags.system ?? botKeys[botId];\r\n    if (!key) {\r\n        if (addKeys) {\r\n            key = botKeys[botId] = originalBot.tags.__key = uuid();\r\n        } else if (noWarnMissingKeys) {\r\n            key = originalBot.id;\r\n        } else {\r\n            console.warn(`No key could be determined for ${botId}! Set the system tag or the __key tag to enable consistent tests.`);\r\n            os.toast(`No key could be determined for ${botId}! Set the system tag or the __key tag to enable consistent tests.`);\r\n        }\r\n    }\r\n    return key;\r\n}","compileTimeline":"@let finalTimeline = [];\r\nlet hasUserAction = false;\r\nlet timeline = that.timeline;\r\n\r\nfor(let i = 0; i < timeline.length; i++) {\r\n    const event = timeline[i];\r\n\r\n    if (event.type === 'user_action') {\r\n        hasUserAction = true;\r\n\r\n        if ('timeline' in event) {\r\n            if (event.timeline.length <= 1) {\r\n                continue;\r\n            }\r\n        }\r\n    } else if (!hasUserAction) {\r\n        continue;\r\n    }\r\n\r\n    finalTimeline.push(event);\r\n}\r\n\r\nconsole.log('[debug] Timeline', timeline.slice());\r\nconsole.log('[debug] Final Timeline', finalTimeline);\r\nreturn finalTimeline;","addBotsToDebugger":"@const d = that;\r\nconst testableBots = getBots(\r\n    not(byTag('__test')),\r\n    not(byTag('ab1')),\r\n    not(byTag('ab1ID')),\r\n    not(byID(getID(thisBot))),\r\n    not(byTag('ab1TestTools')),\r\n    not(bySpace('bootstrap'))\r\n);\r\n\r\nif (testableBots.length <= 0) {\r\n    throw new Error('Unable to create test with no bots!');\r\n}\r\nfor (let b of testableBots) {\r\n    if (b.id === gridPortalBot.id || \r\n        b.id === configBot.id ||\r\n        b.id === miniGridPortalBot.id ||\r\n        b.id === mapPortalBot.id ||\r\n        b.id === systemPortalBot.id ||\r\n        b.id === sheetPortalBot.id ||\r\n        b.id === tagPortalBot.id ||\r\n        b.id === menuPortalBot.id ||\r\n        b.id === idePortalBot.id ||\r\n        b.id === meetPortalBot.id ||\r\n        b.id === botPortalBot.id ||\r\n        b.id === miniMapPortalBot.id ||\r\n        b.id === leftWristPortalBot.id ||\r\n        b.id === rightWristPortalBot.id) {\r\n        continue;\r\n    }\r\n\r\n    let tags = Object.keys(b.tags);\r\n\r\n    if (tags.length <= 0) {\r\n        console.log('no tags!', b);\r\n        continue;\r\n    }\r\n    await d.create(b, {\r\n        __originalBotId: b.id\r\n    });\r\n}","ab1ID":"tests-manager","ab1":true,"ab1Y":3,"ab1Z":0,"scaleZ":"1.6","scaleX":"0.8","scaleY":"0.8","color":"#f1ff3a","strokeColor":"orange","ab1InitialLoad":"true","onPortalChanged":"@if (that.portal === 'systemPortal') {\r\n    if (!configBot.tags.codeToolsPortal) {\r\n        configBot.masks.codeToolsPortal = 'ab1TestTools';\r\n\r\n        destroy(getBots(\r\n            byTag('ab1TestTools', true),\r\n            bySpace('tempLocal')\r\n        ));\r\n\r\n        const runTestsButton = create({\r\n            space: 'tempLocal',\r\n            ab1TestTools: true,\r\n            label: 'Run Tests',\r\n            onClick: `@shout(\"ab1RunTests\")`,\r\n        });\r\n\r\n        thisBot.masks.runTestsButton = runTestsButton.link;\r\n    }\r\n}","ab1RecordTest":"@const testName = await os.showInput('', {\r\n    title: 'Enter test name'\r\n});\r\n\r\nif (!testName) {\r\n    os.toast(\"You must provide a test name in order to record a test.\");\r\n    return;\r\n}\r\n\r\nconst d = await os.createDebugger({\r\n    pausable: true,\r\n    allowAsynchronousScripts: true\r\n});\r\n\r\nconst seed = math.randomInt(-2147483648, 2147483647);\r\nbot.vars.tracing = null;\r\nbot.vars.testName = testName;\r\nbot.vars.randomSeed = seed;\r\nbot.vars.debug = d;\r\nd.math.setRandomSeed(seed);\r\nbot.vars.timeline = [];\r\nawait bot.hookupDebugger({ debug: d, addKeys: true, timeline: bot.vars.timeline });\r\nawait bot.addBotsToDebugger(d);\r\n\r\nawait os.attachDebugger(d, {\r\n    tagNameMapper: {\r\n        forward: forwardMapTagName,\r\n        reverse: reverseMapTagName\r\n    },\r\n});\r\n\r\nawait os.sleep(1000);\r\n\r\nif (configBot.tags.gridPortal) {\r\n    bot.vars.originalGridPortal = configBot.tags.gridPortal;\r\n    d.configBot.tags.gridPortal = configBot.tags.gridPortal = 'test-' + configBot.tags.gridPortal;\r\n}\r\n\r\nshout(\"ab1Sleep\", \"sleep\");\r\nshout('ab1Reset');\r\n\r\nfunction forwardMapTagName(name) {\r\n    const builtinTags = os.listBuiltinTags();\r\n    if (builtinTags.some(t => t === name)) {\r\n        return name;\r\n    }\r\n\r\n    return 'test-' + name;\r\n}\r\n\r\nfunction reverseMapTagName(name) {\r\n    const builtinTags = os.listBuiltinTags();\r\n    if (builtinTags.some(t => t === name)) {\r\n        return name;\r\n    }\r\n\r\n    let withoutTest = name.substring('test-'.length);\r\n    return withoutTest;\r\n}\r\n\r\nawait os.registerApp('ab1TestingApp', thisBot);\r\nthisBot.renderTestingApp();","renderTestingApp":"@let result;\r\n\r\nif  (thisBot.vars.debug) {\r\n    if (thisBot.vars.tracing) {\r\n        result = <div>\r\n            <button onClick={() => thisBot.ab1StopTracing()}>Stop Tracing</button>\r\n        </div>\r\n    } else {\r\n        result = <div>\r\n            <button onClick={() => thisBot.ab1StopRecording()}>Stop Recording</button>\r\n        </div>\r\n    }\r\n} else {\r\n    result = <div></div>;\r\n}\r\n\r\nos.compileApp('ab1TestingApp', result);","ab1StopRecording":"@if (bot.vars.debug) {\r\n    await os.detachDebugger(bot.vars.debug);\r\n}\r\n\r\nbot.vars.debug = null;\r\nbot.vars.tracing = null;\r\n\r\nif (bot.vars.originalGridPortal) {\r\n    configBot.tags.gridPortal = bot.vars.originalGridPortal;\r\n    bot.vars.originalGridPortal = null;\r\n}\r\n\r\nconsole.log('[debug] Done!');\r\nlet finalTimeline = bot.compileTimeline({ timeline: bot.vars.timeline });\r\n\r\ncreate({\r\n    __test: true,\r\n    __testCase: true,\r\n    timeline: '🧬' + getFormattedJSON(finalTimeline.slice()),\r\n    onClick: `@shout('runTestCase', thisBot.id)`,\r\n    system: 'tests.' + bot.vars.testName,\r\n    randomSeed: bot.vars.randomSeed,\r\n    testName: bot.vars.testName\r\n});\r\n\r\nshout(\"ab1Sleep\", \"wake\");\r\nthisBot.renderTestingApp();","ab1RunTests":"@const testCases = getBots(\r\n    byTag('__test', true),\r\n    byTag('__testCase', true)\r\n);\r\n\r\nlet totalCount = testCases.length;\r\nlet completedCount = 0;\r\nlet successCount = 0;\r\nlet failureCount = 0;\r\nlet promises = [];\r\nfor(let testCase of testCases) {\r\n    if (testCase.tags.skip) {\r\n        continue;\r\n    }\r\n\r\n    const promise = thisBot.runTestCase(getID(testCase)).then((result) => {\r\n        if (result.success) {\r\n            successCount += 1;\r\n        } else {\r\n            failureCount += 1;\r\n        }\r\n        completedCount += 1;\r\n        if (thisBot.links.runTestsButton) {\r\n            thisBot.links.runTestsButton.masks.label = `${completedCount}/${totalCount}`;\r\n        }\r\n\r\n        return result;\r\n    });\r\n    promises.push(promise);\r\n}\r\n\r\nconst results = await Promise.all(promises);\r\n\r\nlet success = true;\r\nlet firstUnsucessfulResult = null;\r\nfor(let result of results) {\r\n    if (result.success) {\r\n        continue;\r\n    }\r\n    success = false;\r\n    firstUnsucessfulResult = result;\r\n    break;\r\n}\r\n\r\nif (success) {\r\n    os.toast(\"Success!\");\r\n\r\n    if (thisBot.links.runTestsButton) {\r\n        thisBot.links.runTestsButton.masks.label = `✓ ${successCount}/${totalCount}`;\r\n    }\r\n\r\n    return true;\r\n} else {\r\n    configBot.tags.systemPortalDiff = 'testSystem';\r\n    configBot.tags.systemPortal = firstUnsucessfulResult.system;\r\n    configBot.tags.systemPortalPane = 'diff';\r\n    configBot.tags.systemPortalDiffBot = firstUnsucessfulResult.diffBotId;\r\n    configBot.tags.systemPortalDiffTag = 'timeline';\r\n\r\n    if (thisBot.links.runTestsButton) {\r\n        thisBot.links.runTestsButton.masks.label = `❌ ${successCount}/${totalCount}`;\r\n    }\r\n\r\n    return false;\r\n}","ab1RecordTrace":"@const d = await os.createDebugger({\r\n    pausable: true,\r\n    allowAsynchronousScripts: true\r\n});\r\n\r\nif (!bot.vars.traceCounter) {\r\n    bot.vars.traceCounter = 0;\r\n}\r\nbot.vars.traceCounter += 1;\r\nbot.vars.debug = d;\r\nbot.vars.tracing = true;\r\nbot.vars.timeline = [];\r\nawait bot.hookupDebugger({ debug: d, addKeys: false, timeline: bot.vars.timeline, noWarnMissingKeys: true });\r\nawait bot.addBotsToDebugger(d);\r\n\r\nawait os.attachDebugger(d, {\r\n    tagNameMapper: {\r\n        forward: forwardMapTagName,\r\n        reverse: reverseMapTagName\r\n    },\r\n});\r\n\r\nawait os.sleep(1000);\r\n\r\nif (configBot.tags.gridPortal) {\r\n    bot.vars.originalGridPortal = configBot.tags.gridPortal;\r\n    d.configBot.tags.gridPortal = configBot.tags.gridPortal = 'test-' + configBot.tags.gridPortal;\r\n}\r\n\r\nshout(\"ab1Sleep\", \"sleep\");\r\nshout('ab1Reset');\r\n\r\nfunction forwardMapTagName(name) {\r\n    const builtinTags = os.listBuiltinTags();\r\n    if (builtinTags.some(t => t === name)) {\r\n        return name;\r\n    }\r\n\r\n    return 'test-' + name;\r\n}\r\n\r\nfunction reverseMapTagName(name) {\r\n    const builtinTags = os.listBuiltinTags();\r\n    if (builtinTags.some(t => t === name)) {\r\n        return name;\r\n    }\r\n\r\n    let withoutTest = name.substring('test-'.length);\r\n    return withoutTest;\r\n}\r\n\r\nawait os.registerApp('ab1TestingApp', thisBot);\r\nthisBot.renderTestingApp();","ab1StopTracing":"@if (bot.vars.debug) {\r\n    await os.detachDebugger(bot.vars.debug);\r\n}\r\n\r\nbot.vars.debug = null;\r\nbot.vars.tracing = null;\r\n\r\nif (bot.vars.originalGridPortal) {\r\n    configBot.tags.gridPortal = bot.vars.originalGridPortal;\r\n    bot.vars.originalGridPortal = null;\r\n}\r\n\r\nconsole.log('[debug] Done!');\r\nlet finalTimeline = bot.compileTimeline({ timeline: bot.vars.timeline });\r\n\r\nconst traceName = 'traces.' + pad(bot.vars.traceCounter.toString());\r\nconst rendered = thisBot.renderTimeline({ timeline: finalTimeline, name: traceName });\r\nconst { resultBot } = thisBot.createBotsForRenderedTimeline({ result: rendered, system: traceName });\r\n\r\nshout(\"ab1Sleep\", \"wake\");\r\nthisBot.renderTestingApp();\r\n\r\nos.focusOn(resultBot, {\r\n    tag: 'timeline',\r\n    portal: 'system',\r\n    lineNumber: 0,\r\n    columnNumber: 0\r\n});\r\n\r\nfunction pad(str) {\r\n\r\n    let remaining = 6 - str.length;\r\n    if (remaining > 0) {\r\n        let padded = '0'.repeat(remaining);\r\n        return padded + str;\r\n    }\r\n\r\n    // while(str.length < 6) {\r\n    //     str += '0' + str;\r\n    // }\r\n\r\n    return str;\r\n}","renderTimeline":"@class StringBuilder {\r\n    constructor(str) {\r\n        this.indent = 0;\r\n        this.markers = [];\r\n        this.str = str;\r\n        this.loc = loc(str);\r\n    }\r\n\r\n    appendLine(s) {\r\n        if (this.indent > 0) {\r\n            this.str += indent(s, this.indent);\r\n        } else {\r\n            this.str += s;\r\n        }\r\n        this.str += '\\n';\r\n        this.loc = loc(this.str);\r\n        return this;\r\n    }\r\n\r\n    append(s) {\r\n        this.str += s;\r\n        this.loc = loc(this.str);\r\n        return this;\r\n    }\r\n}\r\n\r\nfunction loc(str) {\r\n    const lines = str.split('\\n');\r\n    const line = lines.length;\r\n    const col = lines[lines.length - 1].length;\r\n    return {\r\n        line,\r\n        col\r\n    };\r\n}\r\n\r\nfunction renderTimeline(timeline, name) {\r\n    let builder = new StringBuilder('@');\r\n    builder.appendLine('// Note: this is a visualization of the test timeline.');\r\n    builder.appendLine('// It does not contain working code.\\n');\r\n    builder.appendLine(`start('${name}')`);\r\n    for(let event of timeline) {\r\n        renderEvent(event, builder);\r\n    }\r\n\r\n    console.log(builder.str);\r\n    builder.appendLine('end()');\r\n    return {\r\n        string: builder.str,\r\n        markers: builder.markers\r\n    };\r\n}\r\n\r\nfunction renderEvent(event, builder) {\r\n    console.log('render', event);\r\n    if (event.type === 'user_action') {\r\n        renderUserAction(event, builder);\r\n    } else if (event.type === 'emitted_action') {\r\n        renderEmittedAction(event, builder);\r\n    } else if (event.type === 'check') {\r\n        builder.appendLine(`check: ${getFormattedJSON(event.diff)}`);\r\n    } else if (event.type === 'update_tag') {\r\n        renderUpdateTag(event, builder);\r\n    } else if (event.type === 'update_tag_mask') {\r\n        renderUpdateTagMask(event, builder);\r\n    } else if (event.type === 'script') {\r\n        renderScript(event, builder);\r\n    }\r\n}\r\n\r\nfunction renderShout(event, builder) {\r\n    builder.appendLine(`// @${event.action.eventName}`);\r\n    if (event.action.keys.length > 0) {\r\n        builder.appendLine(`whisper.${event.action.eventName}('${event.action.keys.join(',')}')`);\r\n    } else {\r\n        builder.appendLine(`shout.${event.action.eventName}()`);\r\n    }\r\n}\r\n\r\nfunction renderEmittedAction(event, builder) {\r\n    let prefix = '';\r\n    if ('taskId' in event.action) {\r\n        prefix = `\\$${event.action.taskId}: `;\r\n    }\r\n    let { taskId, type, ...rest } = event.action;\r\n\r\n    if (event.location) {\r\n        builder.markers.push({\r\n            line: builder.loc.line,\r\n            label: 'Go to action',\r\n            location: event.location\r\n        });\r\n    }\r\n\r\n    builder.appendLine(`${prefix}${type}(${getFormattedJSON(rest)})`);\r\n}\r\n\r\nfunction renderUpdateTag(event, builder) {\r\n    if (event.location) {\r\n        builder.markers.push({\r\n            line: builder.loc.line,\r\n            label: 'Go to Tag Update',\r\n            location: event.location\r\n        });\r\n    }\r\n\r\n    builder.appendLine(`updateTag(${event.update.tag}, ${getFormattedJSON(event.update.newValue)})`);\r\n}\r\n\r\nfunction renderUpdateTagMask(event, builder) {\r\n    if (event.location) {\r\n        builder.markers.push({\r\n            line: builder.loc.line,\r\n            label: 'Go to Tag Mask Update',\r\n            location: event.location\r\n        });\r\n    }\r\n\r\n    builder.appendLine(`updateTagMask(${event.update.tag}, ${event.update.space}, ${getFormattedJSON(event.update.newValue)})`);\r\n}\r\n\r\nfunction renderScript(event, builder) {\r\n    if (event.location) {\r\n        builder.markers.push({\r\n            line: builder.loc.line,\r\n            label: 'Go to Script',\r\n            location: event.location\r\n        });\r\n    }\r\n\r\n    builder.appendLine(`run_script('${event.botId}', '${event.tag}', () => {`);\r\n    builder.indent += 4;\r\n    for (let e of event.timeline) {\r\n        renderEvent(e, builder);\r\n    }\r\n    builder.indent -= 4;\r\n    builder.appendLine('\\n})');\r\n}\r\n\r\nfunction renderUserAction(event, builder) {\r\n    if ('timeline' in event) {\r\n        for (let e of event.timeline) {\r\n            renderEvent(e, builder);\r\n        }\r\n    } else if (event.action.type === 'action') {\r\n        renderShout(event, builder);\r\n    } else if (event.action.type === 'async_result') {\r\n        let formatted = getFormattedJSON(event.action.result);\r\n        let commented = formatted.split('\\n').map(line => `// ${line}`).join('\\n');\r\n\r\n        builder.appendLine(`${commented} -> \\$${event.action.taskId}`);\r\n    }\r\n}\r\n\r\nfunction indent(str, level) {\r\n    let lines = str.split('\\n');\r\n    let indentString = ' '.repeat(level);\r\n    let indented = lines.map(l => l.length > 0 ? indentString + l : l);\r\n    return indented.join('\\n');\r\n}\r\n\r\nconst { timeline, name } = that;\r\n\r\nreturn renderTimeline(timeline, name);","createBotsForRenderedTimeline":"@const { system, result, creator, systemTag } = that;\r\n\r\n// const system = systemPrefix + testCase.tags.testName;\r\n\r\nlet resultBot = create({\r\n    space: 'tempLocal',\r\n    creator: creator?.id,\r\n    __test: true,\r\n    __testResult: true,\r\n    timeline: result.string,\r\n    [systemTag ?? 'system']: system\r\n});\r\n\r\nconst markerMod = {\r\n    space: 'tempLocal',\r\n    creator: resultBot.id,\r\n    __test: true,\r\n    __testResult: true,\r\n    form: 'codeButton',\r\n    onClick: `@os.focusOn(bot.tags.location.botId, { portal: 'system', tag: bot.tags.location.tag, lineNumber: bot.tags.location.line, columnNumber: bot.tags.location.column })`\r\n};\r\n\r\nfor (let marker of result.markers) {\r\n    create(markerMod, {\r\n        [`${resultBot.id}.timeline`]: true,\r\n        [`${resultBot.id}.timelineStart`]: marker.line,\r\n        label: marker.label,\r\n        location: marker.location,\r\n    });\r\n}\r\n\r\nreturn {\r\n    resultBot\r\n};","ab1X":7,"ab1Skill":"true"}}}}