{"version":1,"state":{"16ca727c-b4e8-4075-890d-93d1e2f696ae":{"id":"16ca727c-b4e8-4075-890d-93d1e2f696ae","space":"shared","tags":{"ab1":true,"ab1ID":"createPortal","ab1Icon":"terrain","ab1MenuLabel":"portal","ab1PortalClickCheck":"@let currentDim = that.dimension;\nlet dimDecks = getBots(byMod({primitiveID: \"openDeck\", [currentDim]: true}));\nlet portalEntry;\n\nconfigBot.tags.ab1CurrentPortal = null;\n\nif (dimDecks.length > 0) \n{\n    deckCheck:\n    for (let i = 0; i < dimDecks.length; i++) \n    {\n        let currentDeck = dimDecks[i];\n        let maxY = currentDeck.tags[currentDim + \"Y\"] + currentDeck.tags.scale / 2;\n        let minY = currentDeck.tags[currentDim + \"Y\"] - currentDeck.tags.scale / 2;\n\n        if (that.position.y <= maxY && that.position.y >= minY) \n        {\n\n            //SETUP A CHECK FOR WHEN X = DECK X\n            let maxX = currentDeck.tags[currentDim + \"X\"] + currentDeck.tags.scale / 2 + 0.5;\n            let minX = currentDeck.tags[currentDim + \"X\"] - currentDeck.tags.scale / 2 - 0.5;\n\n            if (that.position.x <= maxX && that.position.x >= minX) \n            {\n                if (that.position.x <= currentDeck.tags[currentDim+\"X\"] + 0.3 && that.position.x >= currentDeck.tags[currentDim+\"X\"] - 0.3)//not perfect part of alg\n                {\n                    if (that.position.y >= currentDeck.tags[currentDim+\"Y\"] - currentDeck.tags.scale/2 && that.position.y <= currentDeck.tags[currentDim+\"Y\"] + currentDeck.tags.scale/2)\n                    {\n                        configBot.tags.ab1CurrentPortal = currentDeck.tags.origin;\n                        portalEntry = true;\n                        break deckCheck;\n                    }\n                }\n                \n\n                let midX = currentDeck.tags[currentDim+\"X\"];\n                let midY = currentDeck.tags[currentDim+\"Y\"];\n                const a = Math.pow(currentDeck.tags.scale/2, 2);\n                const b = Math.pow(a / 2, 2);\n                const maxDistance = Math.sqrt(Math.abs(a - b));\n                let slope;\n\n                if ((that.position.x > midX && that.position.y > midY) || (that.position.x < midX && that.position.y < midY))\n                {\n                    slope = (maxY - minY)/(maxX-minX);\n                }\n                else\n                {\n                    if (that.position.x > midX)\n                        slope = (maxX-minX)/(maxY - minY);\n                    else\n                    {\n                        slope = 1/(maxX-minX)/(maxY - minY);\n                    }\n                }\n\n                let c1 = maxY - (maxX * slope);\n                let c2 = that.position.y - (that.position.x * slope);  \n                let actualDistance = Math.abs(c2 - c1)/Math.sqrt(Math.pow(slope,2)+1);\n                \n                if (actualDistance <= maxDistance) \n                {\n                    configBot.tags.ab1CurrentPortal = currentDeck.tags.origin;\n                    portalEntry = true;\n                    break deckCheck;\n                }\n            }\n        }\n\n        if (that.portalID) \n        {\n            if (that.portalID == currentDeck.tags.origin) \n            {\n                configBot.tags.ab1CurrentPortal = currentDeck.tags.origin;\n                portalEntry = true;\n                break deckCheck;\n            }\n        }\n    }\n}\n\nfor (let i = 0; i < dimDecks.length; i++) \n{\n    if (dimDecks[i].tags.origin != configBot.tags.ab1CurrentPortal) {\n        whisper(dimDecks[i], \"portalReset\");\n    }\n}\n\nif (portalEntry)\n{\n    return true;\n}\nelse\n{\n    return false;\n}","ab1PortalMenu":"@if (os.getMenuDimension() != null)\n{\n    setTagMask(ab1InstMemory, \"previousMenu\", os.getMenuDimension());\n}\n\nconfigBot.tags.menuPortal = \"ab1Menu\";\n\nlet portalBot = that;\nlet menuButton = {};\n\nmenuButton.space = \"tempLocal\";\nmenuButton.ab1Menu = true;\nmenuButton.ab1MenuReset = \"@ destroy(thisBot);\";\nmenuButton.color = portalBot.tags.color;\nmenuButton.menuItemStyle = `ðŸ§¬ {\"border-radius\": \"9px 9px 9px 9px\", \"margin-top\": \"6px\"}`;\nmenuButton.ab1Click = \"@ destroy(thisBot);\";\nmenuButton.labelAlignment = \"center\";\nmenuButton.label = portalBot.tags.portalAddress;\n\ncreate(menuButton);\n\nmenuButton.formAddress = \"edit\";\nmenuButton.labelAlignment = \"left\";\nmenuButton.label = \"edit dimension\";\nmenuButton.target = portalBot.id;\nmenuButton.onClick = `@ shout('ab1Refresh');\n\nlet portalBot = getBot('id', tags.target);\n\nlet originalDim = portalBot.tags.portalAddress;\n\nlet dim = await os.showInput(originalDim, {\n    title: \"edit dimension\"\n});\n\nif (!dim)\n{\n    return;\n};\n\nportalBot.tags.portalAddress = dim;\n\nif (configBot.tags.miniGridPortal == originalDim)\n{\n    configBot.tags.miniGridPortal = dim;\n}\n\nshout('clearPortal', portalBot.id);`;\n\ncreate(menuButton);\n\nmenuButton.formAddress = \"arrow_forward\";\nmenuButton.labelAlignment = \"left\";\nmenuButton.label = \"go to dimension\";\nmenuButton.target = portalBot.tags.formAddress;\nmenuButton.onClick = `@ configBot.tags.gridPortal = tags.target; shout('ab1Refresh');`;\n\ncreate(menuButton);","ab1Skill":"true","ab1ToolBoxAction":"@let positionInfo = ab1InstMemory.tags.ab1FocusData;\nlet defaultDim = uuid();\nlet newBot = {}\n\nnewBot.creator = null;\nnewBot[positionInfo.dimension] = true;\nnewBot[positionInfo.dimension+\"X\"] = positionInfo.x;\nnewBot[positionInfo.dimension+\"Y\"] = positionInfo.y;\nnewBot[positionInfo.dimension+\"Z\"] = -1;\nnewBot.color = \"#7B64FF\";\nnewBot.primitiveID = \"portal\";\nnewBot.dimension = positionInfo.dimension;\nnewBot.deckID = defaultDim;\nnewBot.portalAddress = defaultDim;\nnewBot.form = \"hex\";\nnewBot.scale = 2;\nnewBot.scaleZ = 0.75;\nnewBot.onClick = `@ shout(\"setupPortal\", tags); masks.open = true`;\nnewBot.portalReset = `@ if (tags.open){masks.open = null; shout('clearPortal', thisBot.id)};`;\nnewBot.onPointerEnter = \"@ masks.scale = 2.1;\";\nnewBot.onPointerExit = \"@ masks.scale = 2;\";\nnewBot.portalReset = \"@ if (getBots('empty', thisBot.id).length > 6){shout('clearPortal', thisBot.id);}\";\nnewBot.onDropEnter = \"@ if (that.to.bot.id == thisBot.id && that.dragBot.tags.ab1ID != 'ab1Selector'){whisper(thisBot, 'onClick');};\"\nnewBot.portalClick = `@ let xPos = tags[tags.dimension + \"X\"] + that[tags.portalAddress+\"X\"];\nlet yPos = tags[tags.dimension + \"Y\"] + that[tags.portalAddress+\"Y\"];\nshout(\"onGridClick\", {position: {x: xPos, y: yPos}, dimension: tags.dimension, portalID: thisBot.id});`;\n\nlet createBot = create(newBot);\n\nshout(\"ab1Refresh\");","ab1ToolBoxSkill":"true","ab1UpdateID":"3e91a2a1-be6c-4cdf-8873-c5933bc7841e","ab1X":-11,"ab1Y":0,"ab1Z":0,"abIDOrigin":"ab1ToolBox","auxCodeOrigin":"ab1ToolBox","clearPortal":"@let portalBots = getBots(\"origin\", that);\nlet portal = getBot(\"id\", that);\n\nportal.masks.formAddress = null;\n\nportalBots.sort((a, b) =>b.tags.hexNum - a.tags.hexNum);\n\nfor (let i = 0; i < portalBots.length; i++)\n{\n    let currentHex = portalBots[i];\n\n    destroy(currentHex);\n}\n\nclearTagMasks(portal);","color":"#55E679","destroyable":false,"onAnyBotDrag":"@let currentBot = that.bot;\n\nif (currentBot.tags.primitiveID)\n{\n    if (currentBot.tags.primitiveID == \"portal\")\n    {\n        currentBot.masks.interval = setInterval(() => shout('portalPositionCheck', currentBot), 100);\n    }\n}","onAnyBotDrop":"@let currentDim = that.to.dimension;\nlet dimDecks = getBots(byMod({primitiveID: \"deck\", [currentDim]: true}));\n\nif (dimDecks)\n{\n    let portalDrop = await shout(\"ab1PortalClickCheck\", {dimension: that.to.dimension, position: {x: that.to.x, y: that.to.y}, type: \"drop\"})[0];\n\n    if (portalDrop)\n    {\n        let targetDeck = getBot(\"id\", configBot.tags.ab1CurrentPortal)\n        let newDim = targetDeck.tags.portalAddress;\n        \n        that.bot.tags[newDim] = true;\n        that.bot.tags[newDim+\"X\"] = that.bot.tags[currentDim+\"X\"] - targetDeck.tags[currentDim+\"X\"];\n        that.bot.tags[newDim+\"Y\"] = that.bot.tags[currentDim+\"Y\"] - targetDeck.tags[currentDim+\"Y\"];\n        that.bot.tags[currentDim] = null;\n\n        configBot.tags.ab1CurrentPortal = null;\n    }\n}\n\nif (that.bot.tags.primitiveID)\n{\n    if (that.bot.tags.primitiveID == \"portal\")\n    {\n        let portalBot = that.bot;\n\n        clearInterval(portalBot.masks.interval);\n        clearTagMasks(portalBot);\n\n        if (that.to.dimension != that.from.dimension)\n        {\n            if (that.to.dimension == portalBot.tags.portalAddress)\n            {\n                configBot.tags.miniGridPortal = portalBot.tags.portalAddress;\n\n                miniGridPortalBot.tags.miniPortalWidth = 1;\n\n                portalBot.tags[that.to.dimension + \"X\"] = 0;\n                portalBot.tags[that.to.dimension + \"Y\"] = 0;\n            }\n            else if (configBot.tags.miniGridPortal == portalBot.tags.portalAddress && that.to.dimension != portalBot.tags.portalAddress)\n            {\n                configBot.tags.miniGridPortal = null;\n            }\n        }\n    }\n}","onCreate":null,"onGridClick":"@let currentDim = that.dimension;\nlet dimDecks = getBots(byMod({primitiveID: \"deck\", [currentDim]: true}));\n\nif (dimDecks)\n{\n    let portalEntry = await whisper(thisBot, \"ab1PortalClickCheck\", that)[0];\n}","portalPositionCheck":"@let height = gridPortalBot.tags.pixelHeight;\nlet botThird = height - (height / 8);\nlet pointerY = gridPortalBot.tags.pointerPixelY;\nlet currentBot = that;\n\nif (pointerY > botThird)\n{\n    if (configBot.tags.miniGridPortal != currentBot.tags.portalAddress)\n    {\n        configBot.tags.miniGridPortal = currentBot.tags.portalAddress;\n\n        miniGridPortalBot.tags.miniPortalWidth = 1;\n\n        miniGridPortalBot.tags.portalColor = currentBot.tags.color;\n    }\n}\nelse\n{\n    if (configBot.tags.miniGridPortal == currentBot.tags.portalAddress)\n    {\n        configBot.tags.miniGridPortal = null;\n        miniGridPortalBot.tags.portalColor = null;\n        miniGridPortalBot.tags.miniPortalWidth = null;\n    }\n}","scale":1,"scaleX":"0.8","scaleY":"0.8","scaleZ":"1.6","setupPortal":"@let originBot = getBot(\"id\", that.id);\nlet color = originBot.tags.color;\nlet hexNum = 1;\nlet currentDim = originBot.tags.dimension;\nconst a = Math.PI / 6;\nconst hexScale = 5;\nconst targetDim = originBot.tags.portalAddress;\n\nlet hex = {};\n\nhex.space = \"tempLocal\";\nhex.dimension = currentDim;\nhex.primitiveID = \"openDeck\";\nhex.reset = \"@ destroy(thisBot);\";\nhex.form = \"hex\";\nhex.color = color;\nhex.origin = that.id;\nhex.portalReset = \"@ tags.empty = tags.origin; whisper(getBot('id', tags.origin), 'portalReset');\";\nhex.portalColorUpdate = \"@ tags.color = that;\";\nhex[currentDim+\"Z\"] = -1;\nhex.anchorPoint = \"top\";\nhex.scale = 4.5;\nhex[currentDim] = true;\nhex.pointable = false;\nhex.scaleZ = 0.01;\nhex.animate = `@ animateTag(thisBot, \"scale\", {\n    fromValue: tags.scale,\n    toValue: [that],\n    easing: {\n        type: \"quadratic\",\n        mode: \"out\"\n    },\n    duration: 0.3\n}).catch(e => { });`;\n\nlet scaleBots = getBots(targetDim, true);\nlet ringNum;\n\nif (scaleBots.length > 0)\n{\n    let xParameter = scaleBots.sort((a, b)=> Math.abs(b.tags[targetDim+\"X\"]) - Math.abs(a.tags[targetDim+\"X\"]))[0].tags[targetDim+\"X\"];\n    let yParameter = scaleBots.sort((a, b)=> Math.abs(b.tags[targetDim+\"Y\"]) - Math.abs(a.tags[targetDim+\"Y\"]))[0].tags[targetDim+\"Y\"];\n\n\n    let distance = Math.floor(Math.sqrt(Math.pow(Math.floor(Math.abs(xParameter - 0)), 2) + Math.pow(Math.floor(Math.abs(yParameter - 0)), 2)) / hexScale) + 1;\n    ringNum = 6 * (distance)*(distance+1)/2 + 1;\n\n    if (ringNum > 397)\n    {\n        ringNum = 397;\n    }\n}\nelse\n{\n    ringNum = 7;\n}\n\nif (that.portalAddress == \"ab1ToolBox\")\n{\n    ringNum = 7;\n}\n\noriginBot.masks.scale = 0.1;\noriginBot.masks.pointable = false;\n\nfor (let i = 0; i < ringNum; i++)\n{\n    if (i != 0)\n    {\n        let emptyPos = await checkHexPos(previousHex, currentDim);\n\n        if (emptyPos == 0 || emptyPos == 3)\n        {\n            var x = previousHex.tags[currentDim+\"X\"];\n            \n            var flipX = 1;\n            \n            if (emptyPos == 0)\n            {\n                var flipY = 0;\n                var y = previousHex.tags[currentDim+\"Y\"] + hexScale;\n            }\n            else\n            {\n                var flipY = -1;\n                var y = previousHex.tags[currentDim+\"Y\"] - hexScale/2;\n            }\n        }\n        else\n        {\n            var x = previousHex.tags[currentDim+\"X\"] + (hexScale * 0.85);\n            var y = previousHex.tags[currentDim+\"Y\"];\n\n            if (emptyPos == 1)\n            {\n                var flipX = 1;\n                var flipY = 1;\n            }\n            else if (emptyPos == 2)\n            {\n                var flipX = 1;\n                var flipY = -1;\n            }\n            else if (emptyPos == 4)\n            {\n                x = previousHex.tags[currentDim+\"X\"] - (hexScale * 0.85);\n\n                var flipX = 1;\n                var flipY = -1;\n            }\n            else if (emptyPos == 5)\n            {\n                x = previousHex.tags[currentDim+\"X\"] - (hexScale * 0.85);\n                \n                var flipX = 1;\n                var flipY = 1;\n            }\n        }\n\n        hex[currentDim+\"X\"] = x * flipX;\n        hex[currentDim+\"Y\"] = y + flipY * hexScale/2;\n    }\n    else\n    {\n        hex[currentDim+\"X\"] = originBot.tags[currentDim+\"X\"];\n        hex[currentDim+\"Y\"] = originBot.tags[currentDim+\"Y\"];\n    }\n\n    hex.hexNum = hexNum;\n\n    let nearbyPortalBot = getBot(byMod({//being mirrored right now\n        [targetDim]: true,\n        [targetDim+\"X\"]: x => x > (hex[currentDim+\"X\"] - originBot.tags[currentDim+\"X\"]) - hexScale && x < (hex[currentDim+\"X\"] - originBot.tags[currentDim+\"X\"]) + hexScale,\n        [targetDim+\"Y\"]: y => y > (hex[currentDim+\"Y\"] - originBot.tags[currentDim+\"Y\"]) - hexScale && y < (hex[currentDim+\"Y\"] - originBot.tags[currentDim+\"Y\"]) + hexScale\n    }));\n\n    if (nearbyPortalBot || i < 7)\n    {\n        hex.onPortalComplete = false;\n        hex.color = color;\n    }\n    else\n    {\n        hex.onPortalComplete = true;\n        hex.color = \"clear\";\n    }\n\n    hexNum++;\n\n    var previousHex = await create(hex);\n}\n\nlet nonPortalHexes = getBots(\"onPortalComplete\", true);\nlet portalHexes = getBots(\"onPortalComplete\", false);\n\nfor (let n = 0; n < nonPortalHexes.length; n++)\n{\n    destroy(nonPortalHexes[n]);\n}\n\nwhisper(portalHexes, \"animate\", hexScale);\n\noriginBot.masks.form = \"portal\";\noriginBot.masks.formAddress = originBot.tags.portalAddress;\n\nif (originBot.tags.portalAddress != \"ab1ToolBox\")\n{\n    shout(\"ab1PortalMenu\", originBot);\n}\n\nfunction checkHexPos(hex, dimension)\n{\n    let scaleVar = hexScale/2;\n    let xPos = hex.tags[dimension+\"X\"];\n    let yPos = hex.tags[dimension+\"Y\"];\n    let hexMathVar = Math.PI / 6;\n    let xSpacingPlus = xPos + scaleVar + (1 + Math.cos(hexMathVar));\n    let xSpacingMinus = xPos - (scaleVar + (1 + Math.cos(hexMathVar)));\n    let ySpacingTop = Math.floor(hex.tags.scale) + yPos;\n    let ySpacingUp = yPos + scaleVar * Math.sin(hexMathVar);\n    let ySpacingDown = yPos - scaleVar * Math.sin(hexMathVar);\n    let ySpacingBottom = yPos - Math.floor(hex.tags.scale);\n    let xCheck = [xPos, xSpacingPlus, xSpacingPlus, xPos, xSpacingMinus, xSpacingMinus];\n    let yCheck = [ySpacingTop, ySpacingUp, ySpacingDown, ySpacingBottom, ySpacingDown, ySpacingUp];\n    let totalNeighbors = 0;\n    let neighborArray = []\n\n    for (let i = 0; i < 6; i++)\n    {\n        let hexNeighbor = getBot(byMod({\n            [dimension]: true, \n            [dimension+\"X\"]: x => x > xCheck[i] - scaleVar && x < xCheck[i] + scaleVar, \n            [dimension+\"Y\"]: y => y > yCheck[i] - scaleVar && y < yCheck[i] + scaleVar,\n            origin: hex.tags.origin,\n            primitiveID: \"openDeck\"\n        }));\n\n        if (!hexNeighbor)\n        {\n            neighborArray.push(\"empty\");\n        }\n        else\n        {\n            neighborArray.push(hexNeighbor);\n            totalNeighbors++;\n        }\n    }\n\n    if (totalNeighbors == 0)\n    {\n        var target = 0;\n    }\n    else\n    {\n        var empty = false;\n\n        for (let j = 0; j < 6; j++)\n        {\n            let nextEmpty = neighborArray[j];\n\n            if (nextEmpty == \"empty\")\n            {\n                empty = true;\n\n                if (j == 5)\n                {\n                    var target = 5;\n                }\n            }\n            if(nextEmpty != \"empty\" && empty)\n            {\n                var target = j-1;\n                break;\n            }\n        }\n    }\n    return target;\n}","strokeColor":"orange","system":"ab1.toolBox.createPortal"}},"7e3b803b-49b7-426f-bc0c-1a9a0bf3152f":{"id":"7e3b803b-49b7-426f-bc0c-1a9a0bf3152f","space":"shared","tags":{"ab1":true,"ab1BotAction":"@let selectedBotID = ab1InstMemory.tags.ab1FocusData;\n\nshout(\"ab1MakeMod\", {bot:selectedBotID});\n\nshout(\"ab1Refresh\");","ab1GuideHideButton":"@let previousButton = getBot(\"ab1GuideHideButton\", true);\nlet menuDim = os.getMenuDimension();\n\nif (menuDim == null)\n{\n    menuDim = \"ab1Menu\";\n    configBot.tags.menuPortal = \"ab1Menu\";\n}\n\nif(previousButton)\n{\n    destroy(previousButton);\n};\n\nlet guideHideButton = {};\n\nguideHideButton.space = \"tempLocal\";\nguideHideButton.color = \"black\";\nguideHideButton.labelColor = \"white\";\nguideHideButton.labelAlignment = \"left\";\nguideHideButton.label = \"hide guides\";\nguideHideButton.formAddress = \"visibility_off\";\nguideHideButton[menuDim] = true;\nguideHideButton[menuDim + \"SortOrder\"] = 10;\nguideHideButton.ab1Refresh = \"@ destroy(thisBot);\"\nguideHideButton.onClick = \"@ shout('trackPrimitiveHide');\";\nguideHideButton.menuItemStyle\nguideHideButton.ab1GuideHideButton = true;\nguideHideButton.trackMenuReset = \"@ destroy(thisBot);\";\nguideHideButton.menuItemStyle = `ðŸ§¬ {\"border-radius\": \"9px 9px 9px 9px\", \"margin-top\": \"6px\"}`;\nguideHideButton.ab1Click = \"@ destroy(thisBot);\";\n\ncreate(guideHideButton);","ab1ID":"createMod","ab1Icon":"helix","ab1MakeMod":"@let newBot = {}\n\nnewBot.creator = null;\nnewBot.form = \"helix\";\nnewBot.modPrimitive = true;\nnewBot.onClick = \"@ shout('ab1GuideHideButton'); shout('ab1ModMenuButton', thisBot.id);\";\nnewBot.scale = 0.5;\nnewBot.scaleZ = 1.61;\n\nif (that.bot != \"empty\")\n{\n    let ab1 = getBot(\"ab1ID\", \"ab1\");\n    let dimension = ab1.tags.dimension;\n    let targetBot = getBot(\"id\", that.bot).tags;\n    let mods = {};\n\n    for (const tags in targetBot)\n    {\n        if (tags != dimension+\"X\" && tags != dimension+\"Y\" && tags != dimension+\"Z\")\n        mods[tags] = targetBot[tags];\n    }\n\n    newBot.mods = mods;\n    newBot.color = mods.color;\n    newBot[dimension] = true;\n    newBot[dimension+\"X\"] = ab1.tags[dimension+\"X\"];\n    newBot[dimension+\"Y\"] = ab1.tags[dimension+\"Y\"];\n    newBot[dimension+\"Z\"] = 1;\n}\nelse if (that.position)\n{\n    newBot.color = \"#5E5880\";\n    newBot.mods = `ðŸ§¬{\n\"color\": \"black\"\n}`;\n    newBot[that.position.dimension] = true;\n    newBot[that.position.dimension+\"X\"] = that.position.x;\n    newBot[that.position.dimension+\"Y\"] = that.position.y;\n}\n\nlet createdBot = create(newBot);\n\nreturn createdBot;","ab1MenuLabel":"mod","ab1MenuLabelBotFocus":"extract mod","ab1MenuLabelGridFocus":"mod","ab1ModMenuButton":"@let previousButton = getBot(\"ab1ModMenuButton\", true);\nlet menuDim = os.getMenuDimension();\n\nif (menuDim == null)\n{\n    menuDim = \"ab1Menu\";\n    configBot.tags.menuPortal = \"ab1Menu\";\n}\n\nif(previousButton)\n{\n    destroy(previousButton);\n};\n\nlet modMenuButton = {};\n\nmodMenuButton.space = \"tempLocal\";\nmodMenuButton.color = \"black\";\nmodMenuButton.labelColor = \"white\";\nmodMenuButton.labelAlignment = \"left\";\nmodMenuButton.label = \"edit mod\";\nmodMenuButton.formAddress = \"edit\";\nmodMenuButton[menuDim] = true;\nmodMenuButton[menuDim + \"SortOrder\"] = 1;\nmodMenuButton.targetBot = that;\nmodMenuButton.ab1Refresh = \"@ destroy(thisBot);\"\nmodMenuButton.onClick = `@ let selectedBotID = tags.targetBot;\n        \n    configBot.tags.tagPortal = selectedBotID+\".mods\";\n\n    tagPortalBot.tags.tagPortalAnchorPoint = \"top\";\n\n    setTagMask(getBot(\"ab1ID\", \"createMod\"), \"onGridClick\", \"@ configBot.tags.tagPortal = null;\");`;\nmodMenuButton.menuItemStyle\nmodMenuButton.ab1ModMenuButton = true;\nmodMenuButton.trackMenuReset = \"@ destroy(thisBot);\";\nmodMenuButton.menuItemStyle = `ðŸ§¬ {\"border-radius\": \"9px 9px 9px 9px\", \"margin-top\": \"6px\"}`;\nmodMenuButton.ab1Click = \"@ destroy(thisBot);\";\n\ncreate(modMenuButton);","ab1Skill":"true","ab1ToolBoxAction":"@let positionInfo = ab1InstMemory.tags.ab1FocusData;\n\nlet createBot = await shout(\"ab1MakeMod\", {bot: \"empty\", position: positionInfo})[0];\n\nshout(\"ab1Refresh\");","ab1ToolBoxSkill":"true","ab1UpdateID":"7b60b041-7056-4504-b128-589811501777","ab1X":-8,"ab1Y":0,"ab1Z":0,"abIDOrigin":"ab1ToolBox","auxCodeOrigin":"ab1ToolBox","color":"#55E679","destroyable":false,"modPrimitiveHide":"@let modNodes = getBots(\"modPrimitive\", true);\n\nshout(\"ab1Refresh\");\n\nif (that == \"show\")\n{\n    clearTagMasks(modNodes);\n    clearTagMasks(thisBot);\n}\nelse\n{\n    setTagMask(modNodes, \"color\", \"clear\");\n    setTagMask(modNodes, \"pointable\", false);\n    setTagMask(thisBot, \"modHidden\", true);\n}","onAnyBotDrop":"@if (that.dragBot.tags.modPrimitive && that.to.bot)\n{\n    if (that.to.bot.tags.modPrimitive)\n    {\n        that.dragBot.tags[that.to.dimension+\"X\"] = that.to.bot.tags[that.to.dimension+\"X\"];\n        that.dragBot.tags[that.to.dimension+\"Y\"] = that.to.bot.tags[that.to.dimension+\"Y\"];\n        that.dragBot.tags[that.to.dimension+\"Z\"] = 1;\n    }\n    else if (that.to.bot.tags.trackPrimitive)\n    {\n        destroy(that.dragBot);\n        \n        shout(\"ab1ModTrack\", {modBot: that.dragBot, trackBot: that.to.bot});\n    }\n    else\n    {\n        applyMod(that.to.bot, that.dragBot.tags.mods);\n\n        var snapBack = true;\n    }\n}\nelse if (that.to.bot)\n{\n    if (that.to.bot.tags.modPrimitive)\n    {\n        applyMod(that.dragBot, that.to.bot.tags.mods);\n\n        var snapBack = true;\n    }\n}\n\nif (snapBack == true)\n{\n    that.dragBot.tags[that.from.dimension] = true;\n    that.dragBot.tags[that.from.dimension + \"X\"] = that.from.x;\n    that.dragBot.tags[that.from.dimension + \"Y\"] = that.from.y;\n}","onMenuCreate":"@if (ab1InstMemory.tags.ab1Focus == \"ab1BotAction\")\n{\n    let target = getBot(\"id\", ab1InstMemory.tags.ab1FocusData)\n\n    if (target.tags.modPrimitive)\n    {\n        destroy(thisBot);\n    }\n}","scale":1,"scaleX":"0.8","scaleY":"0.8","scaleZ":"1.6","strokeColor":"orange","system":"ab1.toolBox.createMod"}},"b62d5a0e-1424-432b-a03d-bc590c1bad2d":{"id":"b62d5a0e-1424-432b-a03d-bc590c1bad2d","space":"shared","tags":{"ab1":true,"ab1ID":"createTrack","ab1Icon":"timeline","ab1MenuLabel":"track","ab1ModTrack":"@let modBot = that.modBot;\nlet trackBot = that.trackBot;\nlet modImage = \"https://builder-ltm-files.s3.amazonaws.com/b6352edb88598a1969a648f7dd6d418233ef1159bd78b737cf20a3da5405d1c4.png\";\n\nwhisper(thisBot, 'updateTrackNode', {bot: trackBot.id, changeType: \"mods\", input: modBot.tags.mods});\nwhisper(thisBot, 'updateTrackNode', {bot: trackBot.id, changeType: \"form\", input: \"sprite\"});\nwhisper(thisBot, 'updateTrackNode', {bot: trackBot.id, changeType: \"formAddress\", input: modImage});\nwhisper(thisBot, 'updateTrackNode', {bot: trackBot.id, changeType: \"color\", input: trackBot.tags.strokeColor});","ab1Skill":"true","ab1ToolBoxAction":"@let positionInfo = ab1InstMemory.tags.ab1FocusData;\nlet xMod = [0, 3, 3, 3, 3, 6];\nlet yMod = [0, 0, -3, 0, -3, -3];\nlet newBot = {}\n\nnewBot.creator = null;\nnewBot[positionInfo.dimension] = true;\nnewBot.dimension = positionInfo.dimension;\nnewBot.scaleZ = 0.01;\nnewBot.scale = 0.61;\nnewBot.color = \"clear\";\nnewBot.strokeColor = \"#5E5880\";\nnewBot.lineColor = \"#5E5880\";\nnewBot.trackPrimitive = true;\nnewBot.anchorPoint = \"center\";\nnewBot.duration = 1;\nnewBot.easingType = \"linear\";\nnewBot.easingMode = \"inout\";\nnewBot.onClick = \"@ shout('ab1TrackMenu', {id: thisBot.id, clickInfo: that});\";\n\nfor (let i = 0; i < 3; i++)\n{\n    let xPos1 = positionInfo.x + xMod[i];\n    let yPos1 = positionInfo.y + yMod[i];\n    let xPos2 = positionInfo.x + xMod[i+3];\n    let yPos2 = positionInfo.y + yMod[i+3];\n    let pairUUID = uuid();\n\n    newBot[positionInfo.dimension+\"X\"] = xPos1;\n    newBot[positionInfo.dimension+\"Y\"] = yPos1;\n    newBot.pairID = pairUUID;\n\n    let createBot1 = create(newBot);\n    let createBot2 = create(newBot, {lineTo: createBot1.id, pairBot: createBot1.id, [positionInfo.dimension+\"X\"]: xPos2, [positionInfo.dimension+\"Y\"]: yPos2, lineStyle: \"line\"});\n\n    createBot1.tags.lineTo = createBot2.id;\n    createBot1.tags.pairBot = createBot2.id;\n    createBot1.tags.lineStyle = \"line\";\n\n    let createLogic = `@\nlet botID = getID(thisBot);\nlet pairBot = getBot(byMod({pairID: tags.pairID}), not(byTag(\"id\", botID)));\n\ntags.lineTo = pairBot.id;\ntags.pairBot = pairBot.id;`;\n\n    createBot1.tags.onEggHatch = createLogic;\n    createBot2.tags.onEggHatch = createLogic;\n}\n\nshout(\"ab1Refresh\");","ab1ToolBoxSkill":"true","ab1TrackEasingMenu":"@if (os.getMenuDimension() != null)\n{\n    setTagMask(ab1InstMemory, \"previousMenu\", os.getMenuDimension());\n}\n\nconfigBot.tags.menuPortal = \"ab1Menu\";\n\nshout(\"trackMenuReset\");\n\nlet botColor = \"#000000\";//getBot(\"id\", that).tags.color;\nlet easingArray = [\"linear\", \"quadratic\", \"cubic\", \"quartic\", \"quintic\", \"sinusoidal\", \"exponential\", \"circular\", \"elastic\"];\n\nfor (let i = 0; i < easingArray.length; i++)\n{\n    let menuButton = {};\n\n    menuButton.space = \"tempLocal\";\n    menuButton.ab1Menu = true;\n    menuButton.ab1MenuSortOrder = i;\n    menuButton.ab1MenuReset = \"@ destroy(thisBot);\";\n    menuButton.trackMenuReset = \"@ destroy(thisBot);\";\n    menuButton.menuItemStyle = `ðŸ§¬ {\"border-radius\": \"9px 9px 9px 9px\", \"margin-top\": \"6px\"}`;\n    menuButton.ab1Click = \"@ destroy(thisBot);\";\n    menuButton.labelAlignment = \"left\";\n    menuButton.labelColor = \"white\";  \n    menuButton.targetBot = that; \n    menuButton.label = easingArray[i];\n    menuButton.type = easingArray[i];\n    menuButton.color = botColor;\n    menuButton.info = \"easingType\";\n    menuButton.formAddress = \"arrow_right\"; \n    menuButton.onClick = `@ let targetBot = getBot('id', tags.targetBot);\n   \n    shout('updateTrackNode', {bot: tags.targetBot, changeType: tags.info, input: tags.type});\n   \n   shout('ab1Refresh');`;\n    \n    create(menuButton);\n}","ab1TrackEasingModeMenu":"@if (os.getMenuDimension() != null)\n{\n    setTagMask(ab1InstMemory, \"previousMenu\", os.getMenuDimension());\n}\n\nconfigBot.tags.menuPortal = \"ab1Menu\";\n\nshout(\"trackMenuReset\");\n\nlet botColor = \"#000000\";//getBot(\"id\", that).tags.color;\nlet modeArray = [\"in\", \"out\", \"inout\"];\n\nfor (let i = 0; i < modeArray.length; i++)\n{\n    let menuButton = {};\n\n    menuButton.space = \"tempLocal\";\n    menuButton.ab1Menu = true;\n    menuButton.ab1MenuSortOrder = i;\n    menuButton.ab1MenuReset = \"@ destroy(thisBot);\";\n    menuButton.trackMenuReset = \"@ destroy(thisBot);\";\n    menuButton.menuItemStyle = `ðŸ§¬ {\"border-radius\": \"9px 9px 9px 9px\", \"margin-top\": \"6px\"}`;\n    menuButton.ab1Click = \"@ destroy(thisBot);\";\n    menuButton.labelAlignment = \"left\";\n    menuButton.labelColor = \"white\";  \n    menuButton.targetBot = that; \n    menuButton.label = modeArray[i];\n    menuButton.type = modeArray[i];\n    menuButton.color = botColor;\n    menuButton.info = \"easingMode\";\n    menuButton.formAddress = \"arrow_right\"; \n    menuButton.onClick = `@ let targetBot = getBot('id', tags.targetBot);\n   \n    shout('updateTrackNode', {bot: tags.targetBot, changeType: tags.info, input: tags.type});\n   \n   shout('ab1Refresh');`;\n    \n    create(menuButton);\n}","ab1TrackMenu":"@if (os.getMenuDimension() != null)\n{\n    setTagMask(ab1InstMemory, \"previousMenu\", os.getMenuDimension());\n}\n\nconfigBot.tags.menuPortal = \"ab1Menu\";\n\nshout(\"trackMenuReset\");\n\nlet botColor = \"#000000\";//getBot(\"id\", that).tags.color;\n\nfor (let i = 0; i < 3; i++)\n{\n    let menuButton = {};\n\n    menuButton.space = \"tempLocal\";\n    menuButton.ab1Menu = true;\n    menuButton.ab1MenuSortOrder = i;\n    menuButton.ab1MenuReset = \"@ destroy(thisBot);\";\n    menuButton.trackMenuReset = \"@ destroy(thisBot);\";\n    menuButton.menuItemStyle = `ðŸ§¬ {\"border-radius\": \"9px 9px 9px 9px\", \"margin-top\": \"6px\"}`;\n    menuButton.ab1Click = \"@ destroy(thisBot);\";\n    menuButton.labelAlignment = \"left\";\n    menuButton.labelColor = \"white\";  \n    menuButton.targetBot = that.id;  \n    menuButton.onClick = `@ let targetBot = getBot('id', tags.targetBot);\n\n   let input = await os.showInput(targetBot.tags[tags.info],{\n       title: tags.label \n   });\n   \n   if (input)\n   {\n    shout('updateTrackNode', {bot: tags.targetBot, changeType: tags.info, input: input});\n   }\n   \n   shout('ab1Refresh');`;\n    \n    if (i == 0)\n    {\n        menuButton.label = \"duration\";\n        menuButton.color = botColor;\n        menuButton.info = \"duration\";\n        menuButton.formAddress = \"av_timer\";\n    }\n    else if ( i == 1)\n    {\n        menuButton.label = \"easing type\";\n        menuButton.color = botColor;\n        menuButton.info = \"easingType\";\n        menuButton.formAddress = \"trending_flat\";\n        menuButton.onClick = `@ shout('ab1TrackEasingMenu', tags.targetBot);`;\n    }\n    else if(i == 2)\n    {\n        menuButton.label = \"easing mode\";\n        menuButton.color = botColor;\n        menuButton.info = \"easingMode\";\n        menuButton.formAddress = \"trending_up\";\n        menuButton.onClick = `@ shout('ab1TrackEasingModeMenu', tags.targetBot);`;\n    }\n\n    create(menuButton);\n}\n\nshout(\"ab1GuideHideButton\");\n\n//check if the track has mods\nlet trackBot = getBot(\"id\", that.id);\n\nif (trackBot.tags.mods)\n{\n    shout(\"ab1TrackModMenu\", that);\n}","ab1TrackModMenu":"@let trackBot = getBot(\"id\", that.id);\nlet currentDim = that.clickInfo.dimension;\nlet newBot = {};\n\nnewBot.space = \"tempLocal\"\nnewBot.form = \"helix\";\nnewBot.scale = 0.5;\nnewBot.scaleZ = 1.61;\nnewBot.color = \"#5E5880\";\nnewBot[currentDim] = true;\nnewBot[currentDim + \"X\"] = trackBot.tags[currentDim+\"X\"];\nnewBot[currentDim + \"Y\"] = trackBot.tags[currentDim+\"Y\"];\nnewBot.ab1MenuReset = \"@ destroy(thisBot);\";\nnewBot.trackMenuReset = \"@ destroy(thisBot);\";\nnewBot.mods = trackBot.tags.mods;\nnewBot.target = that.id;\nnewBot.onDrop = `@ shout('ab1Refresh');\nshout('updateTrackNode', {bot: tags.target, changeType: \"mods\", input: null});\nshout('updateTrackNode', {bot: tags.target, changeType: \"form\", input: null});\nshout('updateTrackNode', {bot: tags.target, changeType: \"formAddress\", input: null});\nshout('updateTrackNode', {bot: tags.target, changeType: \"color\", input: \"clear\"});\n\ncreate(thisBot, {onClick:\"@ shout('ab1GuideHideButton'); shout('ab1ModMenuButton', thisBot.id);\", modPrimitive: true, target: null, onDrop: null, ab1MenuReset: null, trackMenuReset: null});`;\n\ncreate(newBot);","ab1UpdateID":"e8bcd23c-ec60-4bdc-bf05-0a2086d292af","ab1X":-13,"ab1Y":0,"ab1Z":0,"abIDOrigin":"ab1ToolBox","animateTrack":"@let animatingBot = that.bot;\nlet currentDim = that.dimension;\nlet nodePosX = animatingBot.tags[currentDim+\"X\"];\nlet nodePosY = animatingBot.tags[currentDim+\"Y\"];\n\nif(animatingBot.tags.lastNode)\n{\n    var lastNode = animatingBot.tags.lastNode;\n}\nelse\n{\n    var lastNode = 1;\n}\n\nlet trackNodes = getBots(byMod({\n    trackPrimitive: true, \n    [currentDim]: true, \n    [currentDim+\"X\"]: x => x < nodePosX + 0.25 && x > nodePosX - 0.25, \n    [currentDim+\"Y\"]: y => y < nodePosY + 0.25 && y > nodePosY - 0.25\n    }), not(byMod({id: lastNode})));\n\n//CHECK to See if other end meets criteria\nfor (let i = 0; i < trackNodes.length; i++)\n{\n    let currentNode = trackNodes[i];\n    let nodeConnection = getBot(\"id\", currentNode.tags.pairBot);\n\n    if (nodeConnection.tags[currentDim] != true)\n    {\n        trackNodes.splice(i, 1);\n    }\n}\n\nif (trackNodes.length == 0)\n{\n    var targetNodeEnd = getBot(\"id\", animatingBot.tags.lastNode);\n    let targetNodeID = targetNodeEnd.tags.pairBot;\n    var targetNode = getBot(\"id\", targetNodeID);\n    whisper(animatingBot, \"onTrackEnd\", that);\n}\nelse\n{\n    let randomizer = math.randomInt(0, trackNodes.length);\n    var targetNodeEnd = trackNodes[randomizer];\n    let targetNodeID = targetNodeEnd.tags.pairBot;\n    var targetNode = getBot(\"id\", targetNodeID);\n    whisper(animatingBot, \"onTrackChange\", that);\n}\n\nif (targetNodeEnd)\n{\n    setTagMask(animatingBot, \"lastNode\", targetNode.id);\n}\n\nif (!animatingBot.tags.trackInterval)\n{\n    setTagMask(animatingBot, \"trackDimension\", currentDim);\n    setTagMask(animatingBot, \"previousInterval\", targetNodeEnd.tags.duration*1000+50);\n    setTagMask(animatingBot, \"onDrag\", \"@ clearInterval(tags.interval); clearTagMasks(thisBot);\");\n    setTagMask(animatingBot, \"trackInterval\", `@ masks.interval = setInterval(() => {shout(\"animateTrack\", {bot: thisBot, dimension: tags.trackDimension});}, ${targetNodeEnd.tags.duration*1000+50}); whisper(thisBot, \"interval\");`);\n}\nelse if (animatingBot.tags.previousInterval != targetNodeEnd.tags.duration * 1000 + 50)\n{\n    await clearInterval(animatingBot.tags.interval);\n\n    setTagMask(animatingBot, \"trackInterval\", `@ masks.interval = setInterval(() => {shout(\"animateTrack\", {bot: thisBot, dimension: tags.trackDimension});}, ${targetNodeEnd.tags.duration*1000+50}); whisper(thisBot, \"interval\");`);\n    setTagMask(animatingBot, \"previousInterval\", targetNodeEnd.tags.duration*1000+50);\n    \n    var changeInterval = true;\n}\n\nif (that.initial || changeInterval)\n{\n    whisper(animatingBot, \"trackInterval\");\n}\n\nif (targetNodeEnd.tags.mods)\n{\n    applyMod(animatingBot, targetNodeEnd.tags.mods);\n}\n\nawait animateTag(animatingBot, {\n    fromValue:{\n        [currentDim+\"X\"]: nodePosX,\n        [currentDim+\"Y\"]: nodePosY\n    },\n    toValue:{\n        [currentDim+\"X\"]: targetNode.tags[currentDim+\"X\"],\n        [currentDim+\"Y\"]: targetNode.tags[currentDim+\"Y\"]\n    },\n    //tagMaskSpace: false,\n    duration: targetNodeEnd.tags.duration || 1,\n    easing: {\n        type: targetNodeEnd.tags.easingType,\n        mode: targetNodeEnd.tags.easingMode\n    }\n}).catch(e => {console.log(e)});\n\nanimatingBot.tags[currentDim+\"X\"] = targetNode.tags[currentDim+\"X\"];\nanimatingBot.tags[currentDim+\"Y\"] = targetNode.tags[currentDim+\"Y\"];","auxCodeOrigin":"ab1ToolBox","color":"#55E679","destroyable":false,"onAnyBotDrag":"@let currentDim = that.from.dimension;\nlet nodePosX = that.from.x;\nlet nodePosY = that.from.y;\nlet trackNodes = getBots(byMod({\n    trackPrimitive: true, \n    [currentDim]: true, \n    [currentDim+\"X\"]: x => x < nodePosX + 0.25 && x > nodePosX - 0.25, \n    [currentDim+\"Y\"]: y => y < nodePosY + 0.25 && y > nodePosY - 0.25\n}));\n\nif (os.getInputState(\"keyboard\", \"Shift\") && that.bot.tags.trackPrimitive)\n{\n    shout(\"ab1Refresh\");\n\n    let pairUUID = uuid();\n    let newBot = {}\n\n    newBot.creator = null;\n    newBot[currentDim] = true;\n    newBot[currentDim+\"X\"] = that.from.x;\n    newBot[currentDim+\"Y\"] = that.from.y;\n    newBot.dimension = currentDim;\n    newBot.scaleZ = 0.01;\n    newBot.scale = 0.61;\n    newBot.color = \"clear\";\n    newBot.strokeColor = \"#5E5880\";\n    newBot.lineColor = \"#5E5880\";\n    newBot.trackPrimitive = true;\n    newBot.anchorPoint = \"center\";\n    newBot.duration = 1;\n    newBot.easingType = \"linear\";\n    newBot.easingMode = \"inout\";\n    newBot.onClick = \"@ shout('ab1TrackMenu', {id: thisBot.id, clickInfo: that});\";\n    newBot.pairID = pairUUID;\n\n    let createBot1 = create(newBot);\n    let createBot2 = create(newBot, {lineTo: createBot1.id, pairBot: createBot1.id, lineStyle: \"line\"});\n\n    createBot1.tags.lineTo = createBot2.id;\n    createBot1.tags.pairBot = createBot2.id;\n    createBot1.tags.lineStyle = \"line\";\n\n    let createLogic = `@\n    let botID = getID(thisBot);\n    let pairBot = getBot(byMod({pairID: tags.pairID}), not(byTag(\"id\", botID)));\n\n    tags.lineTo = pairBot.id;\n    tags.pairBot = pairBot.id;`;\n\n    createBot1.tags.onEggHatch = createLogic;\n    createBot2.tags.onEggHatch = createLogic;\n\n    os.replaceDragBot(createBot2);\n}","onAnyBotDrop":"@if (that.to.bot && !that.dragBot.tags.ab1ID)\n{\n    if (that.to.bot.tags.trackPrimitive)\n    {\n        if (that.dragBot.tags.trackPrimitive)\n        {\n            that.dragBot.tags[that.to.dimension + \"Z\"] = that.to.bot.tags[that.to.dimension + \"Z\"];\n            that.dragBot.tags.duration = that.to.bot.tags.duration;\n            that.dragBot.tags.easingMode = that.to.bot.tags.easingMode;\n            that.dragBot.tags.easingType = that.to.bot.tags.easingType;\n        }\n        else if (!that.dragBot.tags.modPrimitive)\n        {\n            if (that.dragBot.tags.primitiveID)\n            {\n                setTagMask(that.dragBot, \"onPointerExit\", false);\n            }\n\n            whisper(thisBot, \"animateTrack\", {bot:that.dragBot, dimension: that.to.dimension, initial: true});\n            whisper(that.dragBot, \"onTrackStart\", that);\n        }\n    }\n}","scale":1,"scaleX":"0.8","scaleY":"0.8","scaleZ":"1.6","strokeColor":"orange","system":"ab1.toolBox.createTrack","trackPrimitiveHide":"@let trackNodes = getBots(\"trackPrimitive\", true);\n\nshout(\"ab1Refresh\");\n\nif (that == \"show\")\n{\n    clearTagMasks(trackNodes);\n    clearTagMasks(thisBot);\n    shout(\"modPrimitiveHide\", \"show\");\n}\nelse\n{\n    setTagMask(trackNodes, \"color\", \"clear\");\n    setTagMask(trackNodes, \"lineTo\", \"null\");\n    setTagMask(trackNodes, \"pointable\", false);\n    setTagMask(thisBot, \"trackHidden\", true);\n    shout(\"modPrimitiveHide\");\n}","updateTrackNode":"@let targetBot = getBot(\"id\", that.bot);\nlet currentDim = targetBot.tags.dimension;\nlet nodePosX = targetBot.tags[currentDim + \"X\"];\nlet nodePosY = targetBot.tags[currentDim + \"Y\"];\nlet trackNodes = getBots(byMod({\n    trackPrimitive: true, \n    [currentDim]: true, \n    [currentDim+\"X\"]: x => x < nodePosX + 0.25 && x > nodePosX - 0.25, \n    [currentDim+\"Y\"]: y => y < nodePosY + 0.25 && y > nodePosY - 0.25\n    }));\n\nsetTag(trackNodes, that.changeType, that.input);","onGridDown":null}},"bad435b6-f0bc-4886-a905-07326ae5d345":{"id":"bad435b6-f0bc-4886-a905-07326ae5d345","space":"shared","tags":{"ab1Factory":true,"ab1ID":"botStoreTemplate","ab1ToolBoxID":"botStore","abIDOrigin":"librarianExample01","botStore":null,"botStoreStorageCurrent":0,"botStoreStorageMax":1,"color":"#908BFC","createLinks":"@tags.otherBotStores = getLink(that);\n\nos.vars.botStoreLead = thisBot;","factoryIcon":"inventory_2","form":"sphere","home":null,"homeX":-4,"homeY":3,"homeZ":0,"identifyLeadBotStore":"@let botStoreBots = getBots(\"botStore\");\n\nif (botStoreBots[0].id == thisBot.id)\n{\n    whisper(thisBot, \"inheritBotStoreLead\", botStoreBots);\n}\nelse if (tags.botStore == \"lead\")\n{\n    tags.botStore = true;\n    clearInterval(tags.interval);\n    clearTagMasks(thisBot);\n}","inheritBotStoreLead":"@let botStoreBots = that;\n\ntags.botStore = \"lead\";\n\nwhisper(thisBot, \"createLinks\", botStoreBots);\n\nwhisper(thisBot, \"intervalSetup\");","intervalSetup":"@if (!tags.interval)\n{\n    masks.interval = setInterval(() => whisper(getBots('ab1ToolBoxID', 'botStore'),'templateAnimate'), 2000);\n}","label":"0","listening":false,"onBotChanged":"@let botStorageChange = that.tags.includes(\"botStoreStorageCurrent\");\n\nif (botStorageChange)\n{\n    if (!tags.botStoreStorageCurrent)\n    {\n        tags.label = \"0\";\n    }\n    else\n    {\n        tags.label = tags.botStoreStorageCurrent;\n    }\n}","onClick":"@shout(\"ab1MenuReset\");\n\nconfigBot.masks.menuPortal = \"ab1Menu\";\n\nlet menuButton = {};\n\nmenuButton.ab1MenuReset = \"@ destroy(thisBot);\";\nmenuButton.ab1Click = \"@ destroy(thisBot);\";\nmenuButton.ab1Menu = true;\nmenuButton.label = \"unlimited\";\nmenuButton.formAddress = \"file_copy\";\nmenuButton.onClick = `@ let targetBot = getBot('id',\"${thisBot.id}\");\n\ntargetBot.tags.botStoreStorageMax = null;\ntargetBot.tags.botStoreStorageCurrent = null;\ntargetBot.tags.label = null;\n\nshout('ab1Refresh');`;\n\nwhisper(ab1Command, 'ab1GenerateMenuButton', menuButton);\n\nmenuButton.label = \"limited\";\nmenuButton.formAddress = \"inventory\";\n//FIGURE THIS OUT \nmenuButton.onClick = `@ let targetBot = getBot('id',\"${thisBot.id}\");\n\nconst number = await os.showInput(1, {\n    title: 'choose max'\n});\n\ntargetBot.tags.botStoreStorageMax = number;\n\nif (links.template)\n{\n    targetBot.tags.botStoreStorageCurrent = 1;\n    targetBot.tags.label = 1;\n}\nelse\n{\n    targetBot.tags.botStoreStorageCurrent = 0;\n    targetBot.tags.label = 0;\n}\n\nshout('ab1Refresh');`;\n\nwhisper(ab1Command, 'ab1GenerateMenuButton', menuButton);\n\nif (getBot(\"transformer\", thisBot.id));\n{\n    if (tags.templateLock)\n    {\n        menuButton.formAddress = \"lock\";\n    }\n    else\n    {\n        menuButton.formAddress = \"lock_open\";\n    }\n    \n    menuButton.label = \"  \";\n    menuButton.labelAlignment = \"center\";\n    menuButton.onClick = `@ let targetBot = getBot('id',\"${thisBot.id}\");\n\n    if (targetBot.tags.templateLock)\n    {\n        targetBot.tags.templateLock = null;\n        tags.formAddress = \"lock_open\";\n    }\n    else\n    {\n        targetBot.tags.templateLock = true;\n        tags.formAddress = \"lock\";\n    }`;\n\n    whisper(ab1Command, 'ab1GenerateMenuButton', menuButton);\n}","onCreate":"@tags.botStore = true;\n\nlet botStoreLead = getBot(\"botStore\", \"lead\");\n\nif (!botStoreLead)\n{\n    shout(\"identifyLeadBotStore\");\n}\nelse\n{\n    whisper(botStoreLead, \"onInstStreaming\");\n}","onDestroy":"@let newArray = getBots(\"botStore\");\nlet target = newArray.findIndex(distBot => distBot.id == thisBot.id);\n\nnewArray.splice(target, 1);\n\nif (tags.botStore == \"lead\")\n{\n    whisper(links.otherBotStores[1], \"inheritBotStoreLead\", newArray);\n}\nelse\n{\n    let botStoreLead = getBot(\"botStoreLead\");\n\n    whisper(botStoreLead, \"createLinks\", newArray);\n}\n\nclearInterval(tags.interval);","onDrop":"@if (that.dragBot.id == thisBot.id)\n{\n    return;\n}\n\nif (tags.templateLock || that.dragBot.tags.ab1ID)\n{\n    returnBot(that.dragBot);\n\n    return;\n}\n\nif (that.to.bot.id == thisBot.id || that.passThrough)\n{\n\n    if (!links.template)\n    {\n        if (tags.template)\n        {\n            destroy(links.template);\n        }\n\n        tags.template = getLink(that.dragBot);\n\n        whisper(thisBot, \"templateSetup\", that);\n    }\n    else if (that.dragBot.tags.botType == links.template.tags.botType && tags.botStoreStorageMax > tags.botStoreStorageCurrent)\n    {\n        tags.botStoreStorageCurrent++;\n\n        destroy(that.dragBot);\n    }\n    else\n    {\n        console.log(35)\n        returnBot(that.dragBot);\n    }\n}\n\nfunction returnBot (botToReturn)\n{\n    botToReturn.tags[that.from.dimension] = true;\n    botToReturn.tags[that.from.dimension+\"X\"] = that.from.x;\n    botToReturn.tags[that.from.dimension+\"Y\"] = that.from.y;\n    botToReturn.tags[that.from.dimension+\"Z\"] = that.from.z;\n}","onEggHatch":"@whisper(thisBot, \"onInstStreaming\");","onInstStreaming":"@if (tags.botStore == \"lead\")\n{\n    let botStoreBots = getBots(\"botStore\");\n\n    if (botStoreBots[0].id == thisBot.id)\n    {\n        thisBot.intervalSetup();\n\n        whisper(thisBot, \"createLinks\", botStoreBots);\n    }\n    else\n    {\n        shout(\"identifyLeadBotStore\");\n    }\n}","otherBotStores":"ðŸ”—2c82862d-3eea-43bf-ae39-496b9bc6ef8f","resetTemplate":"@if (links)\n{\n    destroy(links.template);\n}\n\ntags.template = null;","scale":2,"scaleZ":0.01,"system":"ab1.factory.botStore","template":"ðŸ”—9d3f48fc-6219-4694-9cd9-c6ff4b7e732b","templateAnimate":"@if (links.template)\n{\n    let zRot = configBot.tags.gridPortal + \"RotationZ\";\n    let pi = 360 * Math.PI / 180;\n\n    await animateTag(links.template, zRot, {\n        fromValue: 0,\n        toValue: pi,\n        duration: 2\n    }).catch(e => {});\n}","templateSetup":"@let currentDim = that.to.dimension;\nlet xScale = links.template.scaleX ? links.template.scaleX : 1;\nlet yScale = links.template.scaleY ? links.template.scaleY : 1;\nlet zScale = links.template.scaleZ ? links.template.scaleZ : 1;\n\nlinks.template.tags.listening = false;\nlinks.template.tags.pointable = false;\nlinks.template.tags.creator = thisBot.id;\nlinks.template.tags.transformer = thisBot.id;\nlinks.template.tags[currentDim + \"X\"] = 0;\nlinks.template.tags[currentDim + \"Y\"] = 0;\nlinks.template.tags[currentDim + \"Z\"] = 30;\nlinks.template.tags.scaleX = xScale / 2;\nlinks.template.tags.scaleY = yScale / 2;\nlinks.template.tags.scaleZ = zScale * 50;\n\nlet secondaryLink = getLink(links.template);\n\nlet hitBox = {};\n\nhitBox.transformer = thisBot.id;\nhitBox.creator = links.template.id;\nhitBox.template = secondaryLink;\nhitBox.color = \"clear\";\n\nif (tags.botStoreStorageMax)\n{\n    tags.botStoreStorageCurrent++;\n}\n\nhitBox.onDrag = `@ let newBot = {};\n\nnewBot.listening = true;\nnewBot.pointable = true;\nnewBot.transformer = null;\nnewBot.creator = null;\nnewBot.scaleX = links.template.tags.scaleX * 2;\nnewBot.scaleY = links.template.tags.scaleY * 2;\nnewBot.scaleZ = links.template.tags.scaleZ / 50;\n\nlet createdBot = create(links.template, newBot);\n\nos.replaceDragBot(createdBot);\n\nlet store = getBot(\"id\", tags.transformer);\n\nif (store.tags.botStoreStorageMax)\n{\n    store.tags.botStoreStorageCurrent--;\n};\n\nif (store.tags.botStoreStorageCurrent <= 0)\n{  \n    destroy(links.template);\n}`;\n\nhitBox.draggable = false;\nhitBox[currentDim] = true;\nhitBox[currentDim + \"X\"] = 0;\nhitBox[currentDim + \"Y\"] = 0;\nhitBox[currentDim + \"Z\"] = 30;\nhitBox.scaleX = xScale / 2;\nhitBox.scaleY = yScale / 2;\nhitBox.scaleZ = zScale * 50;\n\ncreate(hitBox);\n\nif (tags.botStoreStorageMax)\n{\n    tags.botStoreStorageCurrent = 1;\n}\n\nif (tags.interval == null)\n{\n    whisper(thisBot, \"intervalCheck\");\n}","auxCodeOrigin":"ab1ToolBox"}},"c267e935-ac8a-412e-b25c-36a71d3aab74":{"id":"c267e935-ac8a-412e-b25c-36a71d3aab74","space":"shared","tags":{"ab1":true,"ab1EditPadMenu":"@let selectedBot = getBot(\"id\", that);\nlet possibleLocations = selectedBot.tags.abArray;\nlet color = selectedBot.tags.color;\n\n//let labelColor = await whisper(thisBot, \"avatarLabelColor\", selectedBot.tags.color)[0];\n\nconfigBot.tags.menuPortal = \"ab1PadMenu\";\n\nlet menuDim = configBot.tags.menuPortal;\n\nif (possibleLocations) \n{\n    let previousPadButtons = getBots(\"primitiveID\", \"padButton\");\n\n    destroy(previousPadButtons);\n\n    for (let i = 0; i < possibleLocations.length; i++) \n    {\n        let currentPath = possibleLocations[i];\n\n        shout(\"padABButton\", { label: currentPath, color: color, targetBot: selectedBot.id, targetPath: currentPath, menuDim: menuDim});\n    }\n}\n\nlet newAbButton = {};\n\nnewAbButton.space = \"tempLocal\";\nnewAbButton.dimension = menuDim;\nnewAbButton[menuDim] = true;\nnewAbButton[menuDim + \"SortOrder\"] = -1;\nnewAbButton.formAddress = \"meeting_room\";\nnewAbButton.label = \"+\";\nnewAbButton.form = \"input\";\nnewAbButton.color = color;\n//newAbButton.labelColor = labelColor;\nnewAbButton.targetBot = selectedBot.id;\n//New logic for portals\nnewAbButton.onSubmit = `@ let selectedBot = getBot('id', tags.targetBot);\n    clearTagMasks(thisBot);\n\n    if (selectedBot.tags.abArray)\n    {\n        var possibleLocations = selectedBot.tags.abArray;\n    }\n    else\n    {\n        var possibleLocations = [];\n    }\n\n    if (that.text)\n    {\n        let newABName = that.text;\n        let colonCheck = newABName.lastIndexOf(\":\");\n\n        if (colonCheck > -1)\n        {\n            let portalType = newABName.slice(0, colonCheck);\n            let portalAddress = newABName.slice(colonCheck+1);\n            let portal = RegExp(/Portal/);\n            let shoutCommand = RegExp(/shout/);\n            let portalCheck = portal.test(portalType);\n            let shoutCheck = shoutCommand.test(portalType);\n            console.log(portal)\n            if (portalCheck)\n            {\n                var newDestination = newABName;\n            }\n            else if (shoutCheck)\n            {\n                var newDestination = newABName;\n            }\n            else\n            {\n                os.toast(\"invalid portal type\");\n                return;\n            }\n        }\n        else\n        {\n            let auxCodeCheck = await shout(\"auxCodeSearch\", {auxCode: newABName, check: true})[0];\n\n            if (!auxCodeCheck)\n            {\n                os.toast(\"no auxCode found\");\n                return;\n            }\n            else\n            {\n                var newDestination = newABName;\n            }\n        }\n    }\n\n    possibleLocations.push(newDestination);\n\n    let newArray = possibleLocations.slice();\n\n    selectedBot.tags.abArray = newArray;\n\n    shout(\"padABButton\", { label: newDestination, color: tags.color, targetBot: tags.targetBot, targetPath: newDestination, menuDim: tags.dimension});`;\nnewAbButton.ab1Refresh = \"@ destroy(thisBot);\";\nnewAbButton.menuItemStyle = `ðŸ§¬ {\"border-radius\": \"9px 9px 9px 9px\", \"margin-top\": \"6px\"}`;\nnewAbButton.labelAlignment = \"left\"; \n\ncreate(newAbButton);\n\nlet newDestinationScan = {};\n\nnewDestinationScan.space = \"tempLocal\";\nnewDestinationScan[menuDim] = true;\nnewDestinationScan[menuDim + \"SortOrder\"] = 50;\nnewDestinationScan.dimension = menuDim;\nnewDestinationScan.formAddress = \"qr_code_scanner\";\nnewDestinationScan.label = \"    \";\nnewDestinationScan.color = color;\n//newDestinationScan.labelColor = labelColor;\nnewDestinationScan.targetBot = selectedBot.id;\nnewDestinationScan.padPaths = true;\nnewDestinationScan.onClick = \"@ os.openQRCodeScanner();\"\nnewDestinationScan.onQRCodeScanned = `@ let selectedBot = getBot('id', tags.targetBot);\n    os.closeQRCodeScanner();\n    \n    if (selectedBot.tags.abArray)\n    {\n        var possibleLocations = selectedBot.tags.abArray;\n    }\n    else\n    {\n        var possibleLocations = [];\n    }\n\n    if (that)\n    {\n        let auxCodeCheck = await shout(\"auxCodeSearch\", {auxCode: that, check: true})[0];\n\n        if (!auxCodeCheck)\n        {\n            os.toast(\"no auxCode found\");\n            return;\n        }\n        else\n        {\n            var newDestination = that;\n        }\n    }\n\n    possibleLocations.push(newDestination);\n\n    let newArray = possibleLocations.slice();\n\n    selectedBot.tags.abArray = newArray;\n\n    shout(\"padABButton\", { label: newDestination, color: tags.color, targetBot: tags.targetBot, targetPath: newDestination, menuDim: tags.dimension});`;\nnewDestinationScan.ab1Refresh = \"@ destroy(thisBot);\";\nnewDestinationScan.menuItemStyle = `ðŸ§¬ {\"border-radius\": \"9px 9px 9px 9px\", \"margin-top\": \"6px\"}`;\nnewDestinationScan.labelAlignment = \"center\"; \n\ncreate(newDestinationScan);","ab1ID":"createPad","ab1Icon":"meeting_room","ab1MenuLabel":"pad","ab1MenuLabelBotFocus":"edit pad","ab1MenuLabelGridFocus":"pad","ab1Refresh":"@clearTagMasks(thisBot);","ab1Skill":"true","ab1ToolBoxAction":"@let positionInfo = ab1InstMemory.tags.ab1FocusData;\nlet newBot = {}\n\nnewBot.creator = null;\nnewBot[positionInfo.dimension] = true;\nnewBot[positionInfo.dimension+\"X\"] = positionInfo.x;\nnewBot[positionInfo.dimension+\"Y\"] = positionInfo.y;\nnewBot[positionInfo.dimension+\"Z\"] = 0;\nnewBot.color = \"#7B64FF\";\nnewBot.primitiveID = \"pad\";\nnewBot.dimension = positionInfo.dimension;\nnewBot.form = \"hex\";\nnewBot.scale = 1.5;\nnewBot.scaleZ = 0.01;\nnewBot.onClick = getBot(\"ab1ID\", \"createPad\").tags.padClick;\nnewBot.onPointerEnter = \"@ masks.scale = tags.scale + 0.1;\";\nnewBot.onPointerExit = \"@ clearTagMasks(thisBot);\";\n\nlet createBot = create(newBot);\n\nshout(\"ab1Refresh\");","ab1ToolBoxSkill":"true","ab1UpdateID":"cbaa7d5f-37bf-4128-94ca-87f8e1595dab","ab1X":-7,"ab1Y":0,"ab1Z":0,"abDeleteButton":"@let currentButton = getBot(\"primitiveID\", \"deletePath\");\nlet menuDim = os.getMenuDimension();\nlet selectedBots = getBots(\"selectedAB\", true);\n\n//console.log(currentButton, selectedBots)\n\nif (!currentButton && selectedBots.length > 0)\n{\n    let newDeleteButton = {};\n\n    newDeleteButton.space = \"tempLocal\";\n    newDeleteButton[menuDim] = true;\n    newDeleteButton[menuDim + \"SortOrder\"] = 100;\n    newDeleteButton.label = \"   \";\n    newDeleteButton.formAddress = \"delete_outline\";\n    newDeleteButton.primitiveID = \"deletePath\";\n    newDeleteButton.color = \"#F44E3B\";\n    newDeleteButton.onClick = `@\n    let selectedBots = getBots(\"selectedAB\", true);\n\n    for (let i = 0; i < selectedBots.length; i++)\n    {\n        let currentAB = selectedBots[i];\n        let targetPath = currentAB.tags.targetPath;\n        let padBot = getBot(\"id\", currentAB.tags.targetBot);\n        let targetArray = padBot.tags.abArray;\n        \n        if (targetArray)\n        {\n            for (let j = 0; j < targetArray.length; j++)\n            {\n                let currentPath = targetArray[j];\n\n                if (targetPath == currentPath)\n                {\n                    targetArray.splice(j);\n                    break;\n                }\n                \n            }\n        }\n\n        destroy(currentAB);\n\n        if (!targetArray || targetArray.length == 0)\n        {\n            padBot.tags.abArray = null;\n            destroy(selectedBots);\n            break;\n        }\n        else\n        {\n            padBot.tags.abArray = targetArray;\n        }\n    }\n    destroy(thisBot);`;\n    newDeleteButton.ab1Refresh = \"@ destroy(thisBot);\";\n    newDeleteButton.menuItemStyle = `ðŸ§¬ {\"border-radius\": \"9px 9px 9px 9px\", \"margin-top\": \"6px\"}`;\n    newDeleteButton.labelAlignment = \"center\";\n\n    create(newDeleteButton);\n}\nelse if (currentButton && selectedBots.length == 0)\n{\n    destroy(currentButton);\n}","abIDOrigin":"ab1ToolBox","auxCodeOrigin":"ab1ToolBox","color":"#55E679","destroyable":false,"padABButton":"@let padButton = {}\n\npadButton.space = \"tempLocal\";\npadButton[that.menuDim] = true;\npadButton[that.menuDim + \"SortOrder\"] = 1;\npadButton.primitiveID = \"padButton\";\npadButton.label = that.label;\npadButton.color = that.color;\npadButton.targetBot = that.targetBot;\npadButton.targetPath = that.targetPath;\npadButton.formAddress = \"check_box_outline_blank\";\npadButton.labelAlignment = \"left\";\npadButton.onClick = `@ if (!tags.selectedAB){tags.selectedAB = true; masks.formAddress = 'check_box'} \nelse {tags.selectedAB = null; clearTagMasks(thisBot);}; \n\nshout(\"abDeleteButton\", thisBot.id);`;\npadButton.ab1Refresh = \"@ destroy(thisBot);\";\npadButton.menuItemStyle = `ðŸ§¬ {\"border-radius\": \"9px 9px 9px 9px\", \"margin-top\": \"6px\"}`;\n\ncreate(padButton);","padClick":"@let currentDim = tags.dimension;\nlet avatar = getBot(byMod({\"deckAvatar\": configBot.id, [currentDim]: true}));\n\nif (avatar)\n{\n    let padPositionX = tags[currentDim+\"X\"] + (Math.random(0, (tags.scale/3)) * (Math.random() < 0.5 ? -1 : 1));\n    let padPositionY = tags[currentDim+\"Y\"] + (Math.random(0, (tags.scale/3)) * (Math.random() < 0.5 ? -1 : 1));\n\n    if(!avatar.tags.animating)\n    {\n        setTagMask(avatar, \"animating\", true);\n\n        if (avatar.tags[configBot.tags.gridPortal] == true)\n        {\n            if (getBot(\"portalAddress\", configBot.tags.miniPortal))\n            {\n                configBot.tags.miniPortal = null;\n            }\n        }\n\n        configBot.tags.meetPortal = null;\n        configBot.tags.avatarCurrentDeck = null;\n\n        await animateTag(avatar, {\n            fromValue: {\n                [currentDim + \"X\"]: avatar.tags[currentDim + \"X\"],\n                [currentDim + \"Y\"]: avatar.tags[currentDim + \"Y\"],\n            },\n            toValue: {\n                [currentDim + \"X\"]: padPositionX,\n                [currentDim + \"Y\"]: padPositionY\n            },\n            tagMaskSpace: false,\n            duration: 0.5 //should make this more dynamic\n        });\n\n        clearTagMasks(avatar);\n    }\n}\n\nshout(\"padEnter\", thisBot.id);","padEnter":"@shout(\"ab1Refresh\");\n\nlet padBot = getBot(\"id\", that);\nlet color = padBot.tags.color;\nlet possibleLocations = padBot.tags.abArray;\nlet menuDim = os.getMenuDimension();\nlet avatar = getBot(byMod({\"deckAvatar\": configBot.id}));\n//let labelColor = await whisper(thisBot, \"openMapLabelColor\", color)[0];\n\nif(menuDim)\n{\n    ab1InstMemory.tags.previousMenu = menuDim;\n}\n\nmenuDim = \"ab1ABPadMenu\";\n\nconfigBot.tags.menuPortal = menuDim;\n\nif (possibleLocations)\n{\n    //need logic for portals\n\n    if (ab1InstMemory.tags.ab1SleepState == \"Awake\")\n    {\n        var ab1SleepState = \"&ab1Sleep=false\";\n    }\n    else\n    {\n        var ab1SleepState = \"&ab1Sleep=true\";\n    }\n\n    for (let i = 0; i < possibleLocations.length; i++)\n    {\n        //path buttons\n        var currentPath = possibleLocations[i];\n        var botLabel = currentPath;\n        let colonCheck = currentPath.lastIndexOf(\":\");\n\n        if (colonCheck > -1)\n        {\n            let portalType = currentPath.slice(0, colonCheck);\n            let portalAddress = currentPath.slice(colonCheck+1);\n\n            if(portalType == \"meetPortal\")\n            {\n                currentPath = \"@ meetPortalBot.tags.meetPortalAnchorPoint = 'top';\";\n            }\n            else if (portalType == \"miniPortal\")\n            {\n                currentPath = `@ miniPortalBot.tags.miniPortalHeight = 0.3; miniPortalBot.tags.miniPortalWidth = 1;`;\n            }\n            else\n            {\n                currentPath = null;\n            }\n            \n            if (portalType == \"shout\")\n            {\n                var padClick = `@ shout('ab1Refresh'); shout('${portalAddress}');`\n            }\n            else\n            {\n                var padClick = `@ configBot.tags.${portalType} = \"${portalAddress}\"; whisper(thisBot, 'targetPath'); shout('padJump', {dimension:'${portalAddress}', origin:'${that}'}); shout('ab1Refresh');`;\n            }\n        }\n        else\n        {\n            try \n            {\n                currentPath = \"https://casualos.com/?inst=\" + currentPath + configBot.tags.teamCode + \"&auxCode=\" + currentPath + \"&gridPortal=home&teamCode=\" + configBot.tags.teamCode + ab1SleepState; //\"&avatar=\" + openMapAvatar.tags.avatarCode \n            }\n            catch (error) \n            {\n                console.log(\"not a URL path\");\n            }\n\n            var padClick = `@ const state = os.getInputState(\"keyboard\", \"Shift\");\n                if (state) {\n                    os.openURL(tags.targetPath);\n                }\n                else{\n                    os.goToURL(tags.targetPath);\n                }`;\n        }\n\n        let pathButton = {}\n\n        pathButton.space = \"tempLocal\";\n        pathButton[menuDim] = true;\n        pathButton[menuDim + \"SortOrder\"] = 0;\n        pathButton.label = botLabel;\n        pathButton.color = color;\n        //pathButton.labelColor = labelColor;\n        pathButton.formAddress = \"meeting_room\";\n        pathButton.targetPath = currentPath;\n        pathButton.onClick = padClick;\n        pathButton.ab1Refresh = \"@ destroy(thisBot);\";\n        pathButton.menuItemStyle = `ðŸ§¬ {\"border-radius\": \"9px 9px 9px 9px\", \"margin-top\": \"6px\"}`;\n        pathButton.labelAlignment = \"left\";\n\n        create(pathButton);\n    }\n}\n\nlet shareButton = {};\n\nshareButton.space = \"tempLocal\";\nshareButton[menuDim] = true;\nshareButton[menuDim+\"SortOrder\"] = 100;\nshareButton.label = \"    \";\nshareButton.dimension = padBot.tags.dimension;\nshareButton.formAddress = \"ios_share\";\nshareButton.color = color;\n//shareButton.labelColor = labelColor;\nshareButton.ab1Refresh = \"@ destroy(thisBot);\";\nshareButton.menuItemStyle = `ðŸ§¬ {\"border-radius\": \"9px 9px 9px 9px\", \"margin-top\": \"6px\"}`;\nshareButton.labelAlignment = \"center\";\nshareButton.primitiveID = \"shareButton\";\nshareButton.targetBot = padBot.id;\nshareButton.onClick = `@\nlet inst = os.getCurrentInst();\n\nlet url = \"https://casualos.com/?inst=\"+inst+\"&gridPortal=\"+configBot.tags.gridPortal;\n\ntry{\n    await os.share({url: url});\n}\ncatch{\n    os.setClipboard(url);\n\n    os.toast(\"link copied to clipboard\");\n}`;\n\n//shareButton\ncreate(shareButton);\n\nshareButton[menuDim+\"SortOrder\"] = 99;\nshareButton.label = \"   \";\nshareButton.dimension = padBot.tags.dimension;\nshareButton.formAddress = \"edit\";\nshareButton.color = color;\n//shareButton.labelColor = labelColor;\nshareButton.ab1Refresh = \"@ destroy(thisBot);\";\nshareButton.menuItemStyle = `ðŸ§¬ {\"border-radius\": \"9px 9px 9px 9px\", \"margin-top\": \"6px\"}`;\nshareButton.labelAlignment = \"center\";\nshareButton.primitiveID = \"shareButton\";\nshareButton.targetBot = padBot.id;\nshareButton.onClick = `@ shout('ab1EditPadMenu', tags.targetBot);`;\n\n//edit button\ncreate(shareButton);\n\nif (avatar)\n{\n    avatar.tags.pad = padBot.id;\n\n    shout(\"padUpdate\", padBot.id);\n}","padUpdate":"@let pads = getBots(\"primitiveID\", \"pad\");\n\nfor (let i = 0; i < pads.length; i++)\n{\n    let currentPad = pads[i];\n    let padAvatars = getBots(\"pad\", currentPad.id).length;\n\n    if (padAvatars < 1)\n    {\n        padAvatars = 1.5;\n    }\n    else if (padAvatars == 1)\n    {\n        padAvatars = 1.75;\n    }\n\n    await animateTag(currentPad, {\n        fromValue: {\n            scale: currentPad.tags.scale,\n        },\n        toValue: {\n            scale: padAvatars\n        },\n        tagMaskSpace: false,\n        easing: \"elastic\",\n        duration: 0.3\n    });\n}","scale":1,"scaleX":"0.8","scaleY":"0.8","scaleZ":"1.6","strokeColor":"orange","system":"ab1.toolBox.createPad"}}}}