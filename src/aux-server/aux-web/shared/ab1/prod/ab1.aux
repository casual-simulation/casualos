{"version":1,"state":{"08fb0779-e95a-49db-aba1-f3c41add1f3e":{"id":"08fb0779-e95a-49db-aba1-f3c41add1f3e","space":"shared","tags":{"ab1":true,"scaleZ":"1.6","scaleY":"0.8","scaleX":"0.8","ab1UpdateID":"07901318-5cd0-4c69-996c-787f31987580","ab1SkillPositionCalculation":"@let skill = that.bots;\nlet sortedSkills = [];\n\nfor (let i = 0; i < skill.length; i++)\n{\n    let currentSkill = getBot(\"id\", skill[i].tags.originSkill);\n\n    if (skill[i].tags.weight)\n    {\n        var weightedSkill = {bot: skill[i], position: skill[i].tags.weight}\n    }\n    else\n    {\n        let xPos1 = tags.ab1X;\n        let yPos1 = tags.ab1Y;\n        let xPos2 = currentSkill.tags.ab1X;\n        let yPos2 = currentSkill.tags.ab1Y;\n        let distance = Math.round(Math.sqrt(Math.pow(xPos2-xPos1,2)+Math.pow(yPos2-yPos1,2)));\n        var weightedSkill = {bot: skill[i], position: distance};\n    }\n\n    sortedSkills.push(weightedSkill)\n}\n\nsortedSkills.sort((a, b) => a.position - b.position);\n\nreturn sortedSkills;","strokeColor":"orange","ab1MenuLabel":"learn","ab1ID":"learn","destroyable":false,"lineStyle":"line","lineColor":"#908BFC","color":"#20dcf5","onInstStreaming":"@whisper(this, \"onCreate\");","onPortalChanged":"@if (that.portal != \"sheetPortal\" && that.portal != \"menuPortal\" && getBot(\"ab1ID\", \"instMemory\").tags.ab1SleepState == false && that.dimension) {\n    if (that.dimension == \"ab1\") {\n        whisper(thisBot, \"ab1SkillNexus\", that);\n    }\n    else if (getBots(that.dimension).length < 1) {\n        shout(\"ab1Summon\", {\"type\": \"emptyDimension\", \"position\":that});\n    }\n}","onCreate":"@console.log(\"ab-1 START UP\")\n\nsetTimeout(() => whisper(thisBot, \"ab1Boot\"), 500);","scale":1,"ab1SkillPlaceholderArray":[{"abID":"ab1ChangeColor","tags":{"ab1MenuLabelBotFocus":"color","weight":4,"ab1BotAction":true,"color":"#55E679","ab1Icon":"palette"}},{"abID":"ab1Destroy","tags":{"ab1MenuLabelBotFocus":"destroy","weight":17,"ab1BotAction":true,"color":"#D66D5E","ab1Icon":"delete_outline"}},{"abID":"ab1CreateNote","ab1BotActionDependencyTag":"ab1Note","tags":{"ab1MenuLabelBotFocus":"scale","ab1MenuLabelGridFocus":"note","weight":5,"ab1GridAction":true,"ab1BotAction":true,"color":"#55E679","ab1Icon":"sticky_note_2"}},{"abID":"ab1ToolBox","tags":{"ab1MenuLabelGridFocus":"toolBox","weight":7,"ab1GridAction":true,"color":"#55E679","ab1Icon":"handyman"}},{"abID":"ab1SharedEgg","ab1BotActionDependencyTag":"eggVersionHistory","tags":{"ab1MenuLabelBotFocus":"make stable","weight":1,"ab1BotAction":true,"color":"#908BFC","ab1Icon":"egg"}},{"abID":"ab1Link","ab1BotActionDependencyTag":"ab1Note","tags":{"ab1MenuLabelBotFocus":"link","weight":16,"ab1BotAction":true,"ab1Icon":"add_link","color":"#55E679"}}],"onAnyBotsAdded":"@let addedBots = that.bots;\n\nif (addedBots)\n{\n    for (let i = 0; i < addedBots.length; i++)\n    {\n        let currentBot = addedBots[i];\n\n        if (currentBot.tags.ab1Skill)\n        {\n            if (getBots(\"ab1ID\", currentBot.tags.ab1ID).length > 1)\n            {\n                destroy(currentBot);\n            }\n            else\n            {\n                currentBot.tags.destroyable = false;\n            }\n\n            //if hot loaded skill, activate that skill or action\n            if (configBot)\n            {\n                if (currentBot.tags.ab1Skill && configBot.tags.ab1Focus)\n                {\n                    let ab1Inst = configBot.tags.ab1Inst;\n\n                    shout(\"ab1Summon\", ab1Inst)\n\n                    setTagMask(ab1InstMemory, \"ab1Focus\", configBot.tags.ab1Focus);\n                    setTagMask(ab1InstMemory, \"ab1FocusData\", configBot.tags.ab1FocusData);\n\n                    configBot.tags.ab1Inst = null;\n                    configBot.tags.ab1Focus = null;\n                    configBot.tags.ab1FocusData = null;\n\n                    whisper(currentBot, ab1InstMemory.tags.ab1Focus);\n                }\n            }\n        }\n    }\n}","ab1Boot":"@//setting up global variables\nglobalThis.player = os;\nglobalThis.ovoNest = getBot(\"ab1ID\", \"ovo\");\nglobalThis.ab1InstMemory = getBot(\"ab1ID\", \"instMemory\");\nglobalThis.ab1LongTermMemory = getBot(\"ab1ID\", \"ltm\");\nglobalThis.ab1LongTermMemorySearch = getBot(\"ab1ID\", \"searchLTM\");\nglobalThis.ab1Command = getBot(\"ab1ID\", \"command\");\nglobalThis.ab1Publish = getBot(\"ab1ID\", \"publish\");\nglobalThis.ab1LocalMemory = ab1InstMemory;\nglobalThis.countdown = setInterval();\n\n//check for boot code (autoLoad)\nlet bootFlag = configBot.tags.auxCode;\nlet ab1Flag = configBot.tags.ab1Sleep;\n\nif (!bootFlag)\n{\n    bootFlag = configBot.tags.autoLoad;\n}\n\n//catch if a gridPortal is not defined\nif (bootFlag) \n{\n    if (configBot.tags.gridPortal == null && configBot.tags.sheetPortal == null && configBot.tags.mapPortal == null)\n    {\n        configBot.tags.gridPortal = \"home\";\n    }\n}\n\nif (bootFlag && ab1InstMemory.tags.baseAuxCode == null) {\n    ab1InstMemory.tags.baseAuxCode = bootFlag;\n\n    let hashCheck = RegExp(/aux_/);\n    let hashTest = hashCheck.test(bootFlag);\n\n    //discontinue boot up if hash occurs\n    if (hashTest)\n    {\n        shout(\"ab1AUXFileImplement\", {hash: bootFlag});\n        return;\n    }\n\n    let filenamehash = crypto.sha256(bootFlag);\n    let fileurlhash = \"aux_\" + filenamehash + '.aux';\n    let o = {};\n    let targetURL = ab1LongTermMemorySearch.tags.s3BaseSearchURLEgg + fileurlhash;\n\n    setTagMask(ab1InstMemory, \"autoHatch\", true);\n\n    o.method = \"GET\";\n    o.url = targetURL;\n\n    try\n    {\n        var response = await webhook(o);\n    }\n    catch (e)\n    {\n        try \n        {\n            console.log(\"checking old LTM\");\n            o.url = ab1LongTermMemorySearch.tags.s3BaseSearchURLOldLTM + fileurlhash\n            var response = await webhook(o);\n\n        } catch (error)\n        {\n            os.toast(\"id could not be found\");\n            shout(\"hatchAB1\");\n            console.log(e);\n            return;\n        }\n    }\n\n    //attempt to load autoLoad file\n    if (response.status !== 200) \n    {\n        console.log('could not download aux file');\n        return;\n    }\n    else \n    {\n        console.log('loaded aux file from ' + bootFlag);\n    }\n\n    if (response.data.state == null) \n    {\n        os.toast(\"could not find file\");\n        shout(\"hatchAB1\");\n    }\n    else \n    {\n        shout(\"ab1EggCreate\", response);\n    }\n\n    if (ab1Flag == false)\n    {\n        shout(\"hatchAB1\");\n    } \n}\nelse if (ab1InstMemory.tags.ab1SleepState == true && configBot.tags.gridPortal == \"home\" && !ab1InstMemory.tags.baseAuxCode)\n{\n    //hatch ab1\n    shout(\"hatchAB1\");\n}","ab1SkillNexus":"@let skills = getBots(\"ab1Skill\");\nlet lineArray = [];\n\nfor (let i = 0; i < skills.length; i++)\n{\n    let currentSkill = '\"'+skills[i].id+'\"';\n    lineArray.push(currentSkill);\n}\n\nlet nexus = {};\n\nsetTagMask(thisBot, \"lineTo\", `ðŸ§¬ [${lineArray}]`);","ab1Skill":"true","ab1InitialLoad":"true","ab1Z":0,"ab1LoadSkill":"@const abID = that;\nconst actionType = ab1InstMemory.tags.ab1Focus;\nconst actionData = ab1InstMemory.tags.ab1FocusData;\nconst ab1 = getBot(\"ab1ID\", \"ab1\");\nconst ab1Dim  = ab1.tags.dimension;\n\nconfigBot.masks.ab1Inst = {dimension: ab1Dim, bot: {tags:{[ab1Dim+\"X\"]:ab1.tags[ab1Dim+\"X\"], [ab1Dim+\"Y\"]:ab1.tags[ab1Dim+\"Y\"]}}};\nconfigBot.masks.ab1Focus = actionType;\nconfigBot.masks.ab1FocusData = actionData;\n\nlet response = await shout(\"auxCodeSearch\", {auxCode: abID, autoHatch: true});\nlet learn = getBot(\"ab1ID\", \"learn\");\nlet placeHolderArray = learn.tags.ab1SkillPlaceholderArray;\nlet otherArray = learn.tags.ab1SkillUsedArray;\n\nif (!otherArray)\n{\n    otherArray = [];\n}\n\nlet abIndex =  placeHolderArray.findIndex(ab => ab.abID == abID);\n\nlet removedAB = placeHolderArray[abIndex];\n\notherArray.push(removedAB);\n\nlet updatedArray1 = placeHolderArray.slice(abIndex+1);\nlet updatedArray2 = placeHolderArray.slice(0, abIndex);\nlet updatedArray3 = updatedArray1.concat(updatedArray2);\n\nlearn.tags.ab1SkillPlaceholderArray = updatedArray3;\nlearn.tags.ab1SkillUsedArray = otherArray;","ab1Y":0,"ab1X":0,"ab1POV":"@let previousFrustum = getBot(\"frustumID\", configBot.id);\nlet currentDim = configBot.tags.gridPortal;\n\nif (previousFrustum)\n{\n    destroy(previousFrustum);\n}\nelse\n{\n    let frustumBot = {};\n \n    frustumBot.space = \"tempShared\";\n    frustumBot.frustumID = configBot.id;\n    frustumBot.form = \"frustum\";\n    frustumBot.pointable = false;\n    frustumBot.dimension = currentDim;\n    frustumBot[currentDim] = true;\n    frustumBot[currentDim+\"RotationX\"] = gridPortalBot.tags.cameraRotationX;\n    frustumBot[currentDim+\"RotationY\"] = gridPortalBot.tags.cameraRotationY;\n    frustumBot[currentDim+\"RotationZ\"] = gridPortalBot.tags.cameraRotationZ;\n    frustumBot[currentDim+\"X\"] = gridPortalBot.tags.cameraFocusX;\n    frustumBot[currentDim+\"Y\"] = gridPortalBot.tags.cameraFocusY;\n    frustumBot[currentDim+\"Z\"] = 80 / gridPortalBot.tags.cameraZoom;\n    frustumBot.onCreate = \"@ masks.interval = setInterval(() => whisper(thisBot, 'frustumUpdate'), 100);\";\n    frustumBot.onDestroy = \"@ clearInterval(tags.interval);\";\n    frustumBot.frustumUpdate = getBot(\"ab1ID\", \"learn\").tags.frustumUpdate;\n    frustumBot.onPortalChanged = `@ if (that.portal == 'gridPortal')\n    {\n        tags[tags.currentDim] = null;\n        tags[that.dimension] = true;\n        tags.dimension = that.dimension;\n    };`;\n\n    // let color = await os.showInput('white', {\n    //     type: 'color',\n    //     title: 'Enter a custom color'\n    // });\n\n    // frustumBot.color = color;\n\n    let newFrustum = create(frustumBot);\n\n    setTagMask(newFrustum, \"form\", \"none\");\n    setTagMask(newFrustum, \"color\", \"clear\");\n}\n\nshout(\"ab1Refresh\");","frustumUpdate":"@let currentDim = configBot.tags.gridPortal;\n\ntags.anchorPoint = [0, -3 * 80 / gridPortalBot.tags.cameraZoom, 0];\ntags[currentDim + \"RotationX\"] = gridPortalBot.tags.cameraRotationX;\ntags[currentDim + \"RotationY\"] = gridPortalBot.tags.cameraRotationY;\ntags[currentDim + \"RotationZ\"] = gridPortalBot.tags.cameraRotationZ;\ntags[currentDim + \"X\"] = gridPortalBot.tags.cameraFocusX;\ntags[currentDim + \"Y\"] = gridPortalBot.tags.cameraFocusY;\ntags[currentDim + \"Z\"] = 80 / gridPortalBot.tags.cameraZoom;","system":"ab1.manager.learn"}},"1aa9b270-c359-4c70-819a-3f0051ae0e02":{"id":"1aa9b270-c359-4c70-819a-3f0051ae0e02","space":"shared","tags":{"ab1":true,"ab1ID":"summon","destroyable":false,"scaleZ":"1.6","scaleY":"0.8","scaleX":"0.8","ab1UpdateID":"ed3217b2-074c-4b71-bd2e-c39a457c37d0","onGridClick":"@let ab1 = getBot(\"ab1ID\", \"ab1\");\n\nif (ab1InstMemory.tags.ab1SleepState == false && ab1 || that.dimension == \"ab1\" && ab1) \n{\n    const state = os.getInputState(\"keyboard\", \"Shift\");\n\n    if (state)\n    {\n        clearTagMasks(ab1InstMemory);\n        \n        that.to = true;\n\n        let selectorMod = {};\n\n        selectorMod.space = \"tempLocal\";\n        selectorMod[ab1.tags.dimension] = true;\n        selectorMod[ab1.tags.dimension + \"X\"] = that.position.x;\n        selectorMod[ab1.tags.dimension + \"Y\"] = that.position.y;\n        selectorMod.color = \"clear\";\n        selectorMod.strokeColor = ab1.tags.strokeColor;\n        selectorMod.lineColor = ab1.tags.strokeColor;\n        selectorMod.scaleZ = 0.01;\n        selectorMod.lineStyle = \"line\";\n        selectorMod.ab1ID = \"ab1Selector\";\n        selectorMod.ab1Refresh = \"@ destroy(thisBot);\";\n        selectorMod.onClick = \"@ shout('ab1Summon', {'bot': bot, 'dimension': that.dimension}); shout('ab1Refresh');\";\n\n        let selectorBot = create(selectorMod);\n\n        ab1.tags.lineTo = selectorBot.id;\n\n        shout('ab1SelectorDrop', that);\n        return;\n    }\n}\n\nif (ab1InstMemory.tags.ab1SleepState == false || that.dimension == \"ab1\") \n{\n    shout(\"ab1FootprintCreate\", that);\n}","strokeColor":"orange","onAnyBotDrag":"@if (that.bot.tags.ab1ID == \"ab1\")\n{\n    shout(\"ab1Refresh\");\n    \n    let selectorMod = {};\n\n    selectorMod.space = \"tempLocal\";\n    selectorMod.color = \"clear\";\n    selectorMod.strokeColor = that.bot.tags.strokeColor;\n    selectorMod.lineColor = that.bot.tags.strokeColor;\n    selectorMod.scaleZ = 0.01;\n    selectorMod.lineStyle = \"line\";\n    selectorMod.ab1ID = \"ab1Selector\";\n    selectorMod.ab1Refresh = \"@ destroy(thisBot);\";\n    selectorMod.onDrop = `@ if (that.to.bot)\n{\n    destroy(thisBot);\n    if (that.to.bot.tags.ab1ID == \"ab1\")\n    {\n        shout(\"ab1SelfSelect\");\n    }\n    else\n    {\n        shout('ab1SelectorDrop', that);\n    }\n}\nelse\n{\n    tags.draggable = false;\n    shout('ab1SelectorDrop', that);\n}`;\n    selectorMod.onClick = \"@ shout('ab1Summon', {'bot': bot, 'dimension': that.dimension}); shout('ab1Refresh');\";\n\n    let selectorBot = create(selectorMod);\n\n    await os.replaceDragBot(selectorBot);\n\n    that.bot.tags.lineTo = selectorBot.id;\n}\n\nif (ab1InstMemory.tags.ab1GridSnapState == true)\n{\n    os.addDropSnap(\"grid\");\n}","ab1Summon":"@shout(\"ab1Reset\");\n\nif (!ab1InstMemory)\n{\n    var ab1InstMemory = getBot(\"ab1ID\", \"instMemory\");\n}\n\nlet ab1Color = ab1InstMemory.tags.ab1Color;\nlet ab1 = {};\n\nif (that.type == null)\n{\n    ab1.dimension = that.dimension;\n    ab1.onClick = \"@ shout('ab1Click', {'dimension': that.dimension});\";\n    ab1[that.dimension] = true;\n    ab1[that.dimension+\"X\"] = that.bot.tags[that.dimension+\"X\"];\n    ab1[that.dimension+\"Y\"] = that.bot.tags[that.dimension+\"Y\"];\n}\nelse if (that.type == \"emptyDimension\")\n{\n    ab1.dimension = that.position.dimension;\n    ab1[that.position.dimension] = true;\n    ab1[that.position.dimension + \"X\"] = 0;\n    ab1[that.position.dimension + \"Y\"] = 0;\n}\nelse if (that.type == \"initial\")\n{\n    ab1.dimension = that.dimension[0];\n    ab1[that.dimension] = true;\n    ab1[that.dimension + \"X\"] = 0;\n    ab1[that.dimension + \"Y\"] = 0;\n}\n\n//constant ab1 features\nab1.space = \"tempLocal\";\nab1.color = \"clear\";\nab1.onClick = \"@ shout('ab1Click', {'dimension': that.dimension});\";\nab1.strokeColor = ab1Color;\nab1.onDrag = \"@ whisper(ab1Command, 'ab1Refresh')\";\nab1.ab1ID = \"ab1\";\nab1.draggable = false;\nab1.lineStyle = \"line\";\nab1.lineColor = ab1Color;\nab1.menuStateClosedOnEnter = `@ tags.interval = setInterval(() => {whisper(thisBot, \"spin\");}, 2000);\ntags.scale = 1;\nlet rotZ = os.getCurrentDimension()+\"RotationZ\";\n\nanimateTag(thisBot, rotZ, {\n    duration: 1.98,\n    fromValue: 0,\n    toValue: 6.3\n}).catch(error => {});\n\ntry{\n    await animateTag(thisBot, \"scale\", {\n        duration: 1.98,\n        tagMaskSpace: false,\n        toValue: 0.65\n    });\n}\ncatch (e){};`;\nab1.menuStateOpenOnEnter = `@ let rotZ = os.getCurrentDimension()+\"RotationZ\";\n\nclearInterval(tags.interval); \ntags.interval = null;\n\nanimateTag(thisBot, rotZ, null).catch();\n\nanimateTag(thisBot, rotZ, {\n    duration: 0.5,\n    toValue: 0\n}).catch(error => { });\n\nanimateTag(thisBot, \"scale\", null).catch();\n\nanimateTag(thisBot, \"scale\", {\n    duration: 0.5,\n    tagMaskSpace: false,\n    toValue: 1,\n    easing: {\n                type: \"quadratic\",\n                mode: \"inout\"\n            }\n}).catch(error => {});`;\nab1.spin = `@ let rotZ = os.getCurrentDimension()+\"RotationZ\";\n\nif (tags.scale <= 0.651)\n{\n    var targetScale = 0.95;\n}\nelse\n{\n    var targetScale = 0.65;\n}\n\nanimateTag(thisBot, rotZ, \n{\n    duration: 1.98,\n    fromValue: 0,\n    toValue: 6.3,\n}).catch(error => {});\n\ntry\n{\n    await animateTag(thisBot, \"scale\", {\n        duration: 1.98,\n        tagMaskSpace: false,\n        toValue: targetScale,\n        easing: {\n                type: \"quadratic\",\n                mode: \"inout\"\n            }\n    });\n}\ncatch (e){};`;\nab1.ab1Refresh = \"@ tags.lineTo = null; changeState(thisBot, 'Closed', 'menuState');\";\nab1.ab1Reset = \"@destroy(thisBot);\";\n\nlet ab1Bot = create(ab1);\n\nchangeState(ab1Bot, \"Closed\", \"menuState\");","ab1MenuLabel":"summon","color":"#20dcf5","ab1Y":-2,"ab1X":-2,"scale":1,"ab1InitialLoad":"true","ab1Skill":"true","ab1FocusLine":"@let ab1 = getBot(\"ab1ID\", \"ab1\");\n\nif (ab1)\n{\n    ab1.tags.lineColor = ab1.tags.strokeColor;\n    ab1.tags.lineStyle = \"line\";\n    ab1.tags.lineTo = that.id;\n}","ab1GridSelector":"@shout(\"ab1Refresh\");\n\nlet ab1 = getBot(\"ab1ID\", \"ab1\");\n\nlet selectorMod = {};\n\nselectorMod.space = \"tempLocal\";\nselectorMod[that.dimension] = true;\nselectorMod.draggable = false;\nselectorMod[that.dimension + \"X\"] = that.position.x;\nselectorMod[that.dimension + \"Y\"] = that.position.y;\nselectorMod.color = \"clear\";\nselectorMod.strokeColor = ab1.tags.strokeColor;\nselectorMod.lineColor = ab1.tags.strokeColor;\nselectorMod.scaleZ = 0.01;\nselectorMod.position = that;\nselectorMod.lineTo = ab1.id;\nselectorMod.lineStyle = \"line\";\nselectorMod.ab1ID = \"ab1Selector\";\nselectorMod.ab1Refresh = \"@ destroy(thisBot);\";\nselectorMod.onCreate = `@ setTagMask(ab1InstMemory, \"ab1Focus\", \"ab1GridAction\"); setTagMask(ab1InstMemory, \"ab1FocusData\", {dimension: \"${that.dimension}\", position: {x: ${that.position.x}, y: ${that.position.y}}}); shout(\"ab1Click\");`;\nselectorMod.onClick = \"@ shout('ab1Refresh'); shout('ab1Summon', {'bot': bot, 'dimension': [that.dimension]});\"\nselectorMod.ab1Refresh = \"@ destroy(thisBot);\"\n\nlet newSelector = create(selectorMod);","ab1FootprintCreate":"@if (that) \n{\n    shout(\"ab1Refresh\");\n\n    let previousFootPrint = getBot(byMod({ab1ID: \"footPrint\", [that.dimension + \"X\"]: that.position.x, [that.dimension + \"Y\"]: that.position.y}));\n\n    if(!previousFootPrint)\n    {\n        let ab1Color = ab1InstMemory.tags.ab1Color;\n        let focusPoint = {}\n\n        focusPoint.space = \"tempLocal\";\n        focusPoint.scaleZ = 0.01;\n        focusPoint.positioningMode = \"absolute\";\n        focusPoint.draggable = false;\n        focusPoint.ab1ID = \"footPrint\";\n        focusPoint.color = \"clear\";\n        focusPoint.strokeColor = ab1Color;\n        focusPoint.onCreate = `@ setTimeout(() => destroy(thisBot), 700);\n        \n        animateTag(thisBot, \"scaleX\", {\n            fromValue: 0.5,\n            toValue: 1.1,\n            duration: 0.5,\n            easing: {\n                type: \"elastic\",\n                mode: \"out\"\n            }\n        }).catch(e => {});\n\n        await animateTag(thisBot, \"scaleY\", {\n            fromValue: 0.5,\n            toValue: 1.1,\n            duration: 0.5,\n            easing: {\n                type: \"elastic\",\n                mode: \"out\"\n            }\n        }).catch(e => {});`;\n        focusPoint.onClick = \"@ shout('ab1Summon', {'bot': bot, 'dimension': that.dimension}); tags[that.dimension] = false;\";\n        focusPoint[that.dimension] = true;\n        focusPoint[that.dimension + \"X\"] = that.position.x;\n        focusPoint[that.dimension + \"Y\"] = that.position.y;\n\n        create(focusPoint);\n    }\n}","ab1Z":0,"system":"ab1.manager.summon"}},"2b83562a-8637-42c7-abab-7463ca835695":{"id":"2b83562a-8637-42c7-abab-7463ca835695","space":"shared","tags":{"ab1RecordSystem":true,"ab1":true,"ab1Action":"@shout(\"ab1MenuReset\");\n\nsetTagMask(thisBot, \"ab1Scan\", true);\n\nos.openQRCodeScanner();","ab1ID":"scan","ab1Icon":"qr_code_scanner","ab1InitialLoad":"true","ab1MenuLabel":"scan","ab1UpdateID":"cd0ca749-86ff-4539-b538-acc2b3052829","ab1X":7,"ab1Y":7,"ab1Z":0,"color":"#20dcf5","scale":"1","scaleX":"0.8","destroyable":false,"scaleY":"0.8","scaleZ":"1.6","strokeColor":"orange","ab1Skill":"true","onQRCodeScannerClosed":null,"system":"ab1.memory.scan","onQr":null,"onQRCodeScanned":"@if (tags.ab1Scan)\n{\n    let menuDim = os.getMenuDimension();\n    let menuButton = {};\n\n    menuButton.space = \"tempLocal\";\n    menuButton.ab1MenuButton = true;\n    menuButton[menuDim] = true;\n    menuButton.target = that;\n    menuButton.ab1MenuReset = \"@ destroy(thisBot);\";\n    menuButton.color = \"#908BFC\";\n    menuButton.menuItemStyle = `ðŸ§¬ {\"border-radius\": \"9px 9px 9px 9px\", \"margin-top\": \"6px\"}`;\n    menuButton.ab1Click = \"@ destroy(thisBot);\";\n    menuButton.labelAlignment = \"left\";\n    menuButton.onClick = \"@ shout('ab1MenuReset'); shout('ab1QRSearch', tags.target);\";\n    menuButton.type = \"search\";\n    menuButton.label = \"load from uuab\";\n    menuButton.formAddress = \"egg\";\n\n    create(menuButton);\n\n    menuButton.type = \"publish\";\n    menuButton.label = \"publish to uuab\";\n    menuButton.onClick = \"@ shout('ab1MenuReset'); shout('ab1QRPublish', tags.target);\";\n\n    create(menuButton);\n}","ab1Refresh":"@clearTagMasks(thisBot);"}},"37d82a9e-1920-48c6-b797-76f4a6783f74":{"id":"37d82a9e-1920-48c6-b797-76f4a6783f74","space":"shared","tags":{"ab1":true,"strokeColor":"orange","scaleZ":"1.6","scaleY":"0.8","scaleX":"0.8","ab1UpdateID":"40938eb1-eef3-4c69-afb8-d25a403bceb4","ab1ID":"createBot","ab1MenuLabel":"bot","destroyable":false,"color":"#55E679","ab1X":-3,"ab1Y":0,"ab1Icon":"cube","ab1GridAction":"@let positionInfo = ab1InstMemory.tags.ab1FocusData;\nconsole.log(positionInfo)\nlet newBot = {}\n\nnewBot.creator = null;\nnewBot[positionInfo.dimension] = true;\nnewBot[positionInfo.dimension+\"X\"] = positionInfo.x;\nnewBot[positionInfo.dimension+\"Y\"] = positionInfo.y;\nnewBot.color = \"#7B64FF\";\n\nlet createBot = create(newBot);\nlet ab1 = getBot(\"ab1ID\", \"ab1\");\n\nshout(\"ab1Refresh\");\n\nab1InstMemory.masks.ab1Focus = \"ab1BotAction\";\nab1InstMemory.masks.ab1FocusData = createBot.id;\n\nif (ab1)\n{\n    ab1.tags.lineTo = createBot.id;\n}\n\nshout(\"ab1Click\");","scale":1,"ab1Skill":"true","auxCodeOrigin":"ab1CreateBot","onClick":null,"ab1Z":0,"ab1InitialLoad":"true","system":"ab1.action.createBot"}},"3fca5929-83b0-40f9-853b-761ba0be1c83":{"id":"3fca5929-83b0-40f9-853b-761ba0be1c83","space":"shared","tags":{"ab1":true,"ab1UpdateID":"e6ebfdc8-2828-4519-b7f4-c0c8f7a51c57","ab1ID":"openSheet","strokeColor":"orange","scaleZ":"1.6","scaleY":"0.8","scaleX":"0.8","color":"#55E679","ab1Action":"@let currentInst = os.getCurrentInst();\nlet currentDim = getBot(\"ab1ID\", \"ab1\").tags.dimension;\n\nconst state = os.getInputState(\"keyboard\", \"Shift\");\n\nif (state) \n{\n    os.openURL(`/?inst=${currentInst}&sheetPortal=${currentDim}`);\n}\nelse\n{\n    configBot.tags.sheetPortal = currentDim;\n}\n\nshout(\"ab1Reset\");","ab1MenuLabel":"sheet","destroyable":false,"ab1MenuLabelAlternate":"sheet new tab","ab1X":0,"ab1Icon":"table_view","ab1Y":3,"scale":1,"ab1BotAction":"@let currentInst = os.getCurrentInst();\nlet currentDim = getBot(\"ab1ID\", \"ab1\").tags.dimension;\nlet selectedBot = ab1InstMemory.tags.ab1FocusData;\n\nconst state = os.getInputState(\"keyboard\", \"Shift\");\n\nif (state)\n{\n    os.openURL(`/?inst=${currentInst}&gridPortal=${currentDim}&sheetPortal=${selectedBot}`);\n}\nelse\n{\n    configBot.tags.sheetPortal = selectedBot;\n}\n\nshout(\"ab1Reset\");","ab1InitialLoad":"true","ab1Skill":"true","ab1Z":0,"system":"ab1.action.openSheet"}},"6a56d02c-4062-4082-aa98-e595d064a7fe":{"id":"6a56d02c-4062-4082-aa98-e595d064a7fe","space":"shared","tags":{"system":"ab1.action.factory","scaleX":"0.8","scaleY":"0.8","scaleZ":"1.6","color":"#55E679","strokeColor":"orange","ab1":true,"ab1Y":8,"ab1Z":0,"ab1ID":"factory","ab1Icon":"factory","ab1MenuLabel":"factory bot","ab1Skill":"true","ab1UpdateID":"9ab8ddcf-e691-4112-af57-203b6661f88b","destroyable":false,"scale":"1","ab1BotAction":"@let currentDim = getBot(\"ab1ID\", \"ab1\").tags.dimension;\nlet selectedBot = getBot(\"id\", ab1InstMemory.tags.ab1FocusData);\n\nshout(\"ab1Refresh\");\n\nwhisper(getBot(\"ab1ID\", \"factory\"), \"ab1AddToFactory\", {dimension: currentDim, bot: selectedBot});","ab1GridAction":"@let factoryBots = getBots(\"system\");\nlet factoryArray = [];\n\nshout(\"ab1MenuReset\");\n\nfor (let i = 0; i < factoryBots.length; i++)\n{\n    let currentBot = factoryBots[i];\n    let currenSystem = currentBot.tags.system;\n\n    if (currentBot.tags.ab1ID)\n    {\n        continue;\n    }\n    if (currenSystem.includes(\"factory\"))\n    {\n        factoryArray.push(currentBot);\n    }\n}\n\nif (factoryArray.length > 0)\n{\n    let menuDim = os.getMenuDimension();\n    let menuButton = {};\n\n    menuButton.space = \"tempLocal\";\n    menuButton.ab1MenuButton = true;\n    menuButton[menuDim] = true;\n    menuButton.ab1MenuReset = \"@ destroy(thisBot);\";\n    menuButton.menuItemStyle = `ðŸ§¬ {\"border-radius\": \"9px 9px 9px 9px\", \"margin-top\": \"6px\"}`;\n    menuButton.ab1Click = \"@ destroy(thisBot);\";\n    menuButton.labelAlignment = \"left\";\n    menuButton.onClick = `@ shout(\"ab1CreateFromFactory\", {factoryID: tags.label, position: ab1InstMemory.tags.ab1FocusData}); shout('ab1Refresh');`;\n\n    for (let j = 0; j < factoryArray.length; j++)\n    {\n        let currentFactoryBot = factoryArray[j];\n        let currentSystemTag = currentFactoryBot.tags.system\n\n        menuButton.label = currentSystemTag.substring(8);\n        menuButton.color = currentFactoryBot.tags.color;\n\n        let newButton = create(menuButton);\n    }\n}","ab1MenuLabelBotFocus":"add to factory","ab1X":8,"auxCodeOrigin":"ab1Factory01","ab1AddtoFactory":null,"ab1AddToFactory":"@//shout(\"ab1AddToFactory\", {dimension: dimension, bot: bot, factoryID: factoryID});\nlet factoryID;\n\nif (that.factoryID)\n{\n    factoryID = that.factoryID;\n}\nelse\n{\n    factoryID = await os.showInput(null, {\n        title: 'Add factory id'\n    });\n}\n\nif (factoryID)\n{\n    let previousFactoryBot = getBot(\"system\", \"factory.\" + factoryID);\n    \n    if(previousFactoryBot)\n    {\n        destroy(previousFactoryBot);\n    }\n\n    let templateBot = that.bot;\n    let factoryMod = {};\n\n    factoryMod[that.dimension] = null;\n    factoryMod.system = \"factory.\" + factoryID;\n    factoryMod.listening = false;\n    factoryMod.ab1Factory = true;\n\n    create(templateBot, factoryMod);\n\n    os.toast(\"added \" + factoryID + \" to factory\");\n}","ab1CreateFromFactory":"@//shout(\"ab1CreateFromFactory\", {factoryID: \"factoryID\", position: {dimension: \"dimension\", x: \"x\", y: \"y\"}});\nlet fullName = \"factory.\" + that.factoryID;\nlet factoryTemplate = getMod(getBot('system', fullName));\nlet positionInfo = that.position;\n\nlet newBot = {}\n\nnewBot.creator = null;\nnewBot[positionInfo.dimension] = true;\nnewBot[positionInfo.dimension + \"X\"] = positionInfo.x;\nnewBot[positionInfo.dimension + \"Y\"] = positionInfo.y;\nnewBot.listening = null;\nnewBot.system = null;\nnewBot.ab1Factory = null;\n\ncreate(factoryTemplate, newBot);","onMenuCreate":"@let menuType = ab1InstMemory.tags.ab1Focus;\nlet factoryBot = getBot(\"ab1Factory\");\n\nif (menuType == \"ab1GridAction\" && !factoryBot)\n{\n    destroy(thisBot);\n}","ab1InitialLoad":"true"}},"7c2626a2-ddd3-4e5c-8eb1-d8d8af00a0f8":{"id":"7c2626a2-ddd3-4e5c-8eb1-d8d8af00a0f8","space":"shared","tags":{"ab1":true,"ab1ID":"ltm","ab1UpdateID":"6fcf0097-4a38-4114-b29e-048e77d1ef3c","destroyable":false,"scaleX":"0.8","scaleY":"0.8","scaleZ":"1.6","strokeColor":"orange","ab1MenuLabel":"long term memory","ab1Y":-6,"color":"#20dcf5","ab1FileBoot":"@const dataOutput = that;\n\nfor (const property in dataOutput) \n{\n    const newBot = dataOutput[property];\n    \n    if (newBot.space) \n    {\n        try\n        {\n            let b = create(newBot.tags);\n            b.tags.creator = null;\n        }\n        catch(error)\n        {\n            console.log(\"invalid bot\", error);\n        }\n    }\n    else\n    {\n        //console.log(\"skipped bot: \" + newBot);\n    }\n}\n\nshout(\"ab1Reset\");\nos.toast(\"bots loaded\");","scale":1,"s3StorageRequestBaseURLLongTerm":"https://ngsrdpub26.execute-api.us-east-1.amazonaws.com/builder-upload-ltm-files","s3StorageRequestBaseURLShortTerm":"https://xo7qpam8uh.execute-api.us-east-1.amazonaws.com/builder-upload-stm-files","ab1ProcessFile":"@let dataUsed;\nlet baseURL;\n\nif (that.inputFileExtension == \"aux\")\n{\n  dataUsed = that.file;\n}\nelse{\n  dataUsed = that.file.file.data;\n}\n\nif (that.egg == true)\n{\n  baseURL = tags.s3StorageRequestBaseURLShortTerm;\n}\nelse\n{\n  baseURL = tags.s3StorageRequestBaseURLLongTerm; \n}\n\n// Send GET request to the api asking for a file upload url\nconst s3StorageRequestResponse = await web.hook\n({\n  method: 'GET',\n  url: baseURL+'?'+that.fileposturl\n})\n.catch((err) => \n{ \n  // Something went wrong with our GET request, log an error and return\n  console.error(err); \n  return err;\n})\n\nlet h = {}\nh['Content-Type'] = s3StorageRequestResponse.data.contentType;\nh['Cache-Control'] = s3StorageRequestResponse.data.cacheControl;\n\nlet o = {}\no.headers = h;\no.url = s3StorageRequestResponse.data.uploadURL;\no.data = dataUsed;\no.method = 'PUT';\n\n// Send PUT to the URL returned from our first api request\nconst s3StorageResultResponse = await web.hook(o)\n.catch((err) => \n{ \n  // Something went wrong with the PUT, log an error and return\n  console.error(err); \n  return err;\n})\n\n// Create object to return later\nlet processedData = \n{\n  url: s3StorageRequestResponse.data.uploadURL.split('?')[0],\n  fileName: s3StorageRequestResponse.data.fileName,\n  fileExtension: that.inputFileExtension,\n  contentType: s3StorageRequestResponse.data.contentType,\n  data: dataUsed\n};\n\nif (that.inputFileExtension == \"aux\" && that.alias && that.egg == true)\n{\n  webhook.post(\"https://qnhca2s7ic.execute-api.us-east-1.amazonaws.com/slack/T029AP4CQ/B01KNTB8201/gCOPlqQHsRP3tBK9PYHJBmNp\", {\"text\":`${that.eggType} ${that.alias} ${that.latestVersion} ${that.hash}`}, \"Origin: https://casualos.com\");\n}\nelse if (that.inputFileExtension == \"aux\")\n{\n  shout(\"onAuxCodePublished\", that.auxCode);\n  shout(\"onABPublished\", {ab: that.auxCode, fileAddress: processedData.url});\n\n  //copying to clipboard\n  let siteOrigin = new URL(configBot.tags.url).origin;\n\n  if (that.manualPublish)\n  {\n    if (that.auxKey)\n    {\n      os.setClipboard(siteOrigin+\"/?autoLoad=\"+that.auxCode+\"&key=\"+that.auxKey);\n    }\n    else\n    {\n      os.setClipboard(siteOrigin+\"/?autoLoad=\"+that.auxCode);\n    }\n\n    configBot.tags.manualPublish = null;\n\n    os.toast(that.auxCode + \" published, URL copied to clipboard\");\n  }\n}\nelse  \n{\n  configBot.tags.menuPortal = \"ab1ConfirmMenu\";\n\n  destroy(getBots(\"ab1ConfirmMenu\"));\n\n  let botCreateButton = {};\n\n  botCreateButton.space = \"tempLocal\";\n  botCreateButton.menuItemStyle = `ðŸ§¬ {\"border-radius\": \"9px 9px 9px 9px\", \"margin-top\": \"6px\"}`;\n  botCreateButton.mediaData = {\"fileposturl\": that.fileposturl, \"file\": processedData, \"formType\": that.formType, \"inputFileExtension\": that.inputFileExtension, \"formSubtype\": that.formSubtype};\n\n  if (that.formType)\n  {\n    botCreateButton.label = \"add bot to inst\";\n  }\n  else\n  {\n    botCreateButton.label = \"copy file URL\";\n  }\n\n  botCreateButton.color = \"#20dcf5\";\n  botCreateButton.onClick = `@ whisper(getBot('ab1ID', 'auxLoader'), 'ab1CreateMediaBot', tags.mediaData); configBot.tags.menuPortal = null;`;\n  botCreateButton.ab1Refresh = \"@ destroy(thisBot);\";\n  botCreateButton.ab1Upload = \"@ destroy(thisBot);\";\n  botCreateButton.onFileUpload = \"@ destroy(thisBot);\";\n  botCreateButton.ab1ConfirmMenu = true;\n  botCreateButton.ab1ConfirmMenuSortOrder = 0;\n\n  create(botCreateButton);\n\n  let cancelButton = {};\n\n  cancelButton.space = \"tempLocal\";\n  cancelButton.menuItemStyle = `ðŸ§¬ {\"border-radius\": \"9px 9px 9px 9px\", \"margin-top\": \"6px\"}`;\n  cancelButton.label = \"cancel\";\n  cancelButton.color = \"#D66D5E\";\n  cancelButton.onClick = `@ configBot.tags.menuPortal = null;`;\n  cancelButton.ab1Refresh = \"@ destroy(thisBot);\";\n  cancelButton.ab1Upload = \"@ destroy(thisBot);\";\n  cancelButton.onFileUpload = \"@ destroy(thisBot);\";\n  cancelButton.ab1ConfirmMenu = true;\n  cancelButton.ab1ConfirmMenuSortOrder = 2;\n\n  create(cancelButton); \n}","ab1Skill":"true","ab1InitialLoad":"true","ab1Z":0,"ab1X":-6,"system":"ab1.memory.ltm"}},"aac12442-9766-43d8-a25a-2e1d9642c4bb":{"id":"aac12442-9766-43d8-a25a-2e1d9642c4bb","space":"shared","tags":{"ab1":true,"ab1X":12,"ab1ID":"copy","ab1Icon":"file_copy","ab1MenuLabel":"copy","ab1MenuLabelBotFocus":"copy to clipboard","ab1UpdateID":"42ed6161-8f98-48e1-89ec-4bf752e76a7c","color":"#55E679","onPaste":"@let copyBot = JSON.parse(that.text);\nlet botTemplate = copyBot.state;\nlet positionInfo = ab1InstMemory.tags.ab1FocusData;\nlet dimMod = {};\n\nif (positionInfo)\n{\n    dimMod[positionInfo.dimension] = true;\n    dimMod[positionInfo.dimension+\"X\"] = positionInfo.x;\n    dimMod[positionInfo.dimension+\"Y\"] = positionInfo.y;\n}\n\nfor (const property in botTemplate) {\n    const newBot = botTemplate[property];\n\n    if (newBot.tags.ab1UpdateID)\n    {\n        newBot.tags.ab1UpdateID = null;\n        newBot.tags.destroyable = null;\n    }\n    \n    var createBot = create(newBot, dimMod)\n}\n\nos.toast(\"bot added to inst\");\nshout(\"ab1Refresh\");","strokeColor":"orange","scaleZ":"1.6","scaleY":"0.8","scaleX":"0.8","scale":"1","ab1InitialLoad":"true","ab1Skill":"true","ab1Refresh":"@configBot.tags.publishTarget = null;","ab1BotAction":null,"ab1Z":0,"ab1Y":0,"destroyable":false,"system":"ab1.action.copy"}},"b89cfd65-f45f-4989-ab9c-d32ab5c3f170":{"id":"b89cfd65-f45f-4989-ab9c-d32ab5c3f170","space":"shared","tags":{"ab1":true,"ab1Y":2,"ab1Click":"@let ab1 = getBot(\"ab1ID\", \"ab1\");\nlet shiftCheck = os.getInputState(\"keyboard\", \"Shift\");\n\nif (shiftCheck && that)\n{\n  shout(\"ab1SelfSelect\");\n  return;\n}\n\nif (ab1InstMemory.tags.ab1MenuState == true) \n{\n  shout(\"ab1Refresh\");\n  \n  configBot.tags.mode = null;\n}\nelse \n{\n  changeState(ab1, \"Open\", \"menuState\");\n\n  shout(\"ab1GenerateMenu\", {menu: ab1InstMemory.tags.ab1Focus, menuInfo: ab1InstMemory.tags.ab1FocusData});\n\n  setTagMask(ab1InstMemory, \"ab1MenuState\", true);\n}","ab1ID":"command","ab1MenuLabel":"command","ab1GenerateMenu":"@let buttonFunction = that.menu;\nlet skillBots = getBots(buttonFunction);\nlet possibleSkills = getBot(\"ab1ID\", \"learn\").tags.ab1SkillPlaceholderArray;\n\nfor (let h = 0; h < possibleSkills.length; h++)\n{\n    let currentPlaceholder = possibleSkills[h];\n\n    if (currentPlaceholder.tags[buttonFunction])\n    {\n        //Make sure we can filter out placeholders given the possiblities present\n        let botDependencyTag = currentPlaceholder[buttonFunction+\"DependencyTag\"];\n        let botDependencyValue = currentPlaceholder[buttonFunction+\"DependencyValue\"];\n\n        if (getBot(\"auxCodeOrigin\", currentPlaceholder.abID))\n        {\n            continue;\n        }\n\n        if (buttonFunction == \"ab1BotAction\" && botDependencyTag)\n        {\n            let targetBot = getBot(\"id\", ab1InstMemory.tags.ab1FocusData);\n\n            if ((targetBot.tags[botDependencyTag] == botDependencyValue && botDependencyValue) || (targetBot.tags[botDependencyTag] && !botDependencyValue))\n            {\n                skillBots.push(currentPlaceholder);\n            }\n        }\n        else if (botDependencyTag)\n        {\n            let targetBot = getBot(botDependencyTag, botDependencyValue);\n\n            if (targetBot || (getBot(botDependencyTag) && !botDependencyValue))\n            {\n                skillBots.push(currentPlaceholder);\n            }\n        }\n        else\n        {\n            skillBots.push(currentPlaceholder);\n        }\n    }\n}\n\nif (os.getMenuDimension() != null)\n{\n    setTagMask(ab1InstMemory, \"previousMenu\", os.getMenuDimension());\n}\n\nconfigBot.tags.menuPortal = \"ab1Menu\";\n\nfor (let i = 0; i < skillBots.length; i++)\n{\n    let currentSkill = skillBots[i];\n    let menuButton = {};\n\n    menuButton.space = \"tempLocal\";\n    menuButton.ab1MenuButton = true;\n    menuButton.ab1MenuReset = \"@ destroy(thisBot);\";\n    menuButton.label = currentSkill.tags.ab1MenuLabel;\n    menuButton.color = currentSkill.tags.color;\n    menuButton.menuItemStyle = `ðŸ§¬ {\"border-radius\": \"9px 9px 9px 9px\", \"margin-top\": \"6px\"}`;\n    menuButton.ab1Click = \"@ destroy(thisBot);\";\n    menuButton.onCreate = currentSkill.tags.onMenuCreate;\n    menuButton.labelAlignment = \"left\";\n\n    if (currentSkill.abID)\n    {\n        //possible skills\n        menuButton.abID = currentSkill.abID;\n        menuButton.onClick = \"@ shout('ab1LoadSkill', tags.abID);\";\n        menuButton.weight = currentSkill.tags.weight;\n    }\n    else\n    {\n        //actual skills\n        menuButton.originSkill = currentSkill.id;\n        menuButton.onClick = currentSkill.tags[buttonFunction]; \n    }\n\n    if (currentSkill.tags.ab1MenuLabelAlternate)\n    {\n        menuButton.alternateLabel = currentSkill.tags.ab1MenuLabelAlternate;\n        menuButton.mainLabel = currentSkill.tags.ab1MenuLabel;\n        menuButton.onKeyDown = `@ if(that.keys == \"Shift\"){tags.label = tags.alternateLabel;}`;\n        menuButton.onKeyUp = `@ if(that.keys == \"Shift\"){tags.label = tags.mainLabel;}`;\n    }\n\n    if (currentSkill.tags.ab1Icon)\n    {\n        menuButton.formAddress = currentSkill.tags.ab1Icon;\n    }\n\n    if (currentSkill.tags.ab1MenuLabelBotFocus && that.menu == \"ab1BotAction\")\n    {\n        menuButton.label = currentSkill.tags.ab1MenuLabelBotFocus;\n    }\n    else if (currentSkill.tags.ab1MenuLabelGridFocus && buttonFunction == \"ab1GridAction\")\n    {\n        menuButton.label = currentSkill.tags.ab1MenuLabelGridFocus;\n    }\n\n    await create(menuButton);\n}\n\n//order logic goes here\nlet currentMenuBots = getBots(\"ab1MenuButton\", true);\nlet learnBot = getBot(\"ab1ID\", \"learn\");\nlet positionCalculatedBots = await whisper(learnBot, \"ab1SkillPositionCalculation\", {bots: currentMenuBots})[0];\n\nfor (let j = 0; j < positionCalculatedBots.length; j++)\n{\n    let currentButton = positionCalculatedBots[j].bot;\n    let currentWeight = positionCalculatedBots[j].position;\n\n    if (j < 4 || (j == 4 && positionCalculatedBots.length == 5))\n    {\n        currentButton.tags.ab1Menu = true;\n        currentButton.tags.ab1MenuSortOrder = currentWeight;\n    }\n    else if (j < 9 || (j == 9 && positionCalculatedBots.length == 10))\n    {\n        if (j == 4)\n        {\n            whisper(thisBot, \"ab1NextMenuButtonCreate\", 2);\n        }\n\n        currentButton.tags.ab1Menu2 = true;\n        currentButton.tags.ab1Menu2SortOrder = currentWeight;\n    }\n    else\n    {\n        if (j == 10)\n        {\n            whisper(thisBot, \"ab1NextMenu\", 3);\n        }\n\n        currentButton.tags.ab1Menu3 = true;\n        currentButton.tags.ab1Menu3SortOrder = currentWeight;\n    }\n}\n\n//timer for longer menu on quick menu re-open\nlet ab1TimerGenerator = getBot(\"ab1ID\", \"ab1TimerGenerator\");\n\nif (ab1TimerGenerator == null && that.menu != \"focus\"){\n    ab1TimerGenerator = {};\n\n    ab1TimerGenerator.space = \"tempLocal\";\n    ab1TimerGenerator.onDestroy = \"@ shout('ab1MenuTimer');\";\n    ab1TimerGenerator.ab1MenuReset = \"@ destroy(thisBot);\";\n    ab1TimerGenerator.ab1Click = \"@ destroy(thisBot);\";\n\n    create(ab1TimerGenerator);\n}","ab1MenuTimerCreate":"@let ab1MenuTimer = getBot(\"ab1ID\", \"ab1MenuTimer\");\n\nif (ab1MenuTimer == null)\n{\n    ab1MenuTimer = {}\n\n    ab1MenuTimer.space = \"tempLocal\";\n    ab1MenuTimer.ab1ID = \"ab1MenuTimer\";\n    ab1MenuTimer.onCreate = \"@ setTimeout(()=> destroy(thisBot), 500)\";\n\n    create(ab1MenuTimer);\n}","ab1NextMenuButtonCreate":"@let menuButton = {};\nlet ab1Color = ab1InstMemory.tags.ab1Color;\n\nif (that == 2)\n{\n    menuButton.ab1Menu = true;\n    menuButton.onClick = '@ configBot.tags.menuPortal = \"ab1Menu2\"';    \n}\nelse if (that == 3)\n{\n    menuButton.ab1Menu2 = true;\n    menuButton.onClick = '@ configBot.tags.menuPortal = \"ab1Menu3\"';\n}\n\nmenuButton.space = \"tempLocal\";\nmenuButton.ab1MenuSortOrder = 20;\nmenuButton.label = \" \";\nmenuButton.ab1MenuButton = true;\nmenuButton.formAddress = \"expand_more\";\nmenuButton.color = ab1Color;\nmenuButton.scale = 1;\nmenuButton.menuItemStyle = `ðŸ§¬ {\"border-radius\": \"9px 9px 9px 9px\", \"margin-top\": \"6px\"}`;\nmenuButton.ab1MenuReset = \"@ destroy(thisBot);\";\nmenuButton.ab1Click = \"@ destroy(thisBot);\"\n\ncreate(menuButton);","ab1ReminderTimer":"@if(ab1InstMemory.tags.ab1SleepState == false) \n{\n    clearInterval(countdown);\n    countdown = setInterval(() => {os.toast(\"don't forget to publish to an AB to save your work!\")}, 1200000);\n}\nelse \n{\n    clearInterval(countdown);\n}","ab1ScanButton":null,"ab1SelfSelect":"@let time = new Date();\nlet offset = time.getTimezoneOffset();\nlet hour = (32 - time.getHours())-Math.round(offset/60);\nlet minute = 60 - time.getMinutes();\n\nos.toast(hour + \" hours \" + minute + \" minutes until inst reset\", 0.5);\n\nif (os.getMenuDimension() != null)\n{\n    setTagMask(ab1InstMemory, \"previousMenu\", os.getMenuDimension());\n}\n\nconfigBot.tags.menuPortal = \"ab1Menu\";\n\nlet ab1Color = ab1InstMemory.tags.ab1Color;\n\nfor (let i = 0; i < 10; i++)\n{\n    let menuButton = {};\n\n    menuButton.space = \"tempLocal\";\n    menuButton.ab1Menu = true;\n    menuButton.ab1MenuSortOrder = i;\n    menuButton.ab1MenuReset = \"@ destroy(thisBot);\";\n    menuButton.menuItemStyle = `ðŸ§¬ {\"border-radius\": \"9px 9px 9px 9px\", \"margin-top\": \"6px\"}`;\n    menuButton.ab1Click = \"@ destroy(thisBot);\";\n    menuButton.labelAlignment = \"left\";    \n    \n    if (i == 0)// hide\n    {\n        menuButton.onClick =`@ shout(\"ab1Reset\");`;\n        menuButton.label = \"hide\";\n        menuButton.color = ab1Color;\n        menuButton.formAddress = \"visibility_off\";\n    }\n    else if ( i == 1) // color\n    {\n        menuButton.label = \"color\";\n        menuButton.color = ab1Color;\n        menuButton.formAddress = \"palette\";\n        menuButton.onClick = `@\n        os.showInputForTag(ab1InstMemory, \"ab1Color\", {\n            type: 'color',\n            title: 'pick a color'\n        });\n\n        shout(\"ab1Reset\");`;\n    }\n    else if(i == 2)// sleep\n    {\n        let sleepState = ab1InstMemory.tags.ab1SleepState;\n\n        \n        menuButton.color = ab1Color;\n        if (sleepState == false)\n        {\n            menuButton.label = \"sleep\";\n            menuButton.onClick = `@ shout(\"ab1Sleep\", \"sleep\"); shout(\"ab1Reset\");`;\n            menuButton.formAddress = \"nights_stay\";\n        }\n        else \n        {\n            menuButton.label = \"wake\";\n            menuButton.onClick = `@ shout(\"ab1Sleep\", \"wake\");`;\n            menuButton.formAddress = \"wb_sunny\";\n        }\n    }\n    else if (i == 3)\n    {\n        let previousFrustum = getBot(\"frustumID\", configBot.id);\n        \n        menuButton.onClick = \"@ shout('ab1POV');\";\n        menuButton.label = \"collab pov\";\n        menuButton.color = ab1Color;\n        \n\n        if (previousFrustum)\n        {\n            menuButton.formAddress = \"visibility\";\n        }\n        else\n        {\n            menuButton.formAddress = \"visibility_off\";\n        }\n\n    }\n    else if (i == 4)\n    {\n        menuButton.label = \"systems\";\n        menuButton.color = ab1Color;\n        menuButton.formAddress = \"settings_applications\";\n        menuButton.onKeyDown = \"@ \";\n        menuButton.onKeyUp = \"@ \";\n        menuButton.onClick = `@ let shiftCheck = os.getInputState(\"keyboard\", \"Shift\");\n        let currentInst = os.getCurrentInst();\n\n        if (shiftCheck)\n        {\n            os.openURL(\"/?inst=\"+currentInst+\"&systemPortal=true\");\n        }\n        else\n        {\n            configBot.tags.systemPortal = true;\n        }\n\n        shout('ab1Refresh');\n        `;\n    }\n    else if(i == 5)//edit skills\n    {\n        menuButton.onClick = \"@ os.goToDimension('ab1'); shout('ab1Refresh');\";\n        menuButton.label = \"manage skills\";\n        menuButton.color = ab1Color;\n        menuButton.formAddress = \"settings\";\n    }\n    else if(i == 6)//change grid snap\n    {\n        let gridState = ab1InstMemory.tags.ab1GridSnapState;\n\n        menuButton.onClick = `@\n        if (tags.gridState == true)\n        {\n            changeState(thisBot, false, \"gridState\");\n        }\n        else\n        {\n            changeState(thisBot, true, \"gridState\");\n        }`;\n        menuButton.label = \"grid snap\";\n        menuButton.gridStatetrueOnEnter = `@\n        tags.formAddress = \"check_box\";\n        ab1InstMemory.tags.ab1GridSnapState = true;`;\n        menuButton.gridStatefalseOnEnter = `@\n        tags.formAddress = \"check_box_outline_blank\";\n        ab1InstMemory.tags.ab1GridSnapState = false;`;\n        menuButton.color = ab1Color;\n        menuButton.onCreate = `@ changeState(thisBot, ${gridState}, \"gridState\");`;\n    }\n    else if(i == 7)//change bot snap\n    {\n        let botSnapState = ab1InstMemory.tags.ab1BotSnapState;\n\n        if (!botSnapState)\n        {\n            menuButton.formAddress = \"check_box_outline_blank\";\n        }\n\n        menuButton.onClick = `@\n        if (tags.botSnapState == \"face\")\n        {\n            changeState(thisBot, \"none\", \"botSnapState\");\n        }\n        else\n        {\n            changeState(thisBot, \"face\", \"botSnapState\");\n        }`;\n        menuButton.label = \"bot snap\";\n        menuButton.botSnapStatefaceOnEnter = `@\n        tags.formAddress = \"check_box\";\n        ab1InstMemory.tags.ab1BotSnapState = \"face\";`;\n        menuButton.botSnapStatenoneOnEnter = `@\n        tags.formAddress = \"check_box_outline_blank\";\n        ab1InstMemory.tags.ab1BotSnapState = \"none\";`;\n        menuButton.color = ab1Color;\n        menuButton.onCreate = `@ changeState(thisBot, \"${botSnapState}\", \"botSnapState\");`;\n    }\n    else if (i == 8)\n    {   \n        continue;\n        // menuButton.onClick = `@ if (ab1InstMemory.tags.ab1RecordState)\n        // {\n        //     ab1InstMemory.tags.ab1RecordState = false;\n        //     tags.formAddress = \"check_box_outline_blank\";\n        // }\n        // else\n        // {\n        //     ab1InstMemory.tags.ab1RecordState = true;\n        //     tags.formAddress = \"check_box\";\n        // }`;\n        // menuButton.label = \"ab1.link system\";\n        // menuButton.color = ab1Color;\n        \n        // if (ab1InstMemory.tags.ab1RecordState)\n        // {\n        //     menuButton.formAddress = \"check_box\";   \n        // }\n        // else\n        // {\n        //     menuButton.formAddress = \"check_box_outline_blank\";\n        // }\n    }\n    else if (i == 9)//kill ab1\n    {\n        let versionTag = ab1InstMemory.tags.ab1Version + \".\" + ab1InstMemory.tags.ab1Iteration;\n\n        menuButton.onClick = `@  shout(\"ab1Refresh\"); shout(\"ab1Reset\"); setTag(getBots(\"ab1\"), \"destroyable\", true);\n    setTimeout(() => destroy(getBots(\"ab1UpdateID\")), 1000);`;\n        menuButton.label = \"destroy v\"+versionTag;\n        menuButton.color = \"#D66D5E\";\n        menuButton.formAddress = \"delete_forever\";\n    }\n\n    create(menuButton);\n}","ab1SelectorDrop":"@if (that.to.bot == null) //grid focus\n{\n    var menuType = \"ab1GridAction\";\n\n    if (that.dimension)\n    {\n        //grid click arm (from long click?)\n        var focusData = {\"dimension\": that.dimension, \"x\": that.position.x, \"y\": that.position.y};\n    }\n    else\n    {\n        //drag arm\n        var focusData = {\"dimension\": that.to.dimension, \"x\": that.to.x, \"y\": that.to.y};\n    }\n}\nelse //bot focus\n{\n    var menuType = \"ab1BotAction\";\n    var focusData = that.to.bot.id;\n    \n    shout(\"ab1FocusLine\", that.to.bot);\n}\n\nsetTagMask(ab1InstMemory, \"ab1Focus\", menuType);\nsetTagMask(ab1InstMemory, \"ab1FocusData\", focusData);\n\nshout(\"ab1Click\");","ab1Sleep":"@if (that == \"sleep\")\n{\n    changeState(ab1InstMemory, true, \"ab1SleepState\");\n}\nelse\n{\n    changeState(ab1InstMemory, false, \"ab1SleepState\");\n}\n\nshout(\"ab1Refresh\");\nshout(\"ab1RemindTimer\");","ab1UpdateID":"23fe09b9-89bf-484d-af70-945383a370d0","ab1Refresh":"@let previousMenu = ab1InstMemory.tags.previousMenu;\nlet currentMenu = os.getMenuDimension();\nlet ab1MenuCheck = ab1InstMemory.tags.ab1MenuState == true;\n\nif (!previousMenu && ab1MenuCheck) \n{\n    configBot.tags.menuPortal = null;\n}\nelse if (ab1MenuCheck) \n{\n    configBot.tags.menuPortal = previousMenu;\n}\n\nshout(\"ab1MenuReset\");\nclearTagMasks(ab1InstMemory);","ab1Skill":"true","onAnyBotClicked":"@let ab1 = getBot(\"ab1ID\", \"ab1\");\nconst state = os.getInputState(\"keyboard\", \"Shift\");\n\nif (ab1 != null && that.bot.tags.ab1ID != \"ab1\" && that.bot.tags.ab1MenuButton == null && state)\n{\n    //reset everything\n    shout(\"ab1Refresh\");\n\n    //focus on bot and pop menu\n    shout(\"ab1SelectorDopr\", {to: {bot: that.bot}});\n}","onAnyBotDropEnter":"@if (ab1InstMemory.tags.ab1BotSnapState == \"face\")\n{\n    os.addDropSnap(\"face\");\n}\n\nif (that.dragBot.tags.ab1ID == \"ab1Selector\")\n{\n    let ab1 = getBot(\"ab1ID\", \"ab1\");\n\n    that.dragBot.tags.strokeColor = \"clear\";\n    \n    ab1.tags.lineTo = that.to.bot.id;\n}","onAnyBotDropExit":"@if (that.dragBot.tags.ab1ID == \"ab1Selector\")\n{\n    let ab1 = getBot(\"ab1ID\", \"ab1\");\n\n    that.dragBot.tags.strokeColor = ab1InstMemory.tags.ab1Color;\n\n    ab1.tags.lineTo = that.dragBot.id;\n}","onAnyBotPointerEnter":"@if (that.bot.tags.ab1Skill)\n{\n    os.toast(that.bot.tags.ab1MenuLabel);\n    \n    that.bot.masks.scale = 1.2;\n}","onAnyBotPointerExit":"@if (that.bot.tags.ab1Skill)\n{\n    that.bot.masks.scale = 1;\n}","onChat":"@if (that.message[0] == \".\") \n{\n    if (that.message == \".download\") {\n        setTag(getBot(\"label\", \"ab1 Installer\"), \"ab1ID\", \"here\");\n        \n        let downloadBots = getBots(byMod({\"ab1ID\": null, \"space\": \"shared\"}));\n        let currentInst = os.getCurrentInst();\n\n        os.downloadBots(downloadBots, currentInst);\n        shout(\"ab1Refresh\");\n    }\n    else if (that.message == \".downloadAB1\"){\n        setTag(ab1InstMemory, \"ab1Iteration\", ab1InstMemory.tags.ab1Iteration+1);\n\n        shout(\"ab1Reset\");\n\n        ab1InstMemory.tags.baseAuxCode = null;\n\n        let learn = getBot(\"ab1ID\", \"learn\");\n        if (learn.tags.ab1SkillUsedArray)\n        {\n            let placeholders = learn.tags.ab1SkillPlaceholderArray;\n            let usedSkills = learn.tags.ab1SkillUsedArray;\n            let combinedArray = usedSkills.concat(placeholders);\n\n            learn.tags.ab1SkillPlaceholderArray = combinedArray;\n            learn.tags.ab1SkillUsedArray = null;\n        }\n\n        if (ab1InstMemory.tags.ab1SleepState == false)\n        {\n            shout(\"ab1Sleep\", \"sleep\"); \n        }\n        \n        let ab1Bots = getBots(\"ab1InitialLoad\");\n        \n        os.downloadBots(ab1Bots, \"ab1 v\"+ ab1InstMemory.tags.ab1Version + \".\" + ab1InstMemory.tags.ab1Iteration);\n    }\n    else if (that.message == \".upload\") {\n        os.showUploadAuxFile();\n    }\n    else if (that.message == \".sleep\") {\n        shout(\"ab1Reset\");\n\n        shout(\"ab1Sleep\", \"sleep\");  \n    }\n    else if (that.message == \"..\") {\n        if (ab1InstMemory.tags.ab1SleepState)\n        {\n            shout(\"ab1Sleep\", \"wake\");\n            shout(\"ab1Summon\", {type: \"emptyDimension\", position: {dimension: configBot.tags.gridPortal}});     \n        }  \n    }\n    else if (that.message == \".ab1Kill\") {\n        shout(\"ab1Reset\");\n        setTag(getBots(\"ab1\"), \"destroyable\", true);\n        setTimeout(() => destroy(getBots(\"ab1UpdateID\")), 1000);    \n    }\n    else {\n        let message = that.message;\n        let executable = message.slice(1);\n\n        os.run(executable);    \n    }\n\n    os.hideChat();\n}","onKeyDown":"@if (that.keys == \"`\"){\n    let ab1Color = ab1InstMemory.tags.ab1Color;\n\n    os.showChat({\n        placeholder: \"ping\",\n        placeholderColor: ab1Color\n    });\n}","onTapCode":"@if (that == \"3342\" && ab1InstMemory.tags.ab1SleepState == false)\n{\n    whisper(thisBot, \"ab1Sleep\", \"sleep\");\n}\nelse if (that == \"3342\")\n{\n    whisper(thisBot, \"ab1Sleep\", \"wake\");\n    shout(\"ab1Summon\", {\"type\": \"emptyDimension\", \"data\":that});\n}","scale":"1","scaleX":"0.8","scaleY":"0.8","scaleZ":"1.6","strokeColor":"orange","color":"#20dcf5","ab1InitialLoad":"true","ab1Reset":"@let ab1 = getBot(\"ab1ID\", \"ab1\");\n\nshout(\"ab1MenuReset\");\n\nif (ab1)\n{\n    destroy(ab1);\n}","ab1Z":0,"ab1X":-2,"destroyable":false,"system":"ab1.manager.command"}},"cd7fbb04-0646-48c2-9196-3a3161564e57":{"id":"cd7fbb04-0646-48c2-9196-3a3161564e57","space":"shared","tags":{"ab1":true,"strokeColor":"orange","scaleZ":"1.6","scaleY":"0.8","scaleX":"0.8","destroyable":false,"ab1UpdateID":"fa250b7e-3542-41c1-889c-fd16e33616ed","ab1ID":"searchLTM","ab1Action":"@let abID = that.text;\n\nif (ab1InstMemory.tags.ab1RecordState)\n{\n    shout(\"ab1MenuReset\");\n    \n    let menuDim = os.getMenuDimension();\n    let spaceMenuButton = {};\n\n    spaceMenuButton.space = \"tempLocal\";\n    spaceMenuButton.ab1MenuReset = \"@ destroy(thisBot);\";\n    spaceMenuButton.color = \"#908BFC\";\n    spaceMenuButton[menuDim] = true;\n    spaceMenuButton.menuItemStyle = `ðŸ§¬ {\"border-radius\": \"9px 9px 9px 9px\", \"margin-top\": \"6px\"}`;\n    spaceMenuButton.ab1Click = \"@ destroy(thisBot);\";\n    spaceMenuButton.labelAlignment = \"left\";\n    spaceMenuButton.targetAB = abID;\n    spaceMenuButton.onClick = `@ shout(\"ab1RecordLookup\", {abID: tags.targetAB, space: tags.data, manualLookup: true});`;\n    spaceMenuButton.label = \"temporary\";\n    spaceMenuButton.data = \"tempGlobal\";\n    spaceMenuButton.formAddress = \"timer\";\n\n    create(spaceMenuButton);\n\n    spaceMenuButton.label = \"permanent\";\n    spaceMenuButton.data = \"permanentGlobal\";\n    spaceMenuButton.formAddress = \"timer_off\";\n\n    create(spaceMenuButton);\n}\nelse\n{\n    shout(\"ab1LTMSearch\", abID);\n}","onQRCodeScanned":null,"color":"#908BFC","ab1Y":-5,"ab1Icon":"search","ab1MenuLabel":"search","ab1LTMSearch":"@shout(\"ab1MenuReset\");\n\nlet autoHatch;\nlet currentVariable = that;\nlet auxCheck = RegExp(/aux\\_/);\nlet jsonTest = isJson(that);\n\nif (ab1InstMemory.tags.autoHatch)\n{\n    autoHatch = true;\n}\n\nif (jsonTest == true) \n{\n    let modTags = JSON.parse(that);\n    let botID = uuid();\n    let state = {};\n\n    state[botID] = { \"id\": botID, \"space\": \"shared\", \"tags\": modTags };\n\n    let newFile = {};\n\n    newFile.version = 1;\n    newFile.state = state;\n\n    let formattedFile = JSON.stringify(newFile)\n\n    whisper(getBot(\"ab1ID\", \"auxLoader\"), \"ab1AUXFileImplement\", { \"file\": { \"data\": formattedFile, \"name\": \"mod\" } });\n    return;\n}\nelse if (auxCheck.test(currentVariable))\n{\n    var fileurlhash = currentVariable + '.aux';\n    var targetURL = ab1LongTermMemorySearch.tags.s3BaseSearchURLEgg + fileurlhash;\n    var hash = true;\n}\nelse \n{\n    let filenamehash = crypto.sha256(currentVariable);\n    var fileurlhash = \"aux_\" + filenamehash + '.aux';\n    var targetURL = ab1LongTermMemorySearch.tags.s3BaseSearchURLEgg + fileurlhash;\n}\n\nlet o = {};\no.method = \"GET\";\no.url = targetURL;\n\ntry \n{\n    var response = await webhook(o);\n\n    if(autoHatch)\n    {\n        setTagMask(ab1InstMemory, \"autoHatch\", true);\n    }\n\n} catch (e) \n{\n    try \n    {\n        console.log(\"checking old LTM\");\n        o.url = ab1LongTermMemorySearch.tags.s3BaseSearchURLOldLTM + fileurlhash\n        var response = await webhook(o);\n\n    } catch (error)\n    {\n        if (configBot.tags.ab1SilentMode == null)\n        {\n            os.toast(\"id could not be found\");\n            whisper(ab1LongTermMemorySearch, \"ab1Action\");\n            console.log(e);\n            return;\n        }\n    }\n}\n\nif (response.data.state == null) \n{\n    os.toast(\"could not find file\")\n}\nelse \n{\n    whisper(ovoNest, \"ab1EggCreate\", response);\n}\n\nfunction isJson(str) \n{\n    try \n    {\n        JSON.parse(str);\n    } catch (e) \n    {\n        //console.log(\"not JSON\");\n        return false;\n    }\n    //console.log(\"JSON\");\n    return true;\n}","s3BaseSearchURLEgg":"https://builder-stm-files.s3.amazonaws.com/","s3BaseSearchURLFile":"https://builder-ltm-files.s3.amazonaws.com/","s3BaseSearchURLOldLTM":"https://builder-files-dev.s3.amazonaws.com/","auxCodeSearch":"@//shout(\"auxCodeSearch\", {auxCode: \"\", password: \"\", autoHatch: \"\", check: \"\"})\nif (!ovoNest)\n{\n    var ovoNest = getBot(\"ab1ID\", \"ovo\");\n}\n\nif (!ab1LongTermMemorySearch)\n{\n    var ab1LongTermMemorySearch = getBot(\"ab1ID\", \"searchLTM\");\n}\n\nif (!ab1InstMemory)\n{\n    var ab1InstMemory = getBot(\"ab1ID\", \"instMemory\");\n}\n\nif (that.check == true)\n{\n    let eggCheck = await whisper(ovoNest, \"ab1EggHistoryCheck\", that.auxCode)[0] \n\n    whisper(ovoNest, \"ab1Reset\");\n    \n    return eggCheck;\n}\n\nif (that.autoHatch == true)\n{\n    ab1InstMemory.masks.autoHatch = true;\n}\n\nif (that.password)\n{\n    configBot.masks.auxKey = that.password;\n}\n\nwhisper(ab1LongTermMemorySearch, \"ab1LTMSearch\", that.auxCode);","ab1MenuLabelGridFocus":"egg","scale":1,"ab1InitialLoad":"true","ab1Skill":"true","ab1Z":0,"ab1X":-5,"onMenuCreate":"@tags.form = \"input\";\ntags.onSubmit = tags.onClick;","ab1ToolBoxAction":"@whisper(getBot(\"ab1ID\", \"ovo\"), \"ovoMenu\");\n\nlet auxCodeField = {}\n\nauxCodeField.space = \"tempLocal\";\nauxCodeField.ovoMenu = true;\nauxCodeField.ab1MenuReset = \"@ destroy(thisBot);\";\nauxCodeField.ovoMenuSortOrder = 0;\nauxCodeField.form = \"input\";\nauxCodeField.color = \"#908BFC\";\nauxCodeField.formAddress = \"egg\";\nauxCodeField.label = \"enter id\";\nauxCodeField.onSubmit = \"@ whisper(ab1LongTermMemorySearch, 'ab1LTMSearch', that.text);\";\nauxCodeField.menuItemStyle = `ðŸ§¬ {\"border-radius\": \"9px 9px 9px 9px\", \"margin-top\": \"6px\"}`;\nauxCodeField.ab1Click = \"@ destroy(thisBot);\";\nauxCodeField.labelAlignment = \"left\";\n\ncreate(auxCodeField);","ab1RecordSystem":"true","ab1LoadRecord":"@shout(\"ab1MenuReset\");\n\nlet hash = that.hash;\nlet record = that.record;\nlet abID = that.abID;\nlet hashedRecord = crypto.sha256(record.state);\nlet recordEncryption = record.abData.encrypted;\nlet key = tags.key;\n\nshout(\"ab1Refresh\");\n\nif (hash != hashedRecord)\n{\n    os.toast(\"record does not match name\");\n\n    return;\n}\n\nif (recordEncryption)\n{\n    if (!key)\n    {\n        key = await os.showInput('', {\n            type: 'secret',\n            title: 'enter a secret key'\n        });\n    }\n\n    record.state = crypto.decrypt(key, record.state);\n    record.state = JSON.parse(record.state);\n}\n\nshout(\"ab1AUXFileImplement\", {record: record.state, abID: abID});","ab1MoreRecordsButton":"@let menuDim = os.getMenuDimension();\nlet optionNum = that.maxNum;\nlet moreData = that.moreData;\nlet recordButton = {};\n\nrecordButton.space = \"tempLocal\";\nrecordButton.ab1MenuReset = \"@ destroy(thisBot);\";\nrecordButton.formAddress = \"keyboard_arrow_down\";\nrecordButton[menuDim] = true;\nrecordButton.menuDim = menuDim;\nrecordButton.color = \"#908BFC\";\nrecordButton.menuItemStyle = `ðŸ§¬ {\"border-radius\": \"9px 9px 9px 9px\", \"margin-top\": \"6px\"}`;\nrecordButton.ab1Click = \"@ destroy(thisBot);\";\nrecordButton.labelAlignment = \"center\";\nrecordButton.label = \"  \";\nrecordButton.optionNum = optionNum;\nrecordButton.moreData = moreData;\nrecordButton[menuDim+\"SortOrder\"] = 100;\nrecordButton.recordButtonReset = \"@ destroy(thisBot);\";\nrecordButton.onClick = `@ shout('recordButtonReset');\n\nlet nextMenu = getBots(tags.menuDim+\"SortOrder\", order => order < (tags.optionNum + 5));\nlet additionalBots = getBots(tags.menuDim+\"SortOrder\", order => order > (tags.optionNum + 4));\n\nif (nextMenu.length <= 5 && nextMenu.length > 0)\n{\n    setTag(nextMenu, tags.menuDim, true);\n    setTag(nextMenu, \"recordButtonReset\", \"@ destroy(thisBot);\");\n\n    if (additionalBots.length >= 1 || tags.moreData)\n    {\n        shout('ab1MoreRecordsButton', {maxNum: tags.optionNum+5, moreData: tags.moreData});\n    }\n}\nelse if (tags.moreData)\n{\n    let recordBot = getBot('ab1ID', 'searchLTM');\n\n    if (recordBot.masks.recordPass)\n    {\n        recordBot.masks.recordPass++;\n    }\n    else\n    {\n        recordBot.masks.recordPass = 1;\n    }\n\n    shout(\"ab1RecordLookup\", {abID: recordBot.tags.recordAbID, space: recordBot.tags.recordSpace, key: recordBot.tags.key});\n}`;\n\ncreate(recordButton);","ab1RecordLoadMenu":"@let records = that.records;\nlet menuDim = os.getMenuDimension();\nlet sortNum = 0;\nlet overflow;\nlet recordButton = {};\n\nrecordButton.space = \"tempLocal\";\nrecordButton.ab1MenuReset = \"@ destroy(thisBot);\";\nrecordButton.formAddress = \"egg\";\nrecordButton.color = \"#908BFC\";\nrecordButton.menuItemStyle = `ðŸ§¬ {\"border-radius\": \"9px 9px 9px 9px\", \"margin-top\": \"6px\"}`;\nrecordButton.ab1Click = \"@ destroy(thisBot);\";\nrecordButton.labelAlignment = \"left\";\nrecordButton.onClick = \"@ shout('ab1LoadRecord', {record: tags.data, hash: tags.hash, abID: tags.label});\";\n\nfor (let i = (records.length - 1); i > -1; i--)\n{\n    let currenRecord = records[i];\n    let hashPos = currenRecord.address.lastIndexOf(\"_hash_\");\n    let recordLabel = currenRecord.address.substring(4, hashPos);\n    let recordHash = currenRecord.address.substring(hashPos + 6);\n\n    recordButton.label = recordLabel;\n    recordButton.data = currenRecord.data;\n    recordButton.hash = recordHash;\n    recordButton[menuDim+\"SortOrder\"] = sortNum;\n\n    sortNum++;\n\n    if (sortNum < 6)\n    {\n        recordButton[menuDim] = true;\n        recordButton.recordButtonReset = \"@ destroy(thisBot);\";\n    }\n    else\n    {\n        overflow = true;\n        recordButton[menuDim] = false;\n        recordButton.recordButtonReset = null;\n    }\n\n    create(recordButton);\n}\n\nif (overflow)\n{\n    shout(\"ab1MoreRecordsButton\", {maxNum: 5, moreData: that.hasMoreRecords});\n}","ab1RecordLookup":"@//shout(\"ab1RecordLookup\", {abID: \"\", space: \"\", key: \"\"});\nshout(\"ab1MenuReset\");\n\nif (that.manualLookup)\n{\n    os.toast(\"looking up records\");\n}\n\nlet recordSkill = getBot(\"ab1ID\", \"publish\");\nlet authorID = recordSkill.tags.ab1AuthID;\nlet token =  recordSkill.tags.ab1AuthToken;\nlet abID = \"aux_\"+that.abID;\n\nif (that.key)\n{\n    setTagMask(thisBot, \"key\", that.key);\n}\n\nsetTagMask(thisBot, \"recordSpace\", that.space);\nsetTagMask(thisBot, \"recordAbID\", that.abID);\n\nlet records = await os.getRecords(\n    byAuthID(authorID),\n    bySpace(that.space),\n    byPrefix(abID),\n    withAuthToken(token)\n);\n\nif (tags.recordPass)\n{\n    for (let i = 0; i < tags.recordPass; i++)\n    {\n        console.log(\"get more\", records);\n        records = await records.getMoreRecords();\n    }\n}\n\nif (records.records.length < 1)\n{\n    os.toast(\"no records found that match that abID\");\n}//put in autoHatch logic here;\nelse\n{\n    whisper(thisBot, \"ab1RecordLoadMenu\", records);\n}","ab1Refresh":"@clearTagMasks(thisBot);","system":"ab1.memory.searchLTM","ab1QRSearch":"@let currentVariable = that;\nlet testVal = RegExp(/\\.com/);\nlet webTest = testVal.test(currentVariable);\n\nif (webTest) \n{\n    setTagMask(ab1InstMemory, \"autoHatch\", true);\n\n    let urlFormat = new URL(currentVariable);\n    let auxCode = urlFormat.searchParams.get(\"auxCode\");\n    let ab = urlFormat.searchParams.get(\"AB\");\n    let autoLoad = urlFormat.searchParams.get(\"autoLoad\");\n    let key = urlFormat.searchParams.get(\"auxKey\");\n    let auxKey = urlFormat.searchParams.get(\"auxKey\");\n\n    if (auxCode || ab || autoLoad) \n    {\n        if (ab) {\n            currentVariable = crypto.sha256(ab);\n        }\n        else if (autoLoad) {\n            currentVariable = crypto.sha256(autoLoad);\n        }\n        else if (auxCode) {\n            currentVariable = crypto.sha256(auxCode);\n        }\n    }\n    else \n    {\n        var targetURL = currentVariable.replace(\"/?\", \"/webhook/?\");\n        var webSite = true;\n    }\n\n    if (key) \n    {\n        configBot.masks.auxKey = key;\n    }\n    else if (auxKey) \n    {\n        configBot.masks.auxKey = auxKey;\n    }\n}\n\nwhisper(thisBot, \"ab1LTMSearch\", currentVariable);\n\nshout(\"ab1Refresh\");"}},"e8e687a2-f1b2-46b9-9b34-0059ec7883ab":{"id":"e8e687a2-f1b2-46b9-9b34-0059ec7883ab","space":"shared","tags":{"ab1":true,"ab1UpdateID":"c10ba8db-570b-41ee-9016-d5afc5bfd9db","scaleX":"0.8","scaleY":"0.8","scaleZ":"1.6","strokeColor":"orange","hatchAB1":"@shout(\"ab1Sleep\");\n\nshout(\"ab1Summon\", {type: \"initial\", dimension: [os.getCurrentDimension()]});\n\nshout(\"ab1RemindTimer\");","ovoMenu":"@configBot.tags.menuPortal = \"ovoMenu\";\n\nwhisper(thisBot, \"ovo\");","ovo":"@let ovo = getBot(\"ab1ID\", \"ovo\")\n\nif (ovo == null)\n{\n    let ovoMod = {};\n    let currentDim = os.getCurrentDimension();\n\n    ovoMod.space = \"tempLocal\";\n    ovoMod.form = \"egg\";\n    ovoMod[currentDim] = true;\n    ovoMod.draggable = false;\n    ovoMod.label = \"ovo\";\n    ovoMod.ab1ID = \"ovo\";\n    ovoMod.labelPosition = \"front\";\n    ovoMod.positioningMode = \"absolute\";\n    ovoMod.onPortalChanged = \"@ if(that.portal == 'gridPortal' || that.portal == 'sheetPortal'){shout('ab1Reset')};\";\n    ovoMod.ab1Reset = \"@ destroy(thisBot);\"\n    ovoMod.labelSize = 0.5;\n    ovoMod.orientationMode = \"billboardFront\";\n    ovoMod.scale = 0.0001;\n    ovoMod.ovoSetup = `@\n    if(tags.scale < 1)\n    {\n        await animateTag(thisBot, 'scale',{\n            toValue: 1,\n            duration: 0.5\n        });\n    }\n\n    os.tweenTo(thisBot, 12, 60, 45, 1);\n\n    setTimeout(() => whisper(getBot('ab1ID', 'searchLTM'), \"ab1Action\"), 200);`;\n    ovoMod.ab1MenuReset = \"@ destroy(thisBot);\";\n    ovoMod.onCreate = `@     await animateTag(thisBot, 'scale',{\n        toValue: 1,\n        duration: 0.5\n    });`;\n\n    create(ovoMod);\n}","destroyable":false,"color":"#908BFC","ovoVersion":"4","ovoEggDataGenerate":"@let filenamehash = crypto.sha256(that.alias); // Get the hexadecimal value of the whole filename\nlet fileurlhash = \"aux_\" + filenamehash + '.aux'; // Create hash\nlet eggVersion = that.uuid; //version id\nlet historyArray;\nlet eggID;\nlet targetVersionNum;\nlet lastHash;\nlet maxVersionNum;\n\nif (!tags.ovoEggHistory || tags.ovoEggHistory == null)//where is this coming from?\n{\n    //console.log(\"no history\")\n    historyArray = `[\"${eggVersion}\"]`;\n    eggID = uuid();\n    targetVersionNum = 1;\n    lastHash = \"none\";\n    maxVersionNum = 1;\n}\nelse\n{\n\n    let newArray = JSON.parse(tags.ovoEggHistory);\n\n    lastHash = newArray[newArray.length - 1];\n    newArray.push(eggVersion);\n    historyArray = JSON.stringify(newArray);\n    eggID = tags.ovoEggID;\n    maxVersionNum = newArray.length;\n\n    if (configBot.tags.versionDefined)\n    {\n        const definedVersion = await os.showInput(maxVersionNum, {\n            title: 'set default version',\n            placeholder: `1 to ${maxVersionNum} (leave as ${maxVersionNum} for latest)`\n        });\n\n        targetVersionNum = definedVersion;\n    }\n    else if (configBot.tags.targetVersion)\n    {\n        targetVersionNum = configBot.tags.targetVersion;\n        configBot.tags.targetVersion = null;\n    }\n    else\n    {\n        targetVersionNum = newArray.length;\n    }\n}\n\nlet egg = {};\n\negg.eggVersionHistory = historyArray;\negg.eggFormatVersion = tags.eggUUID;\negg.targetVersion = targetVersionNum;\negg.maxVersion = maxVersionNum;\negg.label = \"v\"+targetVersionNum;\negg.auxCode = that.alias;\n\nif (that.encryption == \"symmetrical\")\n{\n    egg.encryptedFile = true;\n}\n//create an egg with hatch ab1Logic\nlet state = {}\n\nstate[eggID] = egg;\n\nlet newFile = {}\nnewFile.version = 1;\nnewFile.state = state;\n\nlet formattedFile = JSON.stringify(newFile);\nlet contentTypeString =\"&contentType=text%2Fjson\";\nlet fileposturl = \"fileName=\" + fileurlhash + contentTypeString + \"&cacheControl=no-cache\";\n\nconfigBot.tags.versionDefined = null;\n\nlet latestVersion = \"v\"+maxVersionNum;\n\nreturn { \"fileposturl\": fileposturl, \"file\": formattedFile, \"inputFileExtension\": \"aux\", \"alias\": that.alias, \"eggType\": that.eggType, \"hash\": that.hash, \"lastHash\": lastHash, \"latestVersion\": latestVersion, \"eggHistory\": maxVersionNum};","ab1EggHistoryCheck":"@let filenamehash = crypto.sha256(that);\nlet fileurlhash = \"aux_\" + filenamehash + '.aux';\nlet randomVar = \"?cacheVar=\" + [uuid()];\nvar targetURL = ab1LongTermMemorySearch.tags.s3BaseSearchURLEgg + fileurlhash + randomVar;\n\nlet o = {};\n\no.method = \"GET\";\no.url = targetURL;\n\ntry \n{\n    var response = await webhook(o);\n\n} catch (e) \n{\n    try \n    {\n        o.url = ab1LongTermMemorySearch.tags.s3BaseSearchURLOldLTM + fileurlhash + randomVar\n        var response = await webhook(o);\n\n    } catch (error)\n    {\n        console.log(e);\n        return false;\n    }\n}\n\nvar ids = Object.keys(response.data.state);\nvar eggHistory = JSON.stringify(response.data.state[ids].eggVersionHistory);\n\nif (response.status !== 200) {\n    return false;\n}\nelse {\n    setTagMask(ovoNest, 'ovoEggID', ids);\n    await setTagMask(ovoNest, 'ovoEggHistory', \"ðŸ§¬ \" + eggHistory);\n\n    return true;\n}","eggUUID":"9619a9b9-ba59-418c-a221-7bb19f911f5a","ovoEggSignature":"@let signatureBot = {};\nlet date = new Date();\nlet time = date.getTime();\nlet lastHash = that.lastHash;\n\nsignatureBot.previousHash = lastHash;\nsignatureBot.ab1Version = ab1InstMemory.tags.ab1Version+\".\"+ab1InstMemory.tags.ab1Iteration;\nsignatureBot.eggVersion = tags.eggUUID;\nsignatureBot.eggVersionNum = tags.ovoVersion;\nsignatureBot.timeStamp = time;\nsignatureBot.casualOSVersion = [os.version()];\n\nreturn {signatureBot};","ab1EggCreate":"@let newEgg = that.data.state;\nlet currentDim = os.getCurrentDimension();\nlet spaceMod;\n\nif (!ab1InstMemory.tags.ab1FocusData) \n{\n    var dimensionX = null;\n    var dimensionY = null;\n}\nelse \n{\n    let hatchPoint = ab1InstMemory.tags.ab1FocusData;\n\n    currentDim = hatchPoint.dimension;\n    var dimensionX = hatchPoint.x;\n    var dimensionY = hatchPoint.y;\n    spaceMod = {space: \"shared\"};\n}\n\nif (!ab1InstMemory.tags.autoHatch &&  configBot.tags.auxCode == null)\n{\n    var dimMod = {[currentDim]: true, [currentDim+\"X\"]: dimensionX, [currentDim+\"Y\"]: dimensionY, dimension: currentDim}\n}\nelse\n{\n    let key;\n\n    if (configBot.tags.auxKey)\n    {\n        key = configBot.tags.auxKey;\n    }\n    else if (configBot.tags.key)\n    {\n        key = configBot.tags.key\n    }\n\n    var dimMod = {onCreate: `@whisper(thisBot, 'ovoHatch', {auxKey: '${key}', autoHatch: true});`};\n}\n\nvar eggMod = await whisper(thisBot, \"ovoEggTagGenerate\");\n\nfor (const property in newEgg) {\n    const newBot = newEgg[property];\n\n    create(newBot, eggMod, dimMod, spaceMod);\n}\n\nshout(\"ab1Reset\");","ab1EggClick":"@tags.initialTimer = null;\nlet eggMenuButton = {};\nos.tweenTo(thisBot, 15,45,45, 5);\nconfigBot.tags.menuPortal = 'ab1EggMenu';\n\nsetTagMask(ab1InstMemory, \"ab1MenuState\", true);\n\nshout(\"eggMenuReset\");\n\neggMenuButton.space = \"tempLocal\";\neggMenuButton.ab1EggMenu = true;\neggMenuButton.egg = getID(thisBot);\neggMenuButton.targetVersion = tags.targetVersion;\neggMenuButton.menuItemStyle = 'ðŸ§¬ {\"border-radius\": \"9px 9px 9px 9px\", \"margin-top\": \"6px\"}';\neggMenuButton.label = \"hatch \" + tags.auxCode + \" v\" + tags.targetVersion + \" of \" + tags.maxVersion;\neggMenuButton.eggMenuReset = \"@ destroy(thisBot);\";\neggMenuButton.onGridClick = \"@ destroy(thisBot);\";\neggMenuButton.color = \"#FFFFFF\";\neggMenuButton.onClick = \"@ await shout('eggMenuReset'); whisper(getBot('id', tags.egg), 'ovoHatch');\";\n\ncreate(eggMenuButton);","ab1EggOnKeyDown":"@if (that.keys == \"Shift\")\n{\nlet versionButton = {};\n\nversionButton.space = \"tempLocal\";\nversionButton.ab1EggMenu = true;\nversionButton.maxVersion = tags.maxVersion;\nversionButton.egg = getID(thisBot);\nversionButton.menuItemStyle = 'ðŸ§¬ {\"border-radius\": \"9px 9px 9px 9px\", \"margin-top\": \"6px\"}';\nversionButton.label = \"change egg version\";\nversionButton.eggMenuReset = \"@ destroy(thisBot);\";\nversionButton.onGridClick = \"@ destroy(thisBot);\";\nversionButton.color = \"#FFFFFF\";\nversionButton.onKeyUp = \"@ if(that.keys == 'Shift'){destroy(thisBot)};\";\nversionButton.onClick = \"@ os.showInputForTag(getBot('id', tags.egg), 'targetVersion', {'placeholder': 'enter a version from 1 to ' + tags.maxVersion}); shout('eggMenuReset');\";\n\ncreate(versionButton);\n\nlet versionArray = JSON.parse(tags.eggVersionHistory);\nlet fileUUID = versionArray[tags.targetVersion-1];\nlet hash = crypto.sha256(fileUUID);\n\nlet hashButton = {};\n\nhashButton.space = \"tempLocal\";\nhashButton.ab1EggMenu = true;\nhashButton.targetHash = hash;\nhashButton.egg = getID(thisBot);\nhashButton.menuItemStyle = 'ðŸ§¬ {\"border-radius\": \"9px 9px 9px 9px\", \"margin-top\": \"6px\"}';\nhashButton.label = \"copy hash to clipboard\";\nhashButton.eggMenuReset = \"@ destroy(thisBot);\";\nhashButton.onGridClick = \"@ destroy(thisBot);\";\nhashButton.color = \"#FFFFFF\";\nhashButton.onKeyUp = \"@ if(that.keys == 'Shift'){destroy(thisBot)};\";\nhashButton.onClick = \"@ os.setClipboard('aux_' + tags.targetHash + '.aux'); shout('eggMenuReset'); os.toast('hash copied to clipboard');\";\n\ncreate(hashButton);\n}","ovoEggTagGenerate":"@let eggMod = {}\n\neggMod.space = \"tempLocal\";\neggMod.initialTimer = true;\neggMod.ovoHatch = ab1Publish.tags.hatchLogic;\neggMod.onClick = tags.ab1EggClick;\neggMod.onKeyDown = tags.ab1EggOnKeyDown;\neggMod.onSaveInput = \"@ tags.label = 'v'+tags.targetVersion;\";\neggMod.onCreate = `@ tags.progressBar = 0;tags.interval = setInterval(() => {whisper(thisBot, \"eggTimer\");}, 75);`;\neggMod.form = \"egg\";\neggMod.progressBarColor = \"#BF5E66\";\neggMod.progressBarBackgroundColor = \"#592989\";\neggMod.labelSize = 0.5;\neggMod.labelColor = \"#404040\";\neggMod.onPointerEnter = \"@ os.toast(tags.auxCode + ' v'+tags.targetVersion);\";\neggMod.labelPosition = \"front\";\neggMod.orientationMode = \"billboardFront\";\neggMod.eggTimer = `@ if (tags.progressBar < 1) \n{\n    tags.progressBar += 0.1;\n}\nelse\n{\n    clearTimeout(tags.interval);\n    tags.interval = null;\n    whisper(thisBot, \"onClick\");\n    tags.progressBar = null;\n}`;\n\nreturn eggMod;","ab1MenuLabel":"share egg","ab1Icon":"ios_share","onMenuCreate":"@let selectedBot = getBot(\"id\", ab1InstMemory.tags.ab1FocusData);\n\nif (selectedBot.tags.auxCode == null || selectedBot.tags.eggFormatVersion == null)\n{\n    destroy(thisBot);\n}","ab1X":0,"s3BaseSearchURLEgg":"https://builder-stm-files.s3.amazonaws.com/","onQRCodeScannerClosed":null,"scale":1,"ab1InitialLoad":"true","ab1Skill":"true","ab1ID":"ovo","ab1BotAction":"@let selectedBot = getBot(\"id\", ab1InstMemory.tags.ab1FocusData);\n\ntry \n{\n    await os.share({ url: `https://casualos.com/?autoLoad=${selectedBot.tags.auxCode}` });\n}\ncatch (error) \n{\n    os.setClipboard(`https://casualos.com/?autoLoad=${selectedBot.tags.auxCode}`);\n    os.toast(\"id copied to clipboard\");\n}\n\nshout(\"ab1Refresh\");","ab1Reset":"@clearTagMasks(thisBot);","ab1Z":0,"ab1Y":-2,"system":"ab1.memory.ovo","ovoAbSetup":"@let currentABS = getBots(\"ab\").length;\nlet ab = {}\n\nab.ab1ID = \"abEgg\";\nab.abID = \"abEgg\";\nab.space = \"shared\";\nab.onClick = tags.ovoABLogic;\nab.form = \"egg\";\nab.ab = true;\nab.abX = currentABS;\nab.label = that;\nab.targetAB = that;\nab.labelColor = \"#404040\";\nab.labelPosition = \"front\";\nab.orientationMode = \"billboardFront\";\nab.auxCodeOrigin = that;\n\ncreate(ab);","ovoABLogic":"@let menuDim = os.getMenuDimension();\n\nshout(\"abButtonReset\");\n\nif (menuDim == null)\n{\n    configBot.tags.menuPortal = \"ovoMenu\";\n    menuDim = \"ovoMenu\";\n}\n\nlet abMenuButton = {};\n\nabMenuButton.space = \"tempLocal\";\nabMenuButton.ab1MenuReset = \"@ destroy(thisBot);\";\nabMenuButton.color = \"red\";\nabMenuButton[menuDim] = true;\nabMenuButton.menuItemStyle = `ðŸ§¬ {\"border-radius\": \"9px 9px 9px 9px\", \"margin-top\": \"6px\"}`;\nabMenuButton.ab1Click = \"@ destroy(thisBot);\";\nabMenuButton.labelAlignment = \"left\";\nabMenuButton.label = \"remove \" + tags.targetAB + \" ab\";\nabMenuButton.targetAB = tags.targetAB;\nabMenuButton.formAddress = \"egg\";\nabMenuButton.abButtonReset = \"@ destroy(thisBot);\"\nabMenuButton.onClick = `@ destroy(getBots('auxCodeOrigin', tags.targetAB)); shout('abButtonReset');`;\n\ncreate(abMenuButton);"}},"ec2f5f47-2691-4e51-aa0d-8cdb8c683041":{"id":"ec2f5f47-2691-4e51-aa0d-8cdb8c683041","space":"shared","tags":{"ab1":true,"strokeColor":"orange","scaleZ":"1.6","scaleY":"0.8","scaleX":"0.8","destroyable":false,"ab1Action":"@shout(\"ab1MenuReset\");\n\nlet menuDim = os.getMenuDimension();\nlet menuButton = {};\n\nmenuButton.space = \"tempLocal\";\nmenuButton[menuDim] = true;\nmenuButton.ab1MenuReset = \"@ destroy(thisBot);\";\nmenuButton.ab1Click = \"@ destroy(thisBot);\";\nmenuButton.menuItemStyle = `ðŸ§¬ {\"border-radius\": \"9px 9px 9px 9px\", \"margin-top\": \"6px\"}`;\nmenuButton.labelAlignment = \"left\";\nmenuButton.ab1MenuButton = true;\nmenuButton[menuDim+\"SortOrder\"] = 10;\n\nmenuButton.label = \"download\";\nmenuButton.formAddress = \"get_app\";\nmenuButton.color = \"#55E679\";\nmenuButton.onClick = `@ let downloadBots = getBots(byMod({\"ab1ID\": null, \"ab1Ignore\": null, \"space\": \"shared\"}));\nlet currentInst = os.getCurrentInst();\n\nos.downloadBots(downloadBots, currentInst);\n\nshout(\"ab1Refresh\");`;\n\n//create download button\ncreate(menuButton);\n\nmenuButton[menuDim+\"SortOrder\"] = 9;\nmenuButton.label = \"encrypt\";\nmenuButton.formAddress = \"check_box_outline_blank\";\nmenuButton.encryptState = false;\nmenuButton.color = \"#908BFC\";\nmenuButton.onClick = `@ if(tags.encryptState)\n    {\n        tags.encryptState = false;\n        tags.formAddress = 'check_box_outline_blank';\n        configBot.tags.encryption = null;\n    }\n    else\n    {\n        tags.encryptState = true;\n        tags.formAddress = 'check_box';\n        configBot.tags.encryption = true;\n    }`;\n\n//create encrypt button\ncreate(menuButton);\n\nmenuButton[menuDim+\"SortOrder\"] = 0;\n\nif (ab1InstMemory.tags.ab1RecordState)\n{\n    menuButton.encryptState = null;\n    menuButton.color = \"#908BFC\";\n    menuButton.form = \"input\";\n    menuButton.formAddress = \"egg\";\n    menuButton.label = \"publish record\";\n    menuButton.onSubmit = `@ shout('ab1RecordSpaceMenu', {type: 'publish', record: that.text});`;\n}\nelse\n{\n    menuButton[menuDim] = null;\n    menuButton.dimension = menuDim;\n    menuButton.onKeyDown = `@\n    if (that.keys[0] == \"Shift\")\n    {\n        tags[tags.dimension] = true;\n    }`;\n    menuButton.onKeyUp = `@\n    if (that.keys[0] == \"Shift\")\n    {\n        tags[tags.dimension] = false;\n    }`;\n    menuButton[menuDim+\"SortOrder\"] = -1;\n    menuButton.buttonState = \"automatic\";\n    menuButton.color = \"#908BFC\";\n    menuButton.formAddress = \"check_box\";\n    menuButton.label = \"automatic version\";\n    menuButton.onClick = `@\n    if(tags.buttonState == 'automatic')\n    {\n        tags.buttonState = 'manual';\n        tags.formAddress = 'check_box_outline_blank';\n        configBot.tags.versionDefined = true;\n    }\n    else\n    {\n        tags.label = 'automatic version';\n        tags.formAddress = 'check_box';\n        configBot.tags.versionDefined = null;\n    }`;\n\n    //create version button\n    create(menuButton);\n\n    menuButton[menuDim] = true;\n    menuButton.dimension = null;\n    menuButton.onKeyDown = null;\n    menuButton.onKeyUp = null;\n    menuButton[menuDim+\"SortOrder\"] = null;\n    menuButton.buttonState = null;\n    menuButton.color = \"#908BFC\";\n    menuButton.form = \"input\";\n    menuButton.formAddress = \"egg\";\n    menuButton.label = \"publish\";\n    menuButton.onSubmit = `@ let auxCodeValidTest = await shout('auxCodeValidation', that.text)[0];\n        \n        if (auxCodeValidTest)\n        {\n            shout('ab1InitiatePublish', {fileName: that.text, manualPublish: true});\n        }\n        else\n        {\n            tags.label = 'publish';\n        };`;\n}\n\n//create the publish button (either s3 or record)\ncreate(menuButton);\n\nif (that.ab1BotAction)\n{\n    menuButton[menuDim+\"SortOrder\"] = 9;\n    menuButton.form = null;\n    menuButton.label = \"copy to clipboard\";\n    menuButton.formAddress = \"file_copy\";\n    menuButton.color = \"#55E679\";\n    menuButton.onClick = `@ let selectedBot = getBot(\"id\", ab1InstMemory.tags.ab1FocusData);\n    let preppedBot = JSON.stringify(selectedBot);\n    let state = {}\n\n    state[ab1InstMemory.tags.ab1FocusData] = selectedBot;\n\n    let newFile = {}\n    newFile.version = 1;\n    newFile.state = state;\n\n    var formattedFile = JSON.stringify(newFile);\n\n    os.setClipboard(formattedFile);\n    os.toast(\"bot copied to clipboard\");\n    shout(\"ab1Refresh\");`;\n\n    //create \n    create(menuButton);\n}","ab1UpdateID":"ccd8a3b3-fca7-4f39-8139-52a4ac82b92d","hatchLogic":"@if (that)\n{\n    var auxKey = that.auxKey;\n    var autoHatch = that.autoHatch;\n}\n\nif (tags.encryptedFile != true || auxKey != null)\n{\n    shout(\"eggEnd\");\n\n    let versionArray = JSON.parse(tags.eggVersionHistory);\n    let fileUUID = versionArray[tags.targetVersion-1];\n    let filenamehash = crypto.sha256(fileUUID);\n    let fileurlhash = \"aux_\" + filenamehash + '.aux';\n    let targetURL = ab1LongTermMemorySearch.tags.s3BaseSearchURLFile + fileurlhash;\n\n    let o = {};\n    o.method = \"GET\";\n    o.url = targetURL;\n\n    try\n    {\n        var response = await webhook(o);\n    }\n    catch (e)\n    {\n        try\n        {\n            console.log(\"checking old ltm\")\n            o.url = ab1LongTermMemorySearch.tags.s3BaseSearchURLOldLTM+fileurlhash;\n\n            response = await webhook(o);\n        }\n        catch (error)\n        {\n            if (tags.targetVersion > 1)//if the first attempt failed, fall back to previous\n            {\n                let fileUUID = versionArray[tags.targetVersion-1];\n                let filenamehash = crypto.sha256(fileUUID);\n                let fileurlhash = \"aux_\" + filenamehash + '.aux';\n                let targetURL = ab1LongTermMemorySearch.tags.s3BaseSearchURLFile + fileurlhash;\n\n                let o = {};\n                o.method = \"GET\";\n                o.url = targetURL;\n            \n                try\n                {\n                    response = await webhook(o);\n                }\n                catch (e)\n                {\n                    console.log(\"no file found\");\n                    os.toast(\"no file found\");\n                }\n            }\n            else\n            {\n                console.log(\"no file found\");\n                os.toast(\"no file found\");\n            }\n        }\n    }\n\n    if (response.status !== 200) {\n        console.log('[boot] could not download aux file');\n        return;\n    }\n    else {\n        //console.log('loaded aux file' + targetURL);\n    }\n\n    if (tags.encryptedFile == true && tags.eggKeyPair != null)\n    {\n        const encryptedData = response.data;\n        var dataOutput = JSON.parse(crypto.asymmetric.decrypt(tags.eggKeyPair, auxKey, encryptedData)).state;\n    }\n    else if (tags.encryptedFile == true)\n    {\n        const encryptedData = response.data;\n        var dataOutput = JSON.parse(crypto.decrypt(auxKey, encryptedData)).state;        \n    }\n    else\n    {\n        var dataOutput = response.data.state;\n    }\n\n    let idMap = new Map();\n    let newBots = []\n\n    for (const property in dataOutput) {\n        const newBot = dataOutput[property];\n        const ab1FocusPoint = ab1InstMemory.tags.ab1FocusPoint;\n        const botTotal = Object.keys(dataOutput).length;\n        const auxCodeOrigin = {auxCodeOrigin: tags.auxCode};\n\n        if (newBot.tags)\n        {\n            if (newBot.tags.creator)\n            {\n                auxCodeOrigin.oldCreator = newBot.tags.creator;\n            }\n\n            try\n            {\n                if (botTotal > 1 || ab1FocusPoint == null)\n                {\n                    var b = create(newBot.tags, auxCodeOrigin);\n                }\n                else\n                {\n                    let targetDimension = ab1FocusPoint.dimension;\n                    let targetPosition = {[targetDimension]: true, [targetDimension+\"X\"]: ab1FocusPoint.x, [targetDimension+\"Y\"]: ab1FocusPoint.y}\n\n                    var b = create(newBot.tags, targetPosition, auxCodeOrigin);\n                }\n                \n                idMap.set(property, b.id);\n                newBots.push(b);\n\n                if (b.tags.creator == thisBot.id)\n                {\n                    b.tags.creator = null;\n                }\n            }\n            catch(error)\n            {\n                console.log(\"invalid bot\", error);\n            }\n        }\n        else  \n        {\n            console.log(\"skipped bot: \" + newBot);\n        }\n    }\n\n    let linkTags = [\"link\", \"creator\", \"configBot\", \"lineTo\", \"transformer\"];\n\n    for (let newBot of newBots)\n    {\n        for (let tag of linkTags)\n        {\n            let value = newBot.tags[tag];\n\n            updateBotLinks(newBot, idMap);\n\n            if (tag == \"creator\")\n            {\n                value = newBot.tags.oldCreator;\n                newBot.tags.oldCreator = null;\n            }\n\n            if (value)\n            {\n                if (Array.isArray(value))\n                {\n                    let newValue = value.map(id => {\n                        return idMap.get(id) || id;\n                    })\n\n                    newBot.raw[tag] = newValue;\n                }\n                else\n                {\n                    const newID = idMap.get(value);\n\n                    if (newID)\n                    {\n                        newBot.raw[tag] = newID;\n                    }\n                }\n            }\n        }\n    }\n\n    if (!autoHatch)\n    {\n        configBot.tags.menuPortal = null;\n    }\n\n    if (configBot.tags.ab1SilentMode == null)\n    {\n        os.toast(\"hatched \" + tags.auxCode + \" v\" + tags.targetVersion);\n    }\n\n    configBot.tags.lastEggHatched = tags.auxCode;\n    destroy(thisBot);\n    shout(\"ab1Refresh\");\n    whisper(newBots, \"onEggHatch\", {dimension: tags.dimension, position: {x: tags[tags.dimension+ \"X\"], y: tags[tags.dimension+ \"Y\"]}});\n    whisper(ovoNest, \"ovoAbSetup\", tags.auxCode);\n}\nelse\n{\n    let menuDim = os.getMenuDimension();\n\n    if (!menuDim)\n    {\n        menuDim = \"ovoHatchMenu\";\n    }\n\n    let auxKeyButton = {};\n\n    auxKeyButton.space = \"tempLocal\";\n    auxKeyButton[menuDim] = true;\n    auxKeyButton.color = \"white\";\n    auxKeyButton.form = \"input\";\n    auxKeyButton.ab1MenuReset = \"@ destroy(thisBot);\";\n    auxKeyButton.ovoMenuSortOrder = 0;\n    auxKeyButton.label = \"enter key\";\n    auxKeyButton.onSubmit = \"@ shout('ovoHatch', {auxKey: that.text});\";\n    auxKeyButton.menuItemStyle = `ðŸ§¬ {\"border-radius\": \"9px 9px 9px 9px\", \"margin-top\": \"6px\"}`;\n    auxKeyButton.ab1Click = \"@ destroy(thisBot);\";\n    auxKeyButton.labelAlignment = \"left\";\n\n    create(auxKeyButton);\n}","ab1ID":"publish","ab1MenuLabel":"share","ab1Icon":"ios_share","color":"#908BFC","ab1X":6,"publishAuxCode":"@//shout(\"publishAuxCode\", {auxCode: \"\", password: \"\", target: \"\"});\nlet targetBots = that.target;\nlet historyLookup = await whisper(ovoNest, \"ab1EggHistoryCheck\", that.auxCode)[0];\n\nif (targetBots != null)\n{\n    configBot.tags.publishTarget = targetBots;\n}\n\nwhisper(thisBot, \"ab1InitiatePublish\", {fileName: that.auxCode, password: that.password});","onQRCodeScanned":null,"auxCodeValidation":"@let firstChar = that[0];\nlet spaceCheck = RegExp(/ /);\n\nawait whisper(ovoNest, \"ab1EggHistoryCheck\", that)[0];\n\nif (isNaN(firstChar) == false || firstChar == null) \n{\n    os.toast(\"auxCodes may not start with a number or contain spaces\");\n    return false;\n}\nelse if (spaceCheck.test(that) == true) \n{\n    os.toast(\"auxCodes may not contain spaces\");\n    return false;\n}\n\nreturn true;","ab1InitiatePublish":"@shout(\"ab1MenuReset\");\n\nif (that.manualPublish)\n{\n    os.toast(\"publishing...\", 10);\n}\n\nlet newAlias = that.fileName//tags.eggFileName;\nlet fileUUID = uuid();\nlet filenamehash = crypto.sha256(fileUUID);\nlet fileurlhash = \"aux_\" + filenamehash + '.aux';\nlet contentTypeString = \"&contentType=text%2Fjson\";\nlet fileposturl = \"fileName=\" + fileurlhash + contentTypeString + \"&cacheControl=max-age=31180\";\nlet password;\nlet encryption;\nlet eggType;\n\nif(configBot.tags.encryption)\n{\n    password = await os.showInput(\"\", {\n            type: 'secret',\n            title: 'enter a secret key'\n        });\n\n    passwordCheck = await os.showInput(\"\", {\n        type: 'secret',\n        title: 'confirm secret key'\n    });\n\n    if (password != passwordCheck) {\n        os.toast(\"keys do not match\");\n\n        shout(\"ab1Refresh\");\n\n        return;\n    }\n}\nelse if (that.password)\n{\n    password = that.password;\n}\n\nif (password) {\n    encryption = \"symmetrical\";\n    eggType = \"[PRIVATE]\";\n}\nelse {\n    eggType = \" \";\n}\n\nlet eggDataGenerate = await whisper(ovoNest, \"ovoEggDataGenerate\", { \"alias\": newAlias, \"encryption\": encryption, \"uuid\": fileUUID, \"eggType\": eggType, \"hash\": filenamehash, \"secretKey\": password})[0];\n\nif (newAlias && configBot.tags.publishTarget == null) {\n    let bots = getBots(byMod({ \"ab1ID\": null, \"ab1Ignore\": null, \"space\": \"shared\"}));\n\n    if (bots == null)\n    {\n        shout(\"ab1Refresh\");\n        os.toast(\"no bots to publish\");\n        return;\n    }\n\n    let state = {}\n    for (let bot of bots) {\n        if (bot.tags.label != \"ab1 Installer\") {\n            state[bot.id] = bot;\n        }\n    }\n\n    let generateEggSignature = await whisper(ovoNest, \"ovoEggSignature\", eggDataGenerate.lastHash);\n\n    state.signature = generateEggSignature;\n\n    let newFile = {}\n    newFile.version = 1;\n    newFile.state = state;\n    var formattedFile = JSON.stringify(newFile);\n\n    if (encryption == \"symmetrical\") {\n        formattedFile = crypto.encrypt(password, formattedFile);\n    }\n}\nelse if (newAlias) {\n    let targetBot = configBot.tags.publishTarget;\n\n    if (targetBot == null)\n    {\n        shout(\"ab1Refresh\");\n        os.toast(\"no bots to publish\");\n        return;\n    }\n\n    let state = {}\n\n    if (Array.isArray(targetBot) == true) {\n        for (let i = 0; i < targetBot.length; i++) {\n            let currentBotID = targetBot[i]\n            let currentBot = getBot(\"id\", currentBotID);\n\n            state[currentBotID] = currentBot;\n        }\n    }\n    else {\n        state[targetBot] = getBot('id', targetBot);\n    }\n\n    let newFile = {}\n    newFile.version = 1;\n    newFile.state = state;\n\n    var formattedFile = JSON.stringify(newFile);\n\n    if (encryption == \"symmetrical\") {\n        formattedFile = crypto.encrypt(password, formattedFile);\n    }\n}\nelse {\n    os.toast(\"no alias given\");\n    return;\n}\n\n//upload aux file\nlet fileUpload = await whisper(ab1LongTermMemory, \"ab1ProcessFile\", { \"fileposturl\": fileposturl, \"file\": formattedFile, \"inputFileExtension\": \"aux\", auxCode: newAlias, auxKey: password, manualPublish: that.manualPublish})[0];\n\neggDataGenerate.egg = true;\n\n//create or update egg for the above aux file\nwhisper(ab1LongTermMemory, \"ab1ProcessFile\", eggDataGenerate);\n\nconfigBot.tags.publishTarget = null;\nconfigBot.tags.encryption = null;\n\nshout(\"ab1Reset\");\n\nshout(\"ab1RemindTimer\");","scale":1,"ab1Skill":"true","ab1InitialLoad":"true","ab1BotAction":"@let selectedBot = ab1InstMemory.tags.ab1FocusData;\n\nconfigBot.tags.publishTarget = selectedBot;\n\nwhisper(ab1Publish, \"ab1Action\", {ab1BotAction: true});","ab1Reset":"@configBot.tags.publishTarget = null;\nconfigBot.tags.versionDefined = null;\nconfigBot.tags.encryption = null;","ab1Z":0,"ab1Y":6,"onMenuCreate":"@if (ab1InstMemory.tags.ab1RecordState)\n{\n    tags.label = \"publish record\";\n}","ab1RecordSystem":"true","ab1AuthID":"did:ethr:0x8008eebCf41B6d298fb6b0d0fc3C525DdAD1e9Fc","ab1AuthToken":"WyIweDM0ZjA1ZjVkYTM5M2RmODgwNjE4YzllMzNjY2UxZDBhZTg2YTFmMDQwZmRjZmI2ZjQ5YzJhODBkNTk0NmFlNTE3NWRkNmE2YTY4YzljMTRjODIxMjliODc0OWVkMjY4NzA4NTdjNTdmNmJjMGE0MjYyOGRiMGE3YzE0NzRjZTg5MWMiLCJ7XCJpYXRcIjoxNjM1MTg0MzA1LFwiZXh0XCI6MzMxNzExODQzMDUsXCJpc3NcIjpcImRpZDpldGhyOjB4ODAwOGVlYkNmNDFCNmQyOThmYjZiMGQwZmMzQzUyNURkQUQxZTlGY1wiLFwic3ViXCI6XCJtcW1sNzE3aDVYX2ItVU5TLTdyenV3TGVnLXhDMTBGVmNBV21GVlB6QkFVPVwiLFwiYXVkXCI6XCJKYVBsclVhZmU3ZGF4Q1BoYXlpSzNmcC1MM3JlSGZfN1ZlZk9FOWVIZUo4PVwiLFwibmJmXCI6MTYzNTE4NDMwNSxcInRpZFwiOlwiMGQ5NzkxMTItYWE3NC00ZTcxLWI1NzAtNjJmZTk4OWQ2ZWIyXCIsXCJhZGRcIjpcIjB4MDYyM2NhYzQzYjNiZTQ0YTkyOTg0YjE3ODQwNmZkZjI0ODlhMjhlNThmMzZjODc2ODk3MzAwZDJmODA0NDE3NjY5ZTg0ZjRkNzk4NjM1ZTc1YzI0ZDk4ZTI1NzFmNWE4ZDgyYmZmM2M5NTAxNmUwOWI0MDNhZDdkOWY2ZWIxNjcxYlwifSJd.ab1","ab1PublishRecord":"@//shout(\"ab1PublishRecord\", {abID: \"\", data: \"\", key: \"\", space: \"\"});\nos.toast(\"initiating record publish\", 3);\n\nshout(\"ab1MenuReset\");\n\nif (!authBot)\n{\n    os.toast(\"requesting authorization\");\n\n    let verification = await os.requestAuthBot();\n\n    if (verification)\n    {\n        os.toast(\"authorization received\");\n    }\n    else\n    {\n        os.toast(\"authorization failed\");\n        shout(\"ab1Refresh\");\n        return;\n    }\n}\n\nlet recordConfig = {space: that.space};\nlet version = os.version();\nlet date = new Date();\nlet time = date.getTime();\nlet recordData = {};\nlet botData;\nlet encryption;\nlet location;\nlet previousRecordHash;\n\ntry \n{\n    location = await os.getGeolocation();\n}\ncatch (e)\n{\n    location = \"no data\";\n}\n\nif (that.target)\n{\n    botData = that.data;\n}\nelse if (ab1InstMemory.tags.ab1Focus == \"ab1BotAction\")\n{\n    botData = [getBot(\"id\", ab1InstMemory.tags.ab1FocusData)];\n}\nelse\n{\n    botData  = getBots(byMod({ \"ab1ID\": null, \"space\": \"shared\" }));\n}\n\nif (that.key || configBot.tags.encryption)\n{\n    let key = that.key;\n\n    if (configBot.tags.encryption)\n    {\n        configBot.tags.encryption = null;\n        \n        key = await os.showInput(\"\", {\n            type: 'secret',\n            title: 'enter a secret key'\n        });\n\n        keyCheck = await os.showInput(\"\", {\n            type: 'secret',\n            title: 'confirm secret key'\n        });\n\n        if (key != keyCheck)\n        {\n            os.toast(\"keys do not match\");\n            \n            shout(\"ab1Refresh\");\n            \n            return;\n        }\n    }\n\n    encryption = true;\n    botData = JSON.stringify(botData);\n    botData = crypto.encrypt(key, botData);\n}\nelse\n{\n    encryption = false;\n}\n\ntry\n{\n    let previousRecord = await os.getRecords(\n        byAuthID(tags.ab1AuthID),\n        bySpace(that.space),\n        byPrefix(\"aux_\"+that.abID),\n        withAuthToken(tags.ab1AuthToken)\n    );\n\n    if (previousRecord.records.length > 0)\n    {\n        previousRecordHash = previousRecord.records[previousRecord.records.length - 1].address;\n    }\n    else\n    {\n        previousRecordHash = \"no data\";\n    }\n}\ncatch (e)\n{\n    previousRecordHash = \"no data\";\n}\n\nrecordData.state = botData;\nrecordData.abData = {previousRecord: previousRecordHash, encrypted: encryption, space: that.space, location: location, time: time, version: version.version};\n\nlet recordHash = crypto.sha256(recordData.state);\n//let randomID = uuid();\n\nrecordConfig.authToken = tags.ab1AuthToken;\nrecordConfig.record = recordData;\nrecordConfig.address = \"aux_\" + that.abID + \"_\" + time + \"_hash_\" + recordHash;\n\n//console.log(\"config\",recordConfig)\n\ntry\n{\n    let newRecord = await os.publishRecord(recordConfig);\n\n    //console.log(newRecord);\n}\ncatch (error)\n{\n    console.log(error);\n    os.toast(\"unable to publish record\");\n    shout(\"ab1Refresh\");\n    return;\n}\n\nos.toast(recordConfig.address + \" published!\");\nos.setClipboard(recordConfig.address);\n\nshout(\"ab1Refresh\");","system":"ab1.memory.publish","ab1RecordSpaceMenu":"@shout(\"ab1MenuReset\");\n\nlet menuType = that.type;\nlet recordName = that.record;\nlet menuDim = os.getMenuDimension();\nlet spaceMenuButton = {};\n\nspaceMenuButton.space = \"tempLocal\";\nspaceMenuButton.ab1MenuReset = \"@ destroy(thisBot);\";\nspaceMenuButton.color = \"#908BFC\";\nspaceMenuButton[menuDim] = true;\nspaceMenuButton.menuItemStyle = `ðŸ§¬ {\"border-radius\": \"9px 9px 9px 9px\", \"margin-top\": \"6px\"}`;\nspaceMenuButton.ab1Click = \"@ destroy(thisBot);\";\nspaceMenuButton.labelAlignment = \"left\";\nspaceMenuButton.label = \"temporary\";\nspaceMenuButton.data = \"tempGlobal\";\nspaceMenuButton.formAddress = \"timer\";\nspaceMenuButton.onClick = `@ shout(\"ab1PublishRecord\", {abID: '${recordName}', space: tags.data});`;\n\ncreate(spaceMenuButton);\n\nspaceMenuButton.label = \"permanent\";\nspaceMenuButton.data = \"permanentGlobal\";\nspaceMenuButton.formAddress = \"timer_off\";\n\ncreate(spaceMenuButton);","ab1QRPublish":"@let currentVariable = that;\nlet testVal = RegExp(/\\.com/);\nlet webTest = testVal.test(currentVariable);\nlet abID;\nlet password;\n\nif (webTest) {\n    let urlFormat = new URL(currentVariable);\n    let auxCode = urlFormat.searchParams.get(\"auxCode\");\n    let ab = urlFormat.searchParams.get(\"AB\");\n    let autoLoad = urlFormat.searchParams.get(\"autoLoad\");\n    let auxKey = urlFormat.searchParams.get(\"auxKey\");\n    let key = urlFormat.searchParams.get(\"key\");\n\n    if (ab) {\n        abID = ab;\n    }\n    else if (autoLoad) {\n        abID = autoLoad;\n    }\n    else if (auxCode) {\n        abID = auxCode;\n    }\n\n    if (auxKey) {\n        password = auxKey;\n    }\n    else if (key) {\n        password = ley;\n    }\n}\nelse if (auxCodeValidTest) {\n    abID = that;\n}\n\nwhisper(thisBot, \"ab1InitiatePublish\", { fileName: abID, password: password });\n\nshout(\"ab1Refresh\");"}},"f66829d4-fd59-4fc4-b486-9a8ea115e22d":{"id":"f66829d4-fd59-4fc4-b486-9a8ea115e22d","space":"shared","tags":{"listeningForFileUploads":"true","scaleX":"0.8","scaleY":"0.8","scaleZ":"1.6","strokeColor":"orange","ab1":true,"ab1UpdateID":"1a04103a-35f4-44a1-b1a2-1058f5d2667e","onFileUpload":"@let inputFileExtension = that.file.name.split('.').pop(); // Parse out the extension\nlet inputFilename = that.file.name.split('.').shift(); // Parse out the filename\n\n// Determine what the file is and how to handle it\nswitch(inputFileExtension)\n{\n  case 'jpg':\n  case 'jpeg':\n  case 'webp':\n  case 'gif':\n  case 'png':\n    var uploadMenu = \"ab1ImageUpload\";\n    break;\n  case 'glb':\n  case 'gltf':\n    var uploadMenu = \"ab1MeshUpload\";\n    break;\n  case 'aux':\n    var uploadMenu = \"ab1AUXFileImplement\";\n    break;\n  case 'pdf':\n    var uploadMenu = \"ab1PDFUpload\";\n    break;\n  case 'mp3':\n    var uploadMenu = \"ab1Mp3Upload\";\n    break;\n  case 'mp4':\n    var uploadMenu = \"ab1Mp4Upload\";\n    break;\n  default:\n    // Unknown type, throw an error and return\n    result = new Error(\"Unhandled file type: \" + inputFileExtension);\n    console.warn(result)\n    return result;\n}\n\nif(thisBot.tags.listeningForFileUploads === true) // Allow listening to be easily toggled\n{\n  if (inputFileExtension != \"aux\")\n  {\n    os.toast(inputFileExtension + \" is uploading to ltm\");\n  }\n  console.log(uploadMenu)\n  let file = await Promise.race( whisper(thisBot, uploadMenu,that)) // Wrapped the whisper in a Promise to make sure it's synced up\n}","ab1ID":"auxLoader","ab1MenuLabel":"aux loader","ab1Y":2,"color":"#20dcf5","ab1X":2,"scale":1,"ab1InitialLoad":"true","ab1Skill":"true","ab1AUXFileImplement":"@let origin;\nlet auxFile;\nlet auxkey = false;\nlet dataOutput;\n\nif (that.file) \n{\n    let unformattedFile = JSON.parse(that.file.data);\n    auxFile = unformattedFile.state;\n    origin = that.file.name;\n}\nelse if (that.record)\n{\n    auxFile = that.record;\n    origin = that.abID;\n}\nelse if (that.hash)\n{\n    let url = ab1LongTermMemorySearch.tags.s3BaseSearchURLFile + that.hash;\n    console.log(url)\n    let response = await web.hook({\n        method: \"GET\",\n        url: url\n    });\n    console.log(response)\n    auxFile = response.data.state;\n    origin = that.hash;\n}\n\nif (configBot.tags.key)\n{\n    auxKey = configBot.tags.key;\n}\nelse if (configBot.tags.auxKey)\n{\n    auxKey = configBot.tags.auxKey\n}\n\nif (configBot.tags.keyPair)\n{\n    const encryptedData = auxFile;\n    dataOutput = JSON.parse(crypto.asymmetric.decrypt(configBot.tags.keyPair, auxKey, encryptedData)).state;\n}\nelse if (auxkey) \n{\n    const encryptedData = auxFile;\n    dataOutput = JSON.parse(crypto.decrypt(auxKey, encryptedData)).state;\n}\nelse \n{\n    dataOutput = auxFile;\n}\n\nlet idMap = new Map();\nlet newBots = []\n\nfor (const property in dataOutput) \n{\n    const newBot = dataOutput[property];\n    const ab1FocusPoint = getBot(\"ab1ID\", \"instMemory\").tags.ab1FocusData;\n    const botTotal = Object.keys(dataOutput).length;\n    const auxCodeOrigin = { auxCodeOrigin: origin };\n\n    if (newBot.tags) \n    {\n        if (newBot.tags.creator) \n        {\n            auxCodeOrigin.oldCreator = newBot.tags.creator;\n        }\n\n        try \n        {\n            if (botTotal > 1 || (tags.hatchPoint == null && ab1FocusPoint == null)) \n            {\n                var b = create(newBot.tags, auxCodeOrigin);\n            }\n            else if (tags.hatchPoint) \n            {\n                let targetDimension = tags.hatchPoint.dimension;\n                let targetPosition = { [targetDimension]: true, [targetDimension + \"X\"]: tags.hatchPoint.x, [targetDimension + \"Y\"]: tags.hatchPoint.y }\n\n                var b = create(newBot.tags, targetPosition, auxCodeOrigin);\n            }\n            else \n            {\n                let targetDimension = ab1FocusPoint.dimension;\n                let targetPosition = { [targetDimension]: true, [targetDimension + \"X\"]: ab1FocusPoint.x, [targetDimension + \"Y\"]: ab1FocusPoint.y }\n\n                var b = create(newBot.tags, targetPosition, auxCodeOrigin);\n            }\n\n            idMap.set(property, b.id);\n            newBots.push(b);\n\n            if (b.tags.creator == thisBot.id) \n            {\n                b.tags.creator = null;\n            }\n        }\n        catch (error) \n        {\n            console.log(\"invalid bot\", error);\n        }\n    }\n    else \n    {\n        console.log(\"skipped bot: \" + newBot);\n    }\n}\n\nlet linkTags = [\"link\", \"creator\", \"configBot\", \"lineTo\", \"transformer\"];\n\nfor (let newBot of newBots) \n{\n    for (let tag of linkTags) \n    {\n        let value = newBot.tags[tag];\n\n        if (tag == \"creator\") \n        {\n            value = newBot.tags.oldCreator;\n            newBot.tags.oldCreator = null;\n        }\n\n        if (value) \n        {\n            if (Array.isArray(value)) \n            {\n                let newValue = value.map(id => {\n                    return idMap.get(id) || id;\n                })\n\n                newBot.raw[tag] = newValue;\n            }\n            else \n            {\n                const newID = idMap.get(value);\n\n                if (newID) \n                {\n                    newBot.raw[tag] = newID;\n                }\n            }\n        }\n    }\n}\n\nconfigBot.tags.lastEggHatched = origin;\nshout(\"ab1Refresh\");\nwhisper(newBots, \"onEggHatch\");","ab1ImageUpload":"@let inputFileExtension = that.file.name.split('.').pop(); // Parse out the extension\nlet newFileName = uuid()+ that.file.name;\nlet filenamehash = crypto.sha256(newFileName);\nlet fileurlhash = filenamehash + '.' + inputFileExtension; // Create hash\n\n// Initialize some vars\nlet contentTypeString = \"image/\"+inputFileExtension;\ncontentTypeString = \"&contentType=\" + contentTypeString.replace('/','%2F')\nlet fileposturl = \"fileName=\" + fileurlhash + contentTypeString + \"&cacheControl='max-age=31180'\";\n\nwhisper(ab1LongTermMemory, \"ab1ProcessFile\", {\"fileposturl\": fileposturl, \"file\": that, \"formType\": \"sprite\", \"inputFileExtension\": inputFileExtension});","ab1CreateMediaBot":"@let processedData = that.file;\n\nif(that.formType != null)\n{\n  processedData.bot = await create(\n    {\n      creator: null,\n      [os.getCurrentDimension()]: true, //may need to update this\n      name: processedData.fileName,\n      contentType: processedData.contentType,\n      form: that.formType,\n      formSubtype: that.formSubtype,\n      formAddress: processedData.url\n    }\n  );\n  os.toast(\"bot added to inst\");\n}\nelse\n{\n  os.setClipboard(processedData.url);\n\n  os.toast(\"URL copied to clipboard\");\n}","ab1MeshUpload":"@let inputFileExtension = that.file.name.split('.').pop(); // Parse out the extension\nlet newFileName = uuid()+ that.file.name;\nlet filenamehash = crypto.sha256(newFileName);\nlet fileurlhash = filenamehash + '.' + inputFileExtension; // Create hash\n\n// Initialize some vars\nlet contentTypeString = \"text/xml\";\ncontentTypeString = \"&contentType=\" + contentTypeString.replace('/','%2F')\nlet fileposturl = \"fileName=\" + fileurlhash + contentTypeString + \"&cacheControl='max-age=31180'\";\n\nwhisper(ab1LongTermMemory, \"ab1ProcessFile\", {\"fileposturl\": fileposturl, \"file\": that, \"formType\": \"mesh\", \"formSubtype\": \"gltf\", \"inputFileExtension\": inputFileExtension});","ab1Mp3Upload":"@let inputFileExtension = that.file.name.split('.').pop(); // Parse out the extension\nlet newFileName = uuid()+ that.file.name;\nlet filenamehash = crypto.sha256(newFileName);\nlet fileurlhash = filenamehash + '.' + inputFileExtension; // Create hash\n\n// Initialize some vars\nlet contentTypeString = 'audio/mpeg';\ncontentTypeString = \"&contentType=\" + contentTypeString.replace('/','%2F')\nlet fileposturl = \"fileName=\" + fileurlhash + contentTypeString + \"&cacheControl='max-age=31180'\";\n\nwhisper(ab1LongTermMemory, \"ab1ProcessFile\", {\"fileposturl\": fileposturl, \"file\": that, \"inputFileExtension\": inputFileExtension});","ab1Mp4Upload":"@os.toast(\"not currently supported\");","ab1PDFUpload":"@let fileData = that.file.data;\nlet formattedData = os.parseBotsFromData(fileData);\n\nfor (const property in formattedData) \n{\n    const newBot = formattedData[property];\n    const ab1FocusPoint = ab1InstMemory.tags.ab1FocusPoint;\n    const botTotal = Object.keys(formattedData).length;\n\n    if (newBot.tags) \n    {\n        try \n        {\n            if (botTotal > 1 || ab1FocusPoint == null) \n            {\n                var b = create(newBot.tags);\n            }\n            else \n            {\n                let targetDimension = ab1FocusPoint.dimension;\n                let targetPosition = { [targetDimension]: true, [targetDimension + \"X\"]: ab1FocusPoint.x, [targetDimension + \"Y\"]: ab1FocusPoint.y }\n\n                var b = create(newBot.tags, targetPosition);\n            }\n\n            idMap.set(property, b.id);\n            newBots.push(b);\n\n            if (b.tags.creator == thisBot.id) \n            {\n                b.tags.creator = null;\n            }\n        }\n        catch (error) \n        {\n            console.log(\"invalid bot\", error);\n        }\n    }\n    else \n    {\n        console.log(\"skipped bot: \" + newBot);\n    }\n}","ab1Z":0,"destroyable":false,"onKeyDown":"@if (that.keys == \"c\")\n{\n    var metaInput = os.getInputState(\"keyboard\", \"Meta\");\n    var selectedBot = getBot(\"id\", ab1InstMemory.tags.ab1FocusData);\n\n    if(metaInput && selectedBot)\n    {\n        let state = {}\n\n        state[ab1InstMemory.tags.ab1FocusData] = selectedBot;\n\n        let newFile = {}\n        newFile.version = 1;\n        newFile.state = state;\n\n        var formattedFile = JSON.stringify(newFile);\n\n        os.setClipboard(formattedFile);\n        os.toast(\"bot copied to clipboard\");\n    }\n}","system":"ab1.manager.auxLoader"}},"f7fe142b-b332-4f28-8678-010c2094e333":{"id":"f7fe142b-b332-4f28-8678-010c2094e333","space":"shared","tags":{"ab1":true,"ab1ID":"instMemory","destroyable":false,"scaleZ":"1.6","scaleY":"0.8","scaleX":"0.8","ab1UpdateID":"3fcf5414-0b26-49c9-8c16-42c1d8f7ebf9","ab1SleepStateAsleepOnEnter":"@shout(\"ab1Reset\")","strokeColor":"orange","ab1Y":-2,"ab1X":2,"ab1MenuLabel":"inst memory","color":"#20dcf5","ab1Color":"#908BFC","scale":1,"ab1BotSnapState":"face","ab1GridSnapState":true,"ab1SleepState":true,"ab1Version":"7","ab1InitialLoad":"true","ab1Skill":"true","ab1Reset":"@clearTagMasks(thisBot, \"tempLocal\");","ab1Iteration":76,"ab1MenuState":"false","ab1Z":0,"ab1Focus":"ab1Action","ab1SaveState":null,"ab1RecordState":false,"system":"ab1.manager.instMemory"}}}}