// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
  binaryTargets = ["native", "rhel-openssl-1.0.x", "debian-openssl-3.0.x", "linux-arm64-openssl-3.0.x"]
  output   = "../prisma/generated"
  previewFeatures = ["tracing"]
}

datasource db {
  provider = "cockroachdb"
  url      = env("DATABASE_URL")
}

// Auth
model User {
    id String @id
    name String? @db.String(128)
    email String? @db.String(128)
    phoneNumber String? @db.String(64)
    avatarPortraitUrl String?
    avatarUrl String?
    allSessionRevokeTime DateTime?
    currentLoginRequestId String? @unique
    currentLoginRequest LoginRequest? @relation("CurrentLoginRequest", fields: [currentLoginRequestId], references: [requestId])
    currentWebAuthnChallenge String?
    banTime DateTime?
    banReason String? @db.String(128)

    privoServiceId String? @unique
    privoParentServiceId String?
    privoConsentUrl String?

    subscriptionInfoId String? @unique @db.Uuid
    subscriptionInfo Subscription? @relation(fields: [subscriptionInfoId], references: [id])

    subscriptionStatus String?
    stripeCustomerId String? @unique
    subscriptionId String?
    subscriptionPeriodStart DateTime?
    subscriptionPeriodEnd DateTime?

    allowPublishData Boolean?
    allowPublicData Boolean?
    allowAI Boolean?
    allowPublicInsts Boolean?

    role String?

    // The Studio that this user logs into.
    // Used to differentiate between users who belong to the primary instance
    // and users who belong to a comId.
    // Note that this does not grant any permissions to the studio. It only separates users via comId.
    loginStudioId String?
    loginStudio Studio? @relation(fields: [loginStudioId], references: [id], onDelete: Cascade, map: "User_loginStudioId_fkey1")

    stripeAccountId String? @unique
    stripeAccountRequirementsStatus String?
    stripeAccountStatus String?
    requestedRate Int?

    accounts FinancialAccount[]

    loginRequests LoginRequest[]
    webauthnLoginRequests WebAuthnLoginRequest[]
    sessions AuthSession[]
    records Record[]
    recordKeys RecordKey[]
    roleAssignments RoleAssignment[]
    // TODO: Support global permissions
    // globalPermissionAssignments GlobalPermissionAssignment[]
    resourcePermissionAssignments ResourcePermissionAssignment[]
    markerPermissionAssignments MarkerPermissionAssignment[]

    publishedDataRecords DataRecord[] @relation("PublishedDataRecords")
    subjectDataRecords DataRecord[] @relation("SubjectDataRecords")

    publishedManualDataRecords ManualDataRecord[] @relation("PublishedManualDataRecords")
    subjectManualDataRecords ManualDataRecord[] @relation("SubjectManualDataRecords")

    publishedFileRecords FileRecord[] @relation("PublishedFileRecords")
    subjectFileRecords FileRecord[] @relation("SubjectFileRecords")

    studios StudioAssignment[]
    aiChatMetrics AiChatMetrics[]
    aiImageMetrics AiImageMetrics[]
    aiSkyboxMetrics AiSkyboxMetrics[]
    aiSloydMetrics AiSloydMetrics[]
    aiOpenAIRealtimeMetrics AiOpenAIRealtimeMetrics[]

    instReports UserInstReport[]
    comIdRequests StudioComIdRequest[]
    authenticators UserAuthenticator[]

    webhookRecords WebhookRecord[]
    pushSubscriptions PushSubscriptionUser[]
    notificationSubscriptions NotificationSubscription[]
    sentNotifications SentPushNotification[]

    packageReviews PackageRecordVersionReview[]
    grantedPackageEntitlements GrantedPackageEntitlement[]
    loadedPackages LoadedPackage[]

    checkoutSessions AuthCheckoutSession[]
    purchasedItems PurchasedItem[]

    issuedContracts ContractRecord[] @relation("IssuerUser")
    heldContracts ContractRecord[] @relation("HoldingUser")
    externalPayouts ExternalPayout[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@unique([email, loginStudioId])
    @@unique([phoneNumber, loginStudioId])
}

model UserAuthenticator {
    id String @id @db.Uuid

    userId String
    user User @relation(fields: [userId], references: [id], onDelete: Cascade, map: "UserAuthenticator_userId_fkey1")

    credentialId String @db.String(512) @unique
    credentialPublicKey Bytes @db.Bytes()

    counter Int
    credentialDeviceType String @db.String(32)
    credentialBackedUp Boolean

    aaguid String @db.Uuid
    registeringUserAgent String? @db.String(512)

    transports String[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model LoginRequest {
    requestId String @id
    userId String
    user User @relation(fields: [userId], references: [id], onDelete: Cascade, map: "LoginRequest_userId_fkey1")
    
    secretHash String?

    requestTime DateTime
    expireTime DateTime
    completedTime DateTime?
    
    attemptCount Int
    address String
    addressType String
    ipAddress String

    // oidCodeVerifier String?
    // oidCodeMethod String?
    // oidProvider String?
    // oidRedirectUrl String?
    // oidScope String?
    
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    sessions AuthSession[]
    activeUser User? @relation("CurrentLoginRequest")
}

model AuthSession {
    sessionId String @id
    userId String
    user User @relation(fields: [userId], references: [id], onDelete: Cascade, map: "AuthSession_userId_fkey1")

    secretHash String
    connectionSecret String?

    oidProvider String?
    oidAccessToken String?
    oidTokenType String?
    oidIdToken String?
    oidRefreshToken String?
    oidScope String?
    oidExpiresAtMs BigInt?

    grantedTime DateTime
    expireTime DateTime?
    revokeTime DateTime?

    revocable  Boolean?

    requestId String?
    request LoginRequest? @relation(fields: [requestId], references: [requestId])

    oidRequestId String? @db.Uuid
    oidRequest OpenIDLoginRequest? @relation(fields: [oidRequestId], references: [requestId], map: "AuthSession_oidRequestId_fkey1")

    webauthnRequestId String? @db.Uuid
    webauthnRequest WebAuthnLoginRequest? @relation(fields: [webauthnRequestId], references: [requestId], map: "AuthSession_webauthnRequestId_fkey1")

    previousSessionId String? @unique
    previousSession AuthSession? @relation("PreviousSession", fields: [previousSessionId], references: [sessionId])
    previousSession1 AuthSession? @relation("PreviousSession")

    nextSessionId String? @unique
    nextSession AuthSession? @relation("NextSession", fields: [nextSessionId], references: [sessionId])
    nextSession1 AuthSession? @relation("NextSession")

    ipAddress String?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model OpenIDLoginRequest {
    requestId String @id @db.Uuid
    state String? @unique @db.Uuid

    provider String
    codeVerifier String
    codeMethod String
    authorizationUrl String
    redirectUrl String
    scope String

    requestTime DateTime
    expireTime DateTime
    completedTime DateTime?
    ipAddress String

    authorizationCode String?
    authorizationTime DateTime?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    authSessions AuthSession[]
}

model WebAuthnLoginRequest {
    requestId String @id @db.Uuid
    challenge String

    userId String?
    user User? @relation(fields: [userId], references: [id], onDelete: Cascade, map: "WebAuthnLoginRequest_userId_fkey1")

    requestTime DateTime
    expireTime DateTime
    completedTime DateTime?
    ipAddress String

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    authSessions AuthSession[]
}

model EmailRule {
    id BigInt @id @default(autoincrement())
    type String
    pattern String
}

model SmsRule {
    id BigInt @id @default(autoincrement())
    type String
    pattern String
}

// Records
model Studio {
    id String @id
    displayName String @db.String(128)

    // The comId for this studio. (i.e. a name/uuid that can be used to access this studio as a comId)
    comId String? @unique

    logoUrl String? @db.String(512)

    // The comId that this studio belongs to. (i.e. The comId of the studio that this studio belongs to)
    ownerStudioComId String?
    ownerStudio Studio? @relation(fields: [ownerStudioComId], references: [comId], onUpdate: Cascade, onDelete: SetNull, map: "Studio_ownerStudioComId_fkey1", name: "OwnerStudio")

    // The player web config for this studio.
    playerConfig Json?

    // The player web manifest for this studio.
    playerWebManifest Json?

    // The comId config for this studio.
    comIdConfig Json?

    // The loom app id and private key for this studio.
    loomConfig Json?

    // The hume apiKey and secretKey for this studio.
    humeConfig Json?

    records Record[]
    assignments StudioAssignment[]

    subscriptionInfoId String? @unique @db.Uuid
    subscriptionInfo Subscription? @relation(fields: [subscriptionInfoId], references: [id])

    subscriptionStatus String?
    stripeCustomerId String? @unique
    subscriptionId String?
    subscriptionPeriodStart DateTime?
    subscriptionPeriodEnd DateTime?

    stripeAccountId String? @unique
    stripeAccountRequirementsStatus String?
    stripeAccountStatus String?

    aiChatMetrics AiChatMetrics[]
    aiImageMetrics AiImageMetrics[]
    aiSkyboxMetrics AiSkyboxMetrics[]
    aiSloydMetrics AiSloydMetrics[]
    aiOpenAIRealtimeMetrics AiOpenAIRealtimeMetrics[]
    customDomains CustomDomain[]

    accounts FinancialAccount[]
    users User[]

    childStudios Studio[] @relation("OwnerStudio")
    comIdRequests StudioComIdRequest[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model StudioAssignment {
    @@id([studioId, userId])

    studioId String
    studio Studio @relation(fields: [studioId], references: [id])

    userId String
    user User @relation(fields: [userId], references: [id])

    isPrimaryContact Boolean
    role String

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model Record {
    name String @id @db.String(128)
    ownerId String?
    owner User? @relation(fields: [ownerId], references: [id], map: "Record_ownerId_fkey1")

    studioId String?
    studio Studio? @relation(fields: [studioId], references: [id])

    secretHashes String[]
    secretSalt String

    recordKeys RecordKey[]
    policies Policy[]
    roles Role[]
    roleAssignments RoleAssignment[]

    dataRecords DataRecord[]
    manualDataRecords ManualDataRecord[]
    fileRecords FileRecord[]
    eventRecords EventRecord[]
    instRecords InstRecord[]
    instBranches InstBranch[]
    branchUpdates BranchUpdate[]
    webhookRecords WebhookRecord[] @relation("WebhookRecord")
    targetWebhookRecords WebhookRecord[] @relation("TargetWebookRecord")
    webhookRuns WebhookRun[]

    packageRecords PackageRecord[]
    packageRecordVersions PackageRecordVersion[]

    searchRecords SearchRecord[]

    databaseRecords DatabaseRecord[]

    notificationRecords NotificationRecord[]
    notificationSubscriptions NotificationSubscription[]
    sentNotifications SentNotification[]
    purchasableItems PurchasableItemRecord[]
    purchasedItems PurchasedItem[]

    contracts ContractRecord[]

    resourceAssignments ResourcePermissionAssignment[]
    markerAssignments MarkerPermissionAssignment[]

    grantedEntitlements GrantedPackageEntitlement[]


    userInstReports UserInstReport[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model RecordKey {
    @@id([recordName, secretHash])

    recordName String @db.String(128)
    record Record @relation(fields: [recordName], references: [name], onDelete: Cascade, map: "RecordKey_recordName_fkey1")

    secretHash String
    policy String
    creatorId String
    creator User @relation(fields: [creatorId], references: [id])

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

// Policies
model Policy {
    @@id([recordName, marker])

    recordName String @db.String(128)
    record Record @relation(fields: [recordName], references: [name], onDelete: Cascade, map: "Policy_recordName_fkey1")
    marker String @db.String(128)
    document Json
    markers String[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model Role {
    @@id([recordName, name])
    recordName String @db.String(128)
    record Record @relation(fields: [recordName], references: [name], onDelete: Cascade, map: "Role_recordName_fkey1")

    name String @db.String(128)
    markers String[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model RoleAssignment {
    @@id([recordName, roleId, subjectId])

    recordName String @db.String(128)
    record Record @relation(fields: [recordName], references: [name], onDelete: Cascade, map: "RoleAssignment_recordName_fkey1")
    roleId String @db.String(128)

    subjectId String
    type String
    expireTime DateTime?

    userId String?
    user User? @relation(fields: [userId], references: [id])

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@index([recordName, subjectId])
    @@index([recordName, roleId])
}

// TODO: Support global permissions
// model GlobalPermissionAssignment {
//     // The ID of the assignment
//     id String @db.Uuid @id

//     // The kind of the resource.
//     // If null, then permission for all resource kinds is granted.
//     resourceKind String?

//     // The action that the assignment grants.
//     // If null, then the assignment grants every action to the resource.
//     action String?

//     // The options that the assignment grants.
//     options Json?

//     // The ID of the subject that the assignment grants permission to.
//     // This can be the ID of the user or the ID of the inst that permission is granted to.
//     subjectId String

//     // The type of the subject that the assignment grants permission to.
//     // This can be "user", "inst" or "role"
//     // If "role", then all users/insts that have the role in the record are granted permission.
//     // If "inst" or "user", then the given user/inst is granted permission across all records.
//     subjectType String

//     // The ID of the user that the assignment grants permission to.
//     // Null if the subjectType is "role" or "inst"
//     userId String?
//     user User? @relation(fields: [userId], references: [id], onDelete: Cascade, map: "GlobalPermissionAssignment_userId_fkey1")

//     // The time that the assignment expires.
//     // Null means that the assignment never expires.
//     expireTime DateTime?

//     createdAt DateTime @default(now())
//     updatedAt DateTime @updatedAt

//     @@index([subjectType, subjectId])
//     @@index([resourceKind, action, subjectType, subjectId])
// }

model ResourcePermissionAssignment {
    // The ID of the assignment
    id String @db.Uuid @id

    // The name of the record.
    recordName String
    record Record @relation(fields: [recordName], references: [name], onDelete: Cascade, map: "ResourcePermissionAssignment_recordName_fkey1")

    // The kind of the resource.
    resourceKind String

    // The ID of the resource.
    resourceId String

    // The action that the assignment grants.
    // If null, then the assignment grants every action to the resource.
    action String?

    // The options that the assignment grants.
    options Json?

    // The ID of the subject that the assignment grants permission to.
    // This can be the ID of the user or the ID of the inst that permission is granted to.
    subjectId String

    // The type of the subject that the assignment grants permission to.
    // This can be "user", "inst" or "role"
    subjectType String

    // The ID of the user that the assignment grants permission to.
    // Null if the subjectType is "role" or "inst"
    userId String?
    user User? @relation(fields: [userId], references: [id], onDelete: Cascade, map: "ResourcePermissionAssignment_userId_fkey1")

    // The time that the assignment expires.
    // Null means that the assignment never expires.
    expireTime DateTime?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@index([subjectType, subjectId, recordName])
    @@index([recordName, resourceKind, resourceId, action, subjectType, subjectId])
}

// Example query:
// SELECT * FROM "ResourcePermissionAssignment"
// WHERE "recordName" = recordName AND "resourceKind" = resourceKind
// AND "resourceId" = resourceId AND "action" = action
// AND (
//    ("subjectId" = subjectId AND "subjectType" = subjectType) OR 
//    ("subjectType" = 'role' AND "subjectId" IN (SELECT "roleId" FROM "RoleAssignment" WHERE "recordName" = recordName AND "subjectId" = subjectId AND "subjectType" = subjectType)))

model MarkerPermissionAssignment {
    // The ID of the assignment
    id String @db.Uuid @id

    // The name of the record.
    recordName String
    record Record @relation(fields: [recordName], references: [name], onDelete: Cascade, map: "MarkerPermissionAssignment_recordName_fkey1")

    // The marker of the resources that the assignment grants.
    // If null, then the assignment grants permission for a resource instead.
    marker String @db.String(128)

    // The resource kind that this assignment is for.
    // If null, then the assignment is for all resource kinds.
    resourceKind String?

    // The action that the assignment grants.
    // If null, then the assignment grants every action to the resource.
    action String?

    // The options that the assignment grants.
    options Json?

    // The ID of the subject that the assignment grants permission to.
    // This can be the ID of the user or the ID of the inst that permission is granted to.
    subjectId String

    // The type of the subject that the assignment grants permission to.
    // This can be "user", "inst" or "role"
    subjectType String

    // The ID of the user that the assignment grants permission to.
    // Null if the subjectType is "role" or "inst"
    userId String?
    user User? @relation(fields: [userId], references: [id], onDelete: Cascade, map: "MarkerPermissionAssignment_userId_fkey1")

    // The time that the assignment expires.
    // Null means that the assignment never expires.
    expireTime DateTime?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@index([subjectType, subjectId, recordName])
    @@index([recordName, marker, action, subjectType, subjectId])
}

model GrantedPackageEntitlement {
    id String @db.Uuid @id

    // The ID of the user that granted the entitlement
    userId String
    user User @relation(fields: [userId], references: [id], onDelete: Cascade, map: "GrantedPackageEntitlement_userId_fkey1")

    // The ID of the package that the entitlement is granted for
    packageId String @db.Uuid
    package PackageRecord @relation(fields: [packageId], references: [id], onDelete: Cascade, map: "GrantedPackageEntitlement_packageId_fkey1")

    // The feature that the entitlement covers
    feature String @db.String(32)

    // The scope of the entitlement
    scope String @db.String(32)

    // The record that was designated by the entitlement
    recordName String
    record Record @relation(fields: [recordName], references: [name], onDelete: Cascade, map: "GrantedPackageEntitlement_recordName_fkey1")

    // The time that the entitlement grant expires
    expireTime DateTime

    // The time that the entitlement was revoked
    revokeTime DateTime?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

// Example query:
// SELECT * FROM "ResourcePermissionAssignment"
// WHERE "recordName" = recordName AND "marker" = marker AND "action" = action
// AND (
//    ("subjectId" = subjectId AND "subjectType" = subjectType) OR 
//    ("subjectType" = 'role' AND "subjectId" IN (SELECT "roleId" FROM "RoleAssignment" WHERE "recordName" = recordName AND "subjectId" = subjectId AND "subjectType" = subjectType)))

// Data
model DataRecord {
    @@id([recordName, address])

    recordName String @db.String(128)
    record Record @relation(fields: [recordName], references: [name], onDelete: Cascade, map: "DataRecord_recordName_fkey1")
    
    address String @db.String(512)
    data Json
    
    publisherId String
    publisher User @relation("PublishedDataRecords", fields: [publisherId], references: [id])

    subjectId String?
    subject User? @relation("SubjectDataRecords", fields: [subjectId], references: [id])

    updatePolicy Json
    deletePolicy Json

    markers String[]

    targetWebhookRecords WebhookRecord[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

// ManualData
model ManualDataRecord {
    @@id([recordName, address])

    recordName String @db.String(128)
    record Record @relation(fields: [recordName], references: [name], onDelete: Cascade, map: "ManualDataRecord_recordName_fkey1")
    
    address String @db.String(512)
    data Json
    
    publisherId String
    publisher User @relation("PublishedManualDataRecords", fields: [publisherId], references: [id])

    subjectId String?
    subject User? @relation("SubjectManualDataRecords", fields: [subjectId], references: [id])

    updatePolicy Json
    deletePolicy Json

    markers String[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model FileRecord {
    @@id([recordName, fileName])

    recordName String @db.String(128)

    // Don't cascade FileRecord deletes because they have storage in other places besides the database
    record Record @relation(fields: [recordName], references: [name])
    fileName String @db.String(512)

    publisherId String?
    publisher User? @relation("PublishedFileRecords", fields: [publisherId], references: [id])

    subjectId String?
    subject User? @relation("SubjectFileRecords", fields: [subjectId], references: [id])

    sizeInBytes BigInt
    description String? @db.String(128)

    bucket String?

    uploadedAt DateTime?

    markers String[]

    targetWebhookRecords WebhookRecord[]

    webhookRuns WebhookRun[]
    packageVersions PackageRecordVersion[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model EventRecord {
    @@id([recordName, name])

    recordName String @db.String(128)
    record Record @relation(fields: [recordName], references: [name], onDelete: Cascade, map: "EventRecord_recordName_fkey1")
    name String @db.String(128)

    count BigInt
    markers String[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model InstRecord {
    @@id([recordName, name])

    recordName String @db.String(128)
    record Record @relation(fields: [recordName], references: [name], onDelete: Cascade, map: "InstRecord_recordName_fkey1")

    name String @db.String(128)

    markers String[]

    branches InstBranch[]
    updates BranchUpdate[]
    userInstReports UserInstReport[]
    webhookRecords WebhookRecord[]
    loadedPackages LoadedPackage[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model InstBranch {
    @@id([recordName, instName, name])

    recordName String @db.String(128)
    record Record @relation(fields: [recordName], references: [name], onDelete: Cascade, map: "InstBranch_recordName_fkey1")

    instName String @db.String(128)
    inst InstRecord @relation(fields: [recordName, instName], references: [recordName, name], onDelete: Cascade, map: "InstBranch_instName_fkey1")

    name String @db.String(512)
    temporary Boolean

    updates BranchUpdate[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model BranchUpdate {
    id String @id @db.Uuid()

    recordName String @db.String(128)
    record Record @relation(fields: [recordName], references: [name], onDelete: Cascade, map: "BranchUpdate_recordName_fkey1")

    instName String @db.String(128)
    inst InstRecord @relation(fields: [recordName, instName], references: [recordName, name], onDelete: Cascade, map: "BranchUpdate_instName_fkey1")

    branchName String @db.String(512)
    branch InstBranch @relation(fields: [recordName, instName, branchName], references: [recordName, instName, name], onDelete: Cascade, map: "BranchUpdate_branchName_fkey1")

    sizeInBytes Int
    updateData String

    createdAt DateTime @default(now())
    updated DateTime @updatedAt

    @@index([recordName, instName, branchName, id])
}

// A package that has been loaded into an inst
model LoadedPackage {
    id String @id @db.Uuid

    // The ID of the user that loaded the package
    // Null if the user was deleted or if the package was loaded by the system
    userId String?
    user User? @relation(fields: [userId], references: [id], onDelete: SetNull, map: "LoadedPackage_user_fkey1")

    packageId String @db.Uuid
    package PackageRecord @relation(fields: [packageId], references: [id], onDelete: Cascade, map: "LoadedPackage_packageId_fkey1")

    packageVersionId String @db.Uuid
    packageVersion PackageRecordVersion @relation(fields: [packageVersionId], references: [id], onDelete: Cascade, map: "LoadedPackage_packageVersionId_fkey1")

    // The inst that the package was loaded into
    instRecordName String @db.String(128)
    instName String @db.String(128)
    branch String @db.String(512)
    inst InstRecord @relation(fields: [instRecordName, instName], references: [recordName, name], onDelete: Cascade, map: "LoadedPackage_inst_fkey1")

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model WebhookRecord {
    @@id([recordName, address])

    recordName String @db.String(128)
    record Record @relation("WebhookRecord", fields: [recordName], references: [name], onDelete: Cascade, map: "WebhookRecord_recordName_fkey1")

    address String @db.String(512)

    markers String[]

    targetRecordName String? @db.String(128)
    targetRecord Record? @relation("TargetWebookRecord", fields: [targetRecordName], references: [name], onDelete: SetNull, map: "WebhookRecord_targetRecordName_fkey1")

    targetDataRecordAddress String? @db.String(512)
    targetDataRecord DataRecord? @relation(fields: [targetRecordName, targetDataRecordAddress], references: [recordName, address], onDelete: SetNull, map: "WebhookRecord_targetDataRecordAddress_fkey1")

    targetFileRecordFileName String? @db.String(512)
    targetFileRecord FileRecord? @relation(fields: [targetRecordName, targetFileRecordFileName], references: [recordName, fileName], onDelete: SetNull, map: "WebhookRecord_targetFileRecordFileName_fkey1")

    targetInstRecordName String? @db.String(128)
    targetInstRecord InstRecord? @relation(fields: [targetRecordName, targetInstRecordName], references: [recordName, name], onDelete: SetNull, map: "WebhookRecord_targetInstRecordName_fkey1")

    targetPublicInstRecordName String? @db.String(128)

    userId String?
    user User? @relation(fields: [userId], references: [id])

    runs WebhookRun[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model WebhookRun {
    id String @id @db.Uuid

    recordName String @db.String(128)
    record Record @relation(fields: [recordName], references: [name], onDelete: Cascade, map: "WebhookRun_recordName_fkey1")

    webhookAddress String @db.String(512)
    webhook WebhookRecord @relation(fields: [recordName, webhookAddress], references: [recordName, address], onDelete: Cascade, map: "WebhookRun_webhookAddress_fkey1")

    statusCode Int?
    stateSha256 String @db.String(64)

    requestTime DateTime
    responseTime DateTime

    errorResult Json?

    infoFileRecordName String? @db.String(128)
    infoFileName String? @db.String(512)
    infoFile FileRecord? @relation(fields: [infoFileRecordName, infoFileName], references: [recordName, fileName], onDelete: SetNull, map: "WebhookRun_infoFile_fkey1")
    
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model NotificationRecord {
    @@id([recordName, address])

    recordName String @db.String(128)
    record Record @relation(fields: [recordName], references: [name], onDelete: Cascade, map: "NotificationRecord_recordName_fkey1")

    address String @db.String(512)

    description String? @db.String(2048)

    markers String[]

    subscriptions NotificationSubscription[]
    sentNotifications SentNotification[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model PushSubscription {
    id String @id @db.Uuid

    endpoint String @db.String(1024)
    keys Json

    active Boolean

    users PushSubscriptionUser[]
    sentNotifications SentPushNotification[]
    subscriptions NotificationSubscription[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@index([active])
}

model PushSubscriptionUser {
    @@id([pushSubscriptionId, userId])

    pushSubscriptionId String @db.Uuid
    pushSubscription PushSubscription @relation(fields: [pushSubscriptionId], references: [id], onDelete: Cascade, map: "PushSubscriptionUser_pushSubscriptionId_fkey1")

    userId String
    user User @relation(fields: [userId], references: [id], onDelete: Cascade, map: "PushSubscriptionUser_userId_fkey1")

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model NotificationSubscription {
    id String @id @db.Uuid

    recordName String @db.String(128)
    record Record @relation(fields: [recordName], references: [name], onDelete: Cascade, map: "NotificationSubscription_recordName_fkey1")

    notificationAddress String @db.String(512)
    notification NotificationRecord @relation(fields: [recordName, notificationAddress], references: [recordName, address], onDelete: Cascade, map: "NotificationSubscription_notificationAddress_fkey1")

    userId String?
    user User? @relation(fields: [userId], references: [id])

    pushSubscriptionId String? @db.Uuid
    pushSubscription PushSubscription? @relation(fields: [pushSubscriptionId], references: [id])

    sentNotifications SentPushNotification[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@unique([recordName, notificationAddress, userId])
    @@unique([recordName, notificationAddress, pushSubscriptionId])
}

model SentNotification {
    id String @id @db.Uuid

    recordName String @db.String(128)
    record Record @relation(fields: [recordName], references: [name], onDelete: Cascade, map: "SentNotification_recordName_fkey1")

    notificationAddress String @db.String(512)
    notification NotificationRecord @relation(fields: [recordName, notificationAddress], references: [recordName, address], onDelete: Cascade, map: "SentNotification_notificationAddress_fkey1")

    title String @db.String(128)
    body String @db.String(512)
    icon String? @db.String(1024)
    badge String? @db.String(1024)
    silent Boolean?

    tag String? @db.String(128)
    topic String? @db.String(128)

    defaultAction Json
    actions Json
    sentTime DateTime

    sentToDevices SentPushNotification[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model SentPushNotification {
    id String @id @db.Uuid

    sentNotificationId String @db.Uuid
    sentNotification SentNotification @relation(fields: [sentNotificationId], references: [id], onDelete: Cascade, map: "SentNotificationUser_sentNotificationId_fkey1")

    subscriptionId String? @db.Uuid
    subscription NotificationSubscription? @relation(fields: [subscriptionId], references: [id], onDelete: SetNull, map: "SentNotificationUser_subscriptionId_fkey1")

    userId String?
    user User? @relation(fields: [userId], references: [id], onDelete: Cascade, map: "SentNotificationUser_userId_fkey1")

    pushSubscriptionId String? @db.Uuid
    pushSubscription PushSubscription? @relation(fields: [pushSubscriptionId], references: [id], onDelete: SetNull, map: "SentNotificationUser_pushSubscriptionId_fkey1")

    success Boolean
    errorCode String?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model PackageRecord {
    id String @id @db.Uuid

    recordName String @db.String(128)
    record Record @relation(fields: [recordName], references: [name], onDelete: Cascade, map: "PackageRecord_recordName_fkey1")

    address String @db.String(128)

    markers String[]

    versions PackageRecordVersion[]
    grantedEntitlements GrantedPackageEntitlement[]
    loadedPackages LoadedPackage[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@unique([recordName, address])
}

model PackageRecordVersion {
    id String @db.Uuid @id

    recordName String @db.String(128)
    record Record @relation(fields: [recordName], references: [name], onDelete: Cascade, map: "PackageRecordVersion_recordName_fkey1")

    address String @db.String(128)
    package PackageRecord @relation(fields: [recordName, address], references: [recordName, address], onDelete: Cascade, map: "PackageRecordVersion_address_fkey1")

    // The major version of the package
    major Int

    // The minor version of the package
    minor Int

    // The patch version of the package
    patch Int

    // The tag of the package
    tag String? @db.String(16)

    // The SHA256 hash of the package
    sha256 String @db.String(64) @unique

    // The SHA256 hash of the package aux data
    auxSha256 String @db.String(64)

    // The aux data of the package
    auxFileName String
    fileRecord FileRecord @relation(fields: [recordName, auxFileName], references: [recordName, fileName], onDelete: Restrict, map: "PackageRecordVersion_auxFileName_fkey1")

    // The list of entitlements that this package version requires
    entitlements Json

    // Whether the package version requires review
    requiresReview Boolean

    // The README of the package
    description String

    // The markers that the package version has
    markers String[]

    // The size of the package version in bytes
    sizeInBytes Int

    // Whether the file was created by this version being uploaded
    createdFile Boolean

    // The list of reviews for the package version
    reviews PackageRecordVersionReview[]
    loadedPackages LoadedPackage[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@unique([recordName, address, major, minor, patch, tag])
}

model PackageRecordVersionReview {
    id String @id @db.Uuid

    packageVersionId String @db.Uuid
    package PackageRecordVersion @relation(fields: [packageVersionId], references: [id], onDelete: Cascade, map: "PackageRecordVersionReview_packageVersionId_fkey1")

    // Whether the package version was approved for use
    approved Boolean

    // The type of approval
    approvalType String?

    // The status of the review
    // can be "pending", "approved", "rejected"
    reviewStatus String

    // Any additional comments by the reviewer
    reviewComments String @db.String(4096)

    // The ID of the user that reviewed the package version
    reviewingUserId String @db.String(128)
    reviewingUser User @relation(fields: [reviewingUserId], references: [id], onDelete: Cascade, map: "PackageRecordVersionReview_reviewingUserId_fkey1")

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model SearchRecord {
    @@id([recordName, address])

    recordName String @db.String(128)
    record Record @relation(fields: [recordName], references: [name], onDelete: Cascade, map: "SearchRecord_recordName_fkey1")
    
    address String @db.String(100)

    // The name of the collection that this record is associated with in Typesense.
    collectionName String @db.String(128)

    // The API key that can be used to search inside this record.
    searchApiKey String @db.String(128)

    markers String[]

    syncs SearchRecordSync[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model SearchRecordSync {
    id String @id @db.Uuid

    searchRecordName String @db.String(128)
    searchRecordAddress String @db.String(128)

    searchRecord SearchRecord @relation(fields: [searchRecordName, searchRecordAddress], references: [recordName, address], onDelete: Cascade, map: "SearchRecordSync_searchRecord_fkey1")

    targetRecordName String @db.String(128)
    targetResourceKind String @db.String(32)
    targetMarker String @db.String(128)
    targetMapping Json

    history SearchRecordSyncHistory[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@unique([searchRecordName, searchRecordAddress, targetRecordName, targetResourceKind, targetMarker])
}

model SearchRecordSyncHistory {
    id String @id @db.Uuid

    searchRecordName String @db.String(128)
    searchRecordAddress String @db.String(128)

    syncId String @db.Uuid
    sync SearchRecordSync @relation(fields: [syncId], references: [id], onDelete: Cascade, map: "SearchRecordSyncHistory_sync_fkey1")

    runId String @db.Uuid

    time DateTime
    status String @db.String(32)
    success Boolean

    numSynced Int
    numErrored Int

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model DatabaseRecord {
    @@id([recordName, address])

    recordName String @db.String(128)
    record Record @relation(fields: [recordName], references: [name], onDelete: Cascade, map: "DatabaseRecord_recordName_fkey1")
    
    address String @db.String(100)

    databaseName String @db.String(100)
    
    // The provider for the database
    // For now, this must be "turso"
    databaseProvider String

    databaseInfo Json

    markers String[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model PurchasableItemRecord {
    @@id([recordName, address])

    recordName String @db.String(128)
    record Record @relation(fields: [recordName], references: [name], onDelete: Cascade, map: "PurchasableItemRecord_recordName_fkey1")

    address String @db.String(512)
    name String @db.String(128)
    description String @db.String(1024)
    imageUrls String[]

    currency String @db.String(15)
    cost Int
    taxCode String? @db.String(64)

    roleName String @db.String(128)
    roleGrantTimeMs Int?

    // redirectUrl String @db.String(2048)
    markers String[]

    purchasedItems PurchasedItem[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model AuthCheckoutSession {
    id String @id @db.Uuid

    paid Boolean
    fulfilledAt DateTime?
    items Json

    // returnUrl String @db.String(2048)
    // successUrl String @db.String(2048)
    
    stripeStatus String?
    stripePaymentStatus String?
    stripeCheckoutSessionId String? @unique

    invoiceId String? @unique @db.Uuid
    invoice Invoice?

    userId String?
    user User? @relation(fields: [userId], references: [id], onDelete: SetNull, map: "PurchasableItemCheckoutSession_userId_fkey1")

    transactionId String?
    transferIds String[]
    transfersPending Boolean?
    shouldBeAutomaticallyFulfilled Boolean?

    purchasedItems PurchasedItem[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model PurchasedItem {
    id String @id @db.Uuid

    recordName String @db.String(128)
    record Record @relation(fields: [recordName], references: [name], onDelete: Cascade, map: "PurchasedItem_recordName_fkey1")

    userId String?
    user User? @relation(fields: [userId], references: [id], onDelete: Cascade, map: "PurchasedItem_userId_fkey1")

    purchasableItemAddress String @db.String(512)
    purchasableItem PurchasableItemRecord @relation(fields: [recordName, purchasableItemAddress], references: [recordName, address], onDelete: Restrict, map: "PurchasedItem_purchasableItemAddress_fkey1")

    checkoutSessionId String? @db.Uuid
    checkoutSession AuthCheckoutSession? @relation(fields: [checkoutSessionId], references: [id], onDelete: SetNull, map: "PurchasedItem_checkoutSessionId_fkey1")

    roleName String @db.String(128)
    roleGrantTimeMs Int?

    // The time that the item was activated
    activatedTime DateTime?
    
    // The activation key that was used to activate the item
    activationKeyId String?
    activationKey ActivationKey? @relation(fields: [activationKeyId], references: [id], onDelete: SetNull, map: "PurchasedItem_activationKeyId_fkey1")

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model ActivationKey {
    id String @id

    // The hash that can be used to associate the item with a user account
    secretHash String

    purchasedItems PurchasedItem[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model Configuration {
    key String @id
    data Json
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model Subscription {
    id String @id @db.Uuid
    stripeSubscriptionId String @unique

    userId String? @unique
    user User? @relation()

    studioId String? @unique
    studio Studio? @relation()

    subscriptionStatus String?
    stripeCustomerId String? @unique
    subscriptionId String?

    currentPeriodStart DateTime?
    currentPeriodEnd DateTime?

    periods SubscriptionPeriod[]
    invoices Invoice[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model SubscriptionPeriod {
    id String @id @db.Uuid

    subscriptionId String @db.Uuid
    subscription Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade, map: "SubscriptionPeriod_subscriptionId_fkey1")

    invoiceId String @unique @db.Uuid
    invoice Invoice?

    periodStart DateTime
    periodEnd DateTime

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model Invoice {
    id String @id @db.Uuid
    stripeInvoiceId String @unique

    subscriptionId String? @db.Uuid
    subscription Subscription? @relation(fields: [subscriptionId], references: [id], onDelete: Cascade, map: "Invoice_subscriptionId_fkey1")

    periodId String? @unique @db.Uuid
    period SubscriptionPeriod? @relation(fields: [periodId], references: [id], onDelete: Cascade, map: "Invoice_periodId_fkey1")

    checkoutSessionId String? @unique @db.Uuid
    checkoutSession AuthCheckoutSession? @relation(fields: [checkoutSessionId], references: [id], onDelete: Cascade, map: "Invoice_checkoutSessionId_fkey1")

    description String?
    status String
    paid Boolean
    currency String
    total Int
    subtotal Int
    tax Int?

    stripeHostedInvoiceUrl String
    stripeInvoicePdfUrl String

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model AiChatMetrics {
    id String @id @db.Uuid
    createdAt DateTime @default(now())

    tokens Int

    userId String?
    user User? @relation(fields: [userId], references: [id], onDelete: Cascade, map: "AiChatMetrics_userId_fkey1")

    studioId String?
    studio Studio? @relation(fields: [studioId], references: [id], onDelete: Cascade, map: "AiChatMetrics_studioId_fkey1")
}

model AiImageMetrics {
    id String @id @db.Uuid
    createdAt DateTime @default(now())
    squarePixelsGenerated Int

    userId String?
    user User? @relation(fields: [userId], references: [id], onDelete: Cascade, map: "AiImageMetrics_userId_fkey1")

    studioId String?
    studio Studio? @relation(fields: [studioId], references: [id], onDelete: Cascade, map: "AiImageMetrics_studioId_fkey1")
}

model AiSkyboxMetrics {
    id String @id @db.Uuid
    createdAt DateTime @default(now())
    skyboxesGenerated Int

    userId String?
    user User? @relation(fields: [userId], references: [id], onDelete: Cascade, map: "AiSkyboxMetrics_userId_fkey1")

    studioId String?
    studio Studio? @relation(fields: [studioId], references: [id], onDelete: Cascade, map: "AiSkyboxMetrics_studioId_fkey1")
}

model AiSloydMetrics {
    id String @id @db.Uuid

    modelsCreated Int
    name String?
    confidence Float?
    mimeType String
    modelData String
    thumbnailBase64 String?
    baseModelId String?

    createdAt DateTime @default(now())

    userId String?
    user User? @relation(fields: [userId], references: [id], onDelete: Cascade, map: "AiSloydMetrics_userId_fkey1")

    studioId String?
    studio Studio? @relation(fields: [studioId], references: [id], onDelete: Cascade, map: "AiSloydMetrics_studioId_fkey1")
}

model AiOpenAIRealtimeMetrics {
    sessionId String @id @db.Uuid

    request Json

    createdAt DateTime @default(now())

    userId String?
    user User? @relation(fields: [userId], references: [id], onDelete: Cascade, map: "AiOpenAIRealtimeMetrics_userId_fkey1")

    studioId String?
    studio Studio? @relation(fields: [studioId], references: [id], onDelete: Cascade, map: "AiOpenAIRealtimeMetrics_studioId_fkey1")
}

model PrivoClientCredentials {
    id String @id @db.Uuid
    createdAt DateTime @default(now())
    expiresAt DateTime

    accessToken String
    refreshToken String
    expiresAtSeconds Int
    scope String

    @@index([expiresAt])
}

model UserInstReport {
    id String @id @db.Uuid

    recordName String? @db.String(128)
    record Record? @relation(fields: [recordName], references: [name], onDelete: Cascade, map: "UserInstReport_recordName_fkey1")

    inst String @db.String(128)
    instRecord InstRecord? @relation(fields: [recordName, inst], references: [recordName, name], onDelete: Cascade, map: "UserInstReport_inst_fkey1")
    
    reportingUserId String?
    reportingUser User? @relation(fields: [reportingUserId], references: [id], onDelete: Cascade, map: "UserInstReport_reportingUserId_fkey1")

    reportingIpAddress String?
    automaticReport Boolean
    reportReasonText String @db.String(2048)
    reportReason String @db.String(128)
    reportedUrl String @db.String(4096)
    reportedPermalink String @db.String(4096)

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@index([automaticReport, createdAt(sort: Desc), recordName, inst])
    @@index([reportReason, createdAt(sort: Desc), recordName, inst])
}

model ModerationJob {
    id String @id @db.Uuid

    // The ID of the s3 batch job
    s3Id String? @unique

    // The type of the moderation job.
    // Usually for files, but there could be other types of moderation jobs.
    type String

    results FileModerationResult[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@index([type, createdAt(sort: Desc)])
}

model FileModerationResult {
    // The ID of the moderation result.
    id String @id @db.Uuid

    // The job that this moderation result is associated with
    jobId String? @db.Uuid
    job ModerationJob? @relation(fields: [jobId], references: [id], onDelete: Cascade, map: "FileModerationResult_jobId_fkey1")

    // The name of the record that was moderated
    recordName String @db.String(128)

    // The name of the file that was moderated
    fileName String @db.String(512)

    // Whether the file contains content that has been
    // algorithmically determined to be banned.
    appearsToMatchBannedContent Boolean

    // The labels that were detected in the file
    labels FileModerationLabel[]

    // The version of the model that was used to produce this result
    modelVersion String

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // Search by banned content status
    @@index([appearsToMatchBannedContent, fileName, createdAt(sort: Desc)])
}

model FileModerationLabel {
    // The ID of the moderation label
    id String @id @db.Uuid

    // The name of the label
    name String @db.String(128)

    // The category of the label
    category String? @db.String(128)

    // The confidence of the label
    confidence Float

    // The ID of the moderation result that this label is associated with
    fileModerationId String @db.Uuid
    fileModeration FileModerationResult @relation(fields: [fileModerationId], references: [id], onDelete: Cascade, map: "FileModerationLabel_fileModerationId_fkey1")

    @@index([fileModerationId, name, confidence])
}

model StudioComIdRequest {
    id String @id @db.Uuid

    studioId String
    studio Studio @relation(fields: [studioId], references: [id], onDelete: Cascade, map: "StudioComIdRequest_studioId_fkey1")

    requestedComId String @db.String(128)

    userId String?
    user User? @relation(fields: [userId], references: [id], onDelete: SetNull, map: "StudioComIdRequest_userId_fkey1")

    requestingIpAddress String?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model FinancialAccount {
    id String @id @db.String(128)

    userId String?
    user User? @relation(fields: [userId], references: [id], onDelete: Restrict, map: "FinancialAccount_userId_fkey1")

    studioId String?
    studio Studio? @relation(fields: [studioId], references: [id], onDelete: Restrict, map: "FinancialAccount_studioId_fkey1")

    contractId String? @db.Uuid @unique
    contract ContractRecord? @relation(fields: [contractId], references: [id], onUpdate: Restrict, onDelete: Restrict, map: "FinancialAccount_contractId_fkey1")

    ledger Int
    currency String @db.String(15)

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@unique([userId, studioId, contractId, ledger])
}

// A contract record is a promise of work at a certain rate
model ContractRecord {
    id String @db.Uuid @id

    // The record that owns the contract.
    // That is, the record that the contract was issued from.
    recordName String @db.String(128)
    record Record @relation(fields: [recordName], references: [name], onDelete: Cascade, map: "ContractRecord_recordName_fkey1")
    address String @db.String(512)

    // The user that issued the contract
    // That is, the user who created the contract in the record.
    // (Similar to subjectId in other record types)
    issuerUserId String
    issuer User @relation(fields: [issuerUserId], references: [id], onDelete: Restrict, map: "ContractRecord_issuerId_fkey1", name: "IssuerUser")

    // The user that is holding the contract
    // That is, the user who is doing the work and getting paid
    holdingUserId String
    holdingUser User @relation(fields: [holdingUserId], references: [id], onDelete: Restrict, map: "ContractRecord_holdingUserId_fkey1", name: "HoldingUser")

    // The rate at which gigs are paid in the contract
    // The rate is in the smallest unit of the currency (e.g. cents for USD)
    // The currency should always be the same as the account
    rate Int

    // The initial value of the contract in the smallest unit of the currency (all gigs) if the contract is a draft
    // This is what would appear in the contract's account if the contract was opened
    initialValue Int

    // The description of the contract
    description String?

    // The status of the contract
    // "open" - the contract is open and can be invoiced
    // "closed" - the contract is closed and cannot be invoiced
    status String

    account FinancialAccount?

    // The ID of the stripe checkout session that was used to pay for the contract
    stripeCheckoutSessionId String? @db.String(128) @unique

    // The ID of the stripe payment intent that was used to pay for the contract
    stripePaymentIntentId String? @db.String(128) @unique

    issuedAt DateTime
    closedAt DateTime?

    markers String[]

    invoices ContractInvoice[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@unique([recordName, address])
}

// An invoice is a request for payment for part of a contract
model ContractInvoice {
    id String @id @db.Uuid

    contractId String @db.Uuid
    contract ContractRecord @relation(fields: [contractId], references: [id], onDelete: Cascade, map: "ContractInvoice_contractId_fkey1")

    // The amount charged in the invoice, in the smallest unit of the currency used in the contracts account
    amount Int

    // The status of the invoice
    // "open" - the invoice has been created but not yet paid
    // "paid" - the invoice has been paid
    // "void" - the invoice has been cancelled
    status String

    // Where the invoice payment should end up.
    // "stripe" - the invoice should be paid out to the contract holder's stripe account
    // "xpExchange - the invoice should be paid out to the contract holder's xp exchange account
    payoutDestination String

    // The reason why the invoice was voided
    // "rejected" - the invoice was rejected by the receiver
    // "cancelled" - the invoice was cancelled by the issuer
    voidReason String?

    // The ID of the transaction that paid the invoice
    transactionId String? @db.String(128)

    // Additional information about the invoice
    note String?

    openedAt DateTime
    paidAt DateTime?
    voidedAt DateTime?

    externalPayoutId String? @db.Uuid @unique
    externalPayout ExternalPayout? @relation()

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}


model ExternalPayout {
    id String @id @db.Uuid

    invoiceId String? @db.Uuid @unique
    invoice ContractInvoice? @relation(fields: [invoiceId], references: [id], onDelete: Restrict, map: "ExternalPayout_invoiceId_fkey1")

    userId String
    user User @relation(fields: [userId], references: [id], onDelete: Cascade, map: "ExternalPayout_userId_fkey1")

    transferId String @db.String(128) @unique
    transactionId String @db.String(128)
    externalDestination String @db.String(32)

    stripeTransferId String?
    destinationStripeAccountId String?

    amount Int

    postedTransferId String? @db.String(128)
    voidedTransferId String? @db.String(128)

    initiatedAt DateTime
    postedAt DateTime?
    voidedAt DateTime?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

// Represents a custom domain that a studio has setup
model CustomDomain {
    id String @id @db.Uuid

    studioId String
    studio Studio @relation(fields: [studioId], references: [id], onDelete: Cascade, map: "CustomDomain_studioId_fkey1")

    // The domain name that is being used
    domainName String @db.String(256)

    // The HMAC-SHA-256 key used to validate requests for this domain
    verificationKey String @db.String(256)

    // Whether the domain has been verified
    // Null if not yet verified
    verified Boolean?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@unique([domainName, verified])
    @@unique([studioId, domainName])
    @@index([domainName])
}

